/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// DecisionDefinitionAPIService DecisionDefinitionAPI service
type DecisionDefinitionAPIService service

type ApiEvaluateDecisionByIdRequest struct {
	ctx                 context.Context
	ApiService          *DecisionDefinitionAPIService
	id                  string
	evaluateDecisionDto *EvaluateDecisionDto
}

func (r ApiEvaluateDecisionByIdRequest) EvaluateDecisionDto(evaluateDecisionDto EvaluateDecisionDto) ApiEvaluateDecisionByIdRequest {
	r.evaluateDecisionDto = &evaluateDecisionDto
	return r
}

func (r ApiEvaluateDecisionByIdRequest) Execute() ([]map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.EvaluateDecisionByIdExecute(r)
}

/*
EvaluateDecisionById Evaluate By Id

Evaluates a given decision and returns the result.
The input values of the decision have to be supplied in the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision definition to be evaluated.
	@return ApiEvaluateDecisionByIdRequest
*/
func (a *DecisionDefinitionAPIService) EvaluateDecisionById(ctx context.Context, id string) ApiEvaluateDecisionByIdRequest {
	return ApiEvaluateDecisionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []map[string]VariableValueDto
func (a *DecisionDefinitionAPIService) EvaluateDecisionByIdExecute(r ApiEvaluateDecisionByIdRequest) ([]map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.EvaluateDecisionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/{id}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluateDecisionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvaluateDecisionByKeyRequest struct {
	ctx                 context.Context
	ApiService          *DecisionDefinitionAPIService
	key                 string
	evaluateDecisionDto *EvaluateDecisionDto
}

func (r ApiEvaluateDecisionByKeyRequest) EvaluateDecisionDto(evaluateDecisionDto EvaluateDecisionDto) ApiEvaluateDecisionByKeyRequest {
	r.evaluateDecisionDto = &evaluateDecisionDto
	return r
}

func (r ApiEvaluateDecisionByKeyRequest) Execute() ([]map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.EvaluateDecisionByKeyExecute(r)
}

/*
EvaluateDecisionByKey Evaluate By Key

Evaluates the latest version of the decision definition which belongs to no tenant.
The input values of the decision have to be supplied in the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be evaluated.
	@return ApiEvaluateDecisionByKeyRequest
*/
func (a *DecisionDefinitionAPIService) EvaluateDecisionByKey(ctx context.Context, key string) ApiEvaluateDecisionByKeyRequest {
	return ApiEvaluateDecisionByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return []map[string]VariableValueDto
func (a *DecisionDefinitionAPIService) EvaluateDecisionByKeyExecute(r ApiEvaluateDecisionByKeyRequest) ([]map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.EvaluateDecisionByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluateDecisionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvaluateDecisionByKeyAndTenantRequest struct {
	ctx                 context.Context
	ApiService          *DecisionDefinitionAPIService
	key                 string
	tenantId            string
	evaluateDecisionDto *EvaluateDecisionDto
}

func (r ApiEvaluateDecisionByKeyAndTenantRequest) EvaluateDecisionDto(evaluateDecisionDto EvaluateDecisionDto) ApiEvaluateDecisionByKeyAndTenantRequest {
	r.evaluateDecisionDto = &evaluateDecisionDto
	return r
}

func (r ApiEvaluateDecisionByKeyAndTenantRequest) Execute() ([]map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.EvaluateDecisionByKeyAndTenantExecute(r)
}

/*
EvaluateDecisionByKeyAndTenant Evaluate By Key And Tenant

Evaluates the latest version of the decision definition for tenant.
The input values of the decision have to be supplied in the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be evaluated.
	@param tenantId The id of the tenant the decision definition belongs to.
	@return ApiEvaluateDecisionByKeyAndTenantRequest
*/
func (a *DecisionDefinitionAPIService) EvaluateDecisionByKeyAndTenant(ctx context.Context, key string, tenantId string) ApiEvaluateDecisionByKeyAndTenantRequest {
	return ApiEvaluateDecisionByKeyAndTenantRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return []map[string]VariableValueDto
func (a *DecisionDefinitionAPIService) EvaluateDecisionByKeyAndTenantExecute(r ApiEvaluateDecisionByKeyAndTenantRequest) ([]map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.EvaluateDecisionByKeyAndTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/tenant-id/{tenant-id}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluateDecisionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionByIdRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	id         string
}

func (r ApiGetDecisionDefinitionByIdRequest) Execute() (*DecisionDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionByIdExecute(r)
}

/*
GetDecisionDefinitionById Get Decision Definition By Id

Retrieves a decision definition by id, according to the `DecisionDefinition` interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision definition to be retrieved.
	@return ApiGetDecisionDefinitionByIdRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionById(ctx context.Context, id string) ApiGetDecisionDefinitionByIdRequest {
	return ApiGetDecisionDefinitionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionByIdExecute(r ApiGetDecisionDefinitionByIdRequest) (*DecisionDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
}

func (r ApiGetDecisionDefinitionByKeyRequest) Execute() (*DecisionDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionByKeyExecute(r)
}

/*
GetDecisionDefinitionByKey Get Decision Definition By Key

Retrieves the latest version of the decision definition which belongs to no tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be retrieved.
	@return ApiGetDecisionDefinitionByKeyRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionByKey(ctx context.Context, key string) ApiGetDecisionDefinitionByKeyRequest {
	return ApiGetDecisionDefinitionByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionByKeyExecute(r ApiGetDecisionDefinitionByKeyRequest) (*DecisionDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionByKeyAndTenantIdRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionDefinitionByKeyAndTenantIdRequest) Execute() (*DecisionDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionByKeyAndTenantIdExecute(r)
}

/*
GetDecisionDefinitionByKeyAndTenantId Get Decision Definition By Key And Tenant Id

Retrieves the latest version of the decision definition for tenant

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be retrieved.
	@param tenantId The id of the tenant the decision definition belongs to.
	@return ApiGetDecisionDefinitionByKeyAndTenantIdRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetDecisionDefinitionByKeyAndTenantIdRequest {
	return ApiGetDecisionDefinitionByKeyAndTenantIdRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionByKeyAndTenantIdExecute(r ApiGetDecisionDefinitionByKeyAndTenantIdRequest) (*DecisionDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/tenant-id/{tenant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDiagramRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	id         string
}

func (r ApiGetDecisionDefinitionDiagramRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDiagramExecute(r)
}

/*
GetDecisionDefinitionDiagram Get Diagram

Retrieves the diagram of a decision definition.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the process definition.
	@return ApiGetDecisionDefinitionDiagramRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagram(ctx context.Context, id string) ApiGetDecisionDefinitionDiagramRequest {
	return ApiGetDecisionDefinitionDiagramRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagramExecute(r ApiGetDecisionDefinitionDiagramRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDiagram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/{id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDiagramByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
}

func (r ApiGetDecisionDefinitionDiagramByKeyRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDiagramByKeyExecute(r)
}

/*
GetDecisionDefinitionDiagramByKey Get Diagram By Key

Returns the diagram for the latest version of the decision definition which belongs to no tenant

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be retrieved.
	@return ApiGetDecisionDefinitionDiagramByKeyRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagramByKey(ctx context.Context, key string) ApiGetDecisionDefinitionDiagramByKeyRequest {
	return ApiGetDecisionDefinitionDiagramByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagramByKeyExecute(r ApiGetDecisionDefinitionDiagramByKeyRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDiagramByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDiagramByKeyAndTenantExecute(r)
}

/*
GetDecisionDefinitionDiagramByKeyAndTenant Get Diagram By Key And Tenant

Returns the XML of the latest version of the decision definition for tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof) to be retrieved.
	@param tenantId The id of the tenant the decision definition belongs to.
	@return ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagramByKeyAndTenant(ctx context.Context, key string, tenantId string) ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest {
	return ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDiagramByKeyAndTenantExecute(r ApiGetDecisionDefinitionDiagramByKeyAndTenantRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDiagramByKeyAndTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/tenant-id/{tenant-id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDmnXmlByIdRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	id         string
}

func (r ApiGetDecisionDefinitionDmnXmlByIdRequest) Execute() (*DecisionDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDmnXmlByIdExecute(r)
}

/*
GetDecisionDefinitionDmnXmlById Get XML By Id

Retrieves the DMN XML of a decision definition.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision definition.
	@return ApiGetDecisionDefinitionDmnXmlByIdRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlById(ctx context.Context, id string) ApiGetDecisionDefinitionDmnXmlByIdRequest {
	return ApiGetDecisionDefinitionDmnXmlByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDiagramDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlByIdExecute(r ApiGetDecisionDefinitionDmnXmlByIdRequest) (*DecisionDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDmnXmlById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/{id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDmnXmlByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
}

func (r ApiGetDecisionDefinitionDmnXmlByKeyRequest) Execute() (*DecisionDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDmnXmlByKeyExecute(r)
}

/*
GetDecisionDefinitionDmnXmlByKey Get XML By Key

Retrieves the XML for the latest version of the decision definition which belongs to no tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof).
	@return ApiGetDecisionDefinitionDmnXmlByKeyRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlByKey(ctx context.Context, key string) ApiGetDecisionDefinitionDmnXmlByKeyRequest {
	return ApiGetDecisionDefinitionDmnXmlByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDiagramDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlByKeyExecute(r ApiGetDecisionDefinitionDmnXmlByKeyRequest) (*DecisionDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDmnXmlByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest struct {
	ctx        context.Context
	ApiService *DecisionDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest) Execute() (*DecisionDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionDmnXmlByKeyAndTenantExecute(r)
}

/*
GetDecisionDefinitionDmnXmlByKeyAndTenant Get XML By Key and Tenant

Retrieves the XML of the latest version of the decision definition for tenant

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definition (the latest version thereof).
	@param tenantId The id of the tenant the decision definition belongs to.
	@return ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlByKeyAndTenant(ctx context.Context, key string, tenantId string) ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest {
	return ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return DecisionDefinitionDiagramDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionDmnXmlByKeyAndTenantExecute(r ApiGetDecisionDefinitionDmnXmlByKeyAndTenantRequest) (*DecisionDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionDmnXmlByKeyAndTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/tenant-id/{tenant-id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionsRequest struct {
	ctx                                       context.Context
	ApiService                                *DecisionDefinitionAPIService
	sortBy                                    *string
	sortOrder                                 *string
	firstResult                               *int32
	maxResults                                *int32
	decisionDefinitionId                      *string
	decisionDefinitionIdIn                    *string
	name                                      *string
	nameLike                                  *string
	deploymentId                              *string
	deployedAfter                             *time.Time
	deployedAt                                *time.Time
	key                                       *string
	keyLike                                   *string
	category                                  *string
	categoryLike                              *string
	version                                   *int32
	latestVersion                             *bool
	resourceName                              *string
	resourceNameLike                          *string
	decisionRequirementsDefinitionId          *string
	decisionRequirementsDefinitionKey         *string
	withoutDecisionRequirementsDefinition     *bool
	tenantIdIn                                *string
	withoutTenantId                           *bool
	includeDecisionDefinitionsWithoutTenantId *bool
	versionTag                                *string
	versionTagLike                            *string
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetDecisionDefinitionsRequest) SortBy(sortBy string) ApiGetDecisionDefinitionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetDecisionDefinitionsRequest) SortOrder(sortOrder string) ApiGetDecisionDefinitionsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetDecisionDefinitionsRequest) FirstResult(firstResult int32) ApiGetDecisionDefinitionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetDecisionDefinitionsRequest) MaxResults(maxResults int32) ApiGetDecisionDefinitionsRequest {
	r.maxResults = &maxResults
	return r
}

// Filter by decision definition id.
func (r ApiGetDecisionDefinitionsRequest) DecisionDefinitionId(decisionDefinitionId string) ApiGetDecisionDefinitionsRequest {
	r.decisionDefinitionId = &decisionDefinitionId
	return r
}

// Filter by decision definition ids.
func (r ApiGetDecisionDefinitionsRequest) DecisionDefinitionIdIn(decisionDefinitionIdIn string) ApiGetDecisionDefinitionsRequest {
	r.decisionDefinitionIdIn = &decisionDefinitionIdIn
	return r
}

// Filter by decision definition name.
func (r ApiGetDecisionDefinitionsRequest) Name(name string) ApiGetDecisionDefinitionsRequest {
	r.name = &name
	return r
}

// Filter by decision definition names that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsRequest) NameLike(nameLike string) ApiGetDecisionDefinitionsRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment the id belongs to.
func (r ApiGetDecisionDefinitionsRequest) DeploymentId(deploymentId string) ApiGetDecisionDefinitionsRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by the deploy time of the deployment the decision definition belongs to. Only selects decision definitions that have been deployed after (exclusive) a specific time.
func (r ApiGetDecisionDefinitionsRequest) DeployedAfter(deployedAfter time.Time) ApiGetDecisionDefinitionsRequest {
	r.deployedAfter = &deployedAfter
	return r
}

// Filter by the deploy time of the deployment the decision definition belongs to. Only selects decision definitions that have been deployed at a specific time (exact match).
func (r ApiGetDecisionDefinitionsRequest) DeployedAt(deployedAt time.Time) ApiGetDecisionDefinitionsRequest {
	r.deployedAt = &deployedAt
	return r
}

// Filter by decision definition key, i.e., the id in the DMN 1.0 XML. Exact match.
func (r ApiGetDecisionDefinitionsRequest) Key(key string) ApiGetDecisionDefinitionsRequest {
	r.key = &key
	return r
}

// Filter by decision definition keys that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsRequest) KeyLike(keyLike string) ApiGetDecisionDefinitionsRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by decision definition category. Exact match.
func (r ApiGetDecisionDefinitionsRequest) Category(category string) ApiGetDecisionDefinitionsRequest {
	r.category = &category
	return r
}

// Filter by decision definition categories that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsRequest) CategoryLike(categoryLike string) ApiGetDecisionDefinitionsRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by decision definition version.
func (r ApiGetDecisionDefinitionsRequest) Version(version int32) ApiGetDecisionDefinitionsRequest {
	r.version = &version
	return r
}

// Only include those decision definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsRequest) LatestVersion(latestVersion bool) ApiGetDecisionDefinitionsRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the decision definition resource. Exact match.
func (r ApiGetDecisionDefinitionsRequest) ResourceName(resourceName string) ApiGetDecisionDefinitionsRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those decision definition resources that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsRequest) ResourceNameLike(resourceNameLike string) ApiGetDecisionDefinitionsRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by the id of the decision requirements definition this decision definition belongs to.
func (r ApiGetDecisionDefinitionsRequest) DecisionRequirementsDefinitionId(decisionRequirementsDefinitionId string) ApiGetDecisionDefinitionsRequest {
	r.decisionRequirementsDefinitionId = &decisionRequirementsDefinitionId
	return r
}

// Filter by the key of the decision requirements definition this decision definition belongs to.
func (r ApiGetDecisionDefinitionsRequest) DecisionRequirementsDefinitionKey(decisionRequirementsDefinitionKey string) ApiGetDecisionDefinitionsRequest {
	r.decisionRequirementsDefinitionKey = &decisionRequirementsDefinitionKey
	return r
}

// Only include decision definitions which does not belongs to any decision requirements definition. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsRequest) WithoutDecisionRequirementsDefinition(withoutDecisionRequirementsDefinition bool) ApiGetDecisionDefinitionsRequest {
	r.withoutDecisionRequirementsDefinition = &withoutDecisionRequirementsDefinition
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A decision definition must have one of the given tenant ids.
func (r ApiGetDecisionDefinitionsRequest) TenantIdIn(tenantIdIn string) ApiGetDecisionDefinitionsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include decision definitions which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsRequest) WithoutTenantId(withoutTenantId bool) ApiGetDecisionDefinitionsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include decision definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsRequest) IncludeDecisionDefinitionsWithoutTenantId(includeDecisionDefinitionsWithoutTenantId bool) ApiGetDecisionDefinitionsRequest {
	r.includeDecisionDefinitionsWithoutTenantId = &includeDecisionDefinitionsWithoutTenantId
	return r
}

// Filter by the version tag.
func (r ApiGetDecisionDefinitionsRequest) VersionTag(versionTag string) ApiGetDecisionDefinitionsRequest {
	r.versionTag = &versionTag
	return r
}

// Filter by the version tags of those decision definition resources that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsRequest) VersionTagLike(versionTagLike string) ApiGetDecisionDefinitionsRequest {
	r.versionTagLike = &versionTagLike
	return r
}

func (r ApiGetDecisionDefinitionsRequest) Execute() ([]DecisionDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionsExecute(r)
}

/*
GetDecisionDefinitions Get List

Queries for decision definitions that fulfill given parameters.
Parameters may be the properties of decision definitions, such as the name, key or version.
The size of the result set can be retrieved by using
the [Get Decision Definition Count](https://docs.operaton.org/manual/1.0/reference/rest/decision-definition/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDecisionDefinitionsRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitions(ctx context.Context) ApiGetDecisionDefinitionsRequest {
	return ApiGetDecisionDefinitionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DecisionDefinitionDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionsExecute(r ApiGetDecisionDefinitionsRequest) ([]DecisionDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DecisionDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.decisionDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionDefinitionId", r.decisionDefinitionId, "")
	}
	if r.decisionDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionDefinitionIdIn", r.decisionDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.deployedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAfter", r.deployedAfter, "")
	}
	if r.deployedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAt", r.deployedAt, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.decisionRequirementsDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionId", r.decisionRequirementsDefinitionId, "")
	}
	if r.decisionRequirementsDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionKey", r.decisionRequirementsDefinitionKey, "")
	}
	if r.withoutDecisionRequirementsDefinition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDecisionRequirementsDefinition", r.withoutDecisionRequirementsDefinition, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeDecisionDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDecisionDefinitionsWithoutTenantId", r.includeDecisionDefinitionsWithoutTenantId, "")
	}
	if r.versionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTag", r.versionTag, "")
	}
	if r.versionTagLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTagLike", r.versionTagLike, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionDefinitionsCountRequest struct {
	ctx                                       context.Context
	ApiService                                *DecisionDefinitionAPIService
	decisionDefinitionId                      *string
	decisionDefinitionIdIn                    *string
	name                                      *string
	nameLike                                  *string
	deploymentId                              *string
	deployedAfter                             *time.Time
	deployedAt                                *time.Time
	key                                       *string
	keyLike                                   *string
	category                                  *string
	categoryLike                              *string
	version                                   *int32
	latestVersion                             *bool
	resourceName                              *string
	resourceNameLike                          *string
	decisionRequirementsDefinitionId          *string
	decisionRequirementsDefinitionKey         *string
	withoutDecisionRequirementsDefinition     *bool
	tenantIdIn                                *string
	withoutTenantId                           *bool
	includeDecisionDefinitionsWithoutTenantId *bool
	versionTag                                *string
	versionTagLike                            *string
}

// Filter by decision definition id.
func (r ApiGetDecisionDefinitionsCountRequest) DecisionDefinitionId(decisionDefinitionId string) ApiGetDecisionDefinitionsCountRequest {
	r.decisionDefinitionId = &decisionDefinitionId
	return r
}

// Filter by decision definition ids.
func (r ApiGetDecisionDefinitionsCountRequest) DecisionDefinitionIdIn(decisionDefinitionIdIn string) ApiGetDecisionDefinitionsCountRequest {
	r.decisionDefinitionIdIn = &decisionDefinitionIdIn
	return r
}

// Filter by decision definition name.
func (r ApiGetDecisionDefinitionsCountRequest) Name(name string) ApiGetDecisionDefinitionsCountRequest {
	r.name = &name
	return r
}

// Filter by decision definition names that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsCountRequest) NameLike(nameLike string) ApiGetDecisionDefinitionsCountRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment the id belongs to.
func (r ApiGetDecisionDefinitionsCountRequest) DeploymentId(deploymentId string) ApiGetDecisionDefinitionsCountRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by the deploy time of the deployment the decision definition belongs to. Only selects decision definitions that have been deployed after (exclusive) a specific time.
func (r ApiGetDecisionDefinitionsCountRequest) DeployedAfter(deployedAfter time.Time) ApiGetDecisionDefinitionsCountRequest {
	r.deployedAfter = &deployedAfter
	return r
}

// Filter by the deploy time of the deployment the decision definition belongs to. Only selects decision definitions that have been deployed at a specific time (exact match).
func (r ApiGetDecisionDefinitionsCountRequest) DeployedAt(deployedAt time.Time) ApiGetDecisionDefinitionsCountRequest {
	r.deployedAt = &deployedAt
	return r
}

// Filter by decision definition key, i.e., the id in the DMN 1.0 XML. Exact match.
func (r ApiGetDecisionDefinitionsCountRequest) Key(key string) ApiGetDecisionDefinitionsCountRequest {
	r.key = &key
	return r
}

// Filter by decision definition keys that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsCountRequest) KeyLike(keyLike string) ApiGetDecisionDefinitionsCountRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by decision definition category. Exact match.
func (r ApiGetDecisionDefinitionsCountRequest) Category(category string) ApiGetDecisionDefinitionsCountRequest {
	r.category = &category
	return r
}

// Filter by decision definition categories that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsCountRequest) CategoryLike(categoryLike string) ApiGetDecisionDefinitionsCountRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by decision definition version.
func (r ApiGetDecisionDefinitionsCountRequest) Version(version int32) ApiGetDecisionDefinitionsCountRequest {
	r.version = &version
	return r
}

// Only include those decision definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsCountRequest) LatestVersion(latestVersion bool) ApiGetDecisionDefinitionsCountRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the decision definition resource. Exact match.
func (r ApiGetDecisionDefinitionsCountRequest) ResourceName(resourceName string) ApiGetDecisionDefinitionsCountRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those decision definition resources that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsCountRequest) ResourceNameLike(resourceNameLike string) ApiGetDecisionDefinitionsCountRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by the id of the decision requirements definition this decision definition belongs to.
func (r ApiGetDecisionDefinitionsCountRequest) DecisionRequirementsDefinitionId(decisionRequirementsDefinitionId string) ApiGetDecisionDefinitionsCountRequest {
	r.decisionRequirementsDefinitionId = &decisionRequirementsDefinitionId
	return r
}

// Filter by the key of the decision requirements definition this decision definition belongs to.
func (r ApiGetDecisionDefinitionsCountRequest) DecisionRequirementsDefinitionKey(decisionRequirementsDefinitionKey string) ApiGetDecisionDefinitionsCountRequest {
	r.decisionRequirementsDefinitionKey = &decisionRequirementsDefinitionKey
	return r
}

// Only include decision definitions which does not belongs to any decision requirements definition. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsCountRequest) WithoutDecisionRequirementsDefinition(withoutDecisionRequirementsDefinition bool) ApiGetDecisionDefinitionsCountRequest {
	r.withoutDecisionRequirementsDefinition = &withoutDecisionRequirementsDefinition
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A decision definition must have one of the given tenant ids.
func (r ApiGetDecisionDefinitionsCountRequest) TenantIdIn(tenantIdIn string) ApiGetDecisionDefinitionsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include decision definitions which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetDecisionDefinitionsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include decision definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionDefinitionsCountRequest) IncludeDecisionDefinitionsWithoutTenantId(includeDecisionDefinitionsWithoutTenantId bool) ApiGetDecisionDefinitionsCountRequest {
	r.includeDecisionDefinitionsWithoutTenantId = &includeDecisionDefinitionsWithoutTenantId
	return r
}

// Filter by the version tag.
func (r ApiGetDecisionDefinitionsCountRequest) VersionTag(versionTag string) ApiGetDecisionDefinitionsCountRequest {
	r.versionTag = &versionTag
	return r
}

// Filter by the version tags of those decision definition resources that the parameter is a substring of.
func (r ApiGetDecisionDefinitionsCountRequest) VersionTagLike(versionTagLike string) ApiGetDecisionDefinitionsCountRequest {
	r.versionTagLike = &versionTagLike
	return r
}

func (r ApiGetDecisionDefinitionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetDecisionDefinitionsCountExecute(r)
}

/*
GetDecisionDefinitionsCount Get List Count

Requests the number of decision definitions that fulfill the query criteria.
Takes the same filtering parameters as the
[Get Decision Definition](https://docs.operaton.org/manual/1.0/reference/rest/decision-definition/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDecisionDefinitionsCountRequest
*/
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionsCount(ctx context.Context) ApiGetDecisionDefinitionsCountRequest {
	return ApiGetDecisionDefinitionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *DecisionDefinitionAPIService) GetDecisionDefinitionsCountExecute(r ApiGetDecisionDefinitionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.GetDecisionDefinitionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.decisionDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionDefinitionId", r.decisionDefinitionId, "")
	}
	if r.decisionDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionDefinitionIdIn", r.decisionDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.deployedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAfter", r.deployedAfter, "")
	}
	if r.deployedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAt", r.deployedAt, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.decisionRequirementsDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionId", r.decisionRequirementsDefinitionId, "")
	}
	if r.decisionRequirementsDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionKey", r.decisionRequirementsDefinitionKey, "")
	}
	if r.withoutDecisionRequirementsDefinition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDecisionRequirementsDefinition", r.withoutDecisionRequirementsDefinition, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeDecisionDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDecisionDefinitionsWithoutTenantId", r.includeDecisionDefinitionsWithoutTenantId, "")
	}
	if r.versionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTag", r.versionTag, "")
	}
	if r.versionTagLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTagLike", r.versionTagLike, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest struct {
	ctx                  context.Context
	ApiService           *DecisionDefinitionAPIService
	id                   string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByDecisionDefinitionIdExecute(r)
}

/*
UpdateHistoryTimeToLiveByDecisionDefinitionId Update History Time to Live

Updates history time to live for decision definition.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision definition to change history time to live.
	@return ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest
*/
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionId(ctx context.Context, id string) ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest {
	return ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionIdExecute(r ApiUpdateHistoryTimeToLiveByDecisionDefinitionIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.UpdateHistoryTimeToLiveByDecisionDefinitionId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/{id}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest struct {
	ctx                  context.Context
	ApiService           *DecisionDefinitionAPIService
	key                  string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByDecisionDefinitionKeyExecute(r)
}

/*
UpdateHistoryTimeToLiveByDecisionDefinitionKey Update History Time to Live By Key

Updates the latest version of the decision definition which belongs to no tenant.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definitions to change history time to live.
	@return ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest
*/
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionKey(ctx context.Context, key string) ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest {
	return ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionKeyExecute(r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.UpdateHistoryTimeToLiveByDecisionDefinitionKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest struct {
	ctx                  context.Context
	ApiService           *DecisionDefinitionAPIService
	key                  string
	tenantId             string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantExecute(r)
}

/*
UpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenant Update History Time to Live By Key And Tenant

Updates the latest version of the decision definition for tenant.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).
The value of the update is mandatory by default and does not allow `null` values. To enable them, please
set the feature flag `enforceHistoryTimeToLive` to `false`. Read more in [Configuration Properties]
(https://docs.operaton.org/manual/1.0/reference/deployment-descriptors/tags/process-engine#configuration-properties)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision definitions to change history time to live.
	@param tenantId The id of the tenant the decision definition belongs to.
	@return ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest
*/
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenant(ctx context.Context, key string, tenantId string) ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest {
	return ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
func (a *DecisionDefinitionAPIService) UpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantExecute(r ApiUpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionDefinitionAPIService.UpdateHistoryTimeToLiveByDecisionDefinitionKeyAndTenant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-definition/key/{key}/tenant-id/{tenant-id}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
