/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// DecisionRequirementsDefinitionAPIService DecisionRequirementsDefinitionAPI service
type DecisionRequirementsDefinitionAPIService service

type ApiGetDecisionRequirementsDefinitionByIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	id         string
}

func (r ApiGetDecisionRequirementsDefinitionByIdRequest) Execute() (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionByIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionById Get Decision Requirements Definition by ID

Retrieves a decision requirements definition according to the
`DecisionRequirementsDefinition` interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision requirements definition to be retrieved.
	@return ApiGetDecisionRequirementsDefinitionByIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionById(ctx context.Context, id string) ApiGetDecisionRequirementsDefinitionByIdRequest {
	return ApiGetDecisionRequirementsDefinitionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionByIdExecute(r ApiGetDecisionRequirementsDefinitionByIdRequest) (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
}

func (r ApiGetDecisionRequirementsDefinitionByKeyRequest) Execute() (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionByKeyExecute(r)
}

/*
GetDecisionRequirementsDefinitionByKey Get Decision Requirements Definition by Key

Retrieves a decision requirements definition according to the
`DecisionRequirementsDefinition` interface in the engine.
Returns the latest version of the decision requirements definition
which belongs to no tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@return ApiGetDecisionRequirementsDefinitionByKeyRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionByKey(ctx context.Context, key string) ApiGetDecisionRequirementsDefinitionByKeyRequest {
	return ApiGetDecisionRequirementsDefinitionByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionByKeyExecute(r ApiGetDecisionRequirementsDefinitionByKeyRequest) (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest) Execute() (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionByKeyAndTenantIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionByKeyAndTenantId Get Decision Requirements Definition by Key and Tenant ID

Retrieves a decision requirements definition according to the
`DecisionRequirementsDefinition` interface in the engine.
Returns the latest version of the decision requirements definition
for a tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@param tenantId The id of the tenant to which the decision requirements definition belongs to.
	@return ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest {
	return ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionByKeyAndTenantIdExecute(r ApiGetDecisionRequirementsDefinitionByKeyAndTenantIdRequest) (*DecisionRequirementsDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}/tenant-id/{tenant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDiagramByIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	id         string
}

func (r ApiGetDecisionRequirementsDefinitionDiagramByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDiagramByIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionDiagramById Get Decision Requirements Diagram by ID

Retrieves the diagram of a decision requirements definition.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision requirements definition.
	@return ApiGetDecisionRequirementsDefinitionDiagramByIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramById(ctx context.Context, id string) ApiGetDecisionRequirementsDefinitionDiagramByIdRequest {
	return ApiGetDecisionRequirementsDefinitionDiagramByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramByIdExecute(r ApiGetDecisionRequirementsDefinitionDiagramByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDiagramById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/{id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
}

func (r ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDiagramByKeyExecute(r)
}

/*
GetDecisionRequirementsDefinitionDiagramByKey Get Decision Requirements Diagram by Key

Retrieves the diagram of a decision requirements definition.
Returns the diagram for the latest version of the decision requirements
definition which belongs to no tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@return ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramByKey(ctx context.Context, key string) ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest {
	return ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramByKeyExecute(r ApiGetDecisionRequirementsDefinitionDiagramByKeyRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDiagramByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionDiagramByKeyAndTenantId Get Decision Requirements Diagram by Key and Tenant ID

Retrieves the diagram of a decision requirements definition.
Returns the diagram of the latest version of the decision requirements
definition for a tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@param tenantId The id of the tenant to which the decision requirements definition belongs to.
	@return ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest {
	return ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdExecute(r ApiGetDecisionRequirementsDefinitionDiagramByKeyAndTenantIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDiagramByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}/tenant-id/{tenant-id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	id         string
}

func (r ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest) Execute() (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDmnXmlByIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionDmnXmlById Get DMN XML by ID

Retrieves the DMN XML of a decision requirements definition.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the decision requirements definition.
	@return ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlById(ctx context.Context, id string) ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest {
	return ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionXmlDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlByIdExecute(r ApiGetDecisionRequirementsDefinitionDmnXmlByIdRequest) (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionXmlDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDmnXmlById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/{id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
}

func (r ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest) Execute() (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDmnXmlByKeyExecute(r)
}

/*
GetDecisionRequirementsDefinitionDmnXmlByKey Get DMN XML by Key

Retrieves the DMN XML of a decision requirements definition.
Returns the XML for the latest version of the decision requirements
definition which belongs to no tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@return ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlByKey(ctx context.Context, key string) ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest {
	return ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionXmlDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlByKeyExecute(r ApiGetDecisionRequirementsDefinitionDmnXmlByKeyRequest) (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionXmlDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDmnXmlByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest struct {
	ctx        context.Context
	ApiService *DecisionRequirementsDefinitionAPIService
	key        string
	tenantId   string
}

func (r ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest) Execute() (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdExecute(r)
}

/*
GetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantId Get DMN XML by Key and Tenant ID

Retrieves the DMN XML of a decision requirements definition.
Returns the XML of the latest version of the decision requirements
definition for a tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key The key of the decision requirements definition (the latest version thereof) to be retrieved.
	@param tenantId The id of the tenant to which the decision requirements definition belongs to.
	@return ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest {
	return ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return DecisionRequirementsDefinitionXmlDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdExecute(r ApiGetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantIdRequest) (*DecisionRequirementsDefinitionXmlDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecisionRequirementsDefinitionXmlDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionDmnXmlByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/key/{key}/tenant-id/{tenant-id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionsRequest struct {
	ctx                                                   context.Context
	ApiService                                            *DecisionRequirementsDefinitionAPIService
	decisionRequirementsDefinitionId                      *string
	decisionRequirementsDefinitionIdIn                    *string
	name                                                  *string
	nameLike                                              *string
	deploymentId                                          *string
	key                                                   *string
	keyLike                                               *string
	category                                              *string
	categoryLike                                          *string
	version                                               *int32
	latestVersion                                         *bool
	resourceName                                          *string
	resourceNameLike                                      *string
	tenantIdIn                                            *string
	withoutTenantId                                       *bool
	includeDecisionRequirementsDefinitionsWithoutTenantId *bool
	sortBy                                                *string
	sortOrder                                             *string
	firstResult                                           *int32
	maxResults                                            *int32
}

// Filter by decision requirements definition id.
func (r ApiGetDecisionRequirementsDefinitionsRequest) DecisionRequirementsDefinitionId(decisionRequirementsDefinitionId string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.decisionRequirementsDefinitionId = &decisionRequirementsDefinitionId
	return r
}

// Filter by decision requirements definition ids.
func (r ApiGetDecisionRequirementsDefinitionsRequest) DecisionRequirementsDefinitionIdIn(decisionRequirementsDefinitionIdIn string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.decisionRequirementsDefinitionIdIn = &decisionRequirementsDefinitionIdIn
	return r
}

// Filter by decision requirements definition name.
func (r ApiGetDecisionRequirementsDefinitionsRequest) Name(name string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.name = &name
	return r
}

// Filter by decision requirements definition names that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsRequest) NameLike(nameLike string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the id of the deployment a decision requirement definition belongs to.
func (r ApiGetDecisionRequirementsDefinitionsRequest) DeploymentId(deploymentId string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by decision requirements definition key, i.e., the id in the DMN 1.3 XML. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsRequest) Key(key string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.key = &key
	return r
}

// Filter by decision requirements definition keys that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsRequest) KeyLike(keyLike string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by decision requirements definition category. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsRequest) Category(category string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.category = &category
	return r
}

// Filter by decision requirements definition categories that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsRequest) CategoryLike(categoryLike string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by decision requirements definition version.
func (r ApiGetDecisionRequirementsDefinitionsRequest) Version(version int32) ApiGetDecisionRequirementsDefinitionsRequest {
	r.version = &version
	return r
}

// Only include those decision requirements definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsRequest) LatestVersion(latestVersion bool) ApiGetDecisionRequirementsDefinitionsRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the decision requirements definition resource. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsRequest) ResourceName(resourceName string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those decision requirements definition resources that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsRequest) ResourceNameLike(resourceNameLike string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by a comma-separated list of tenant ids. A decision requirements definition must have one of the given tenant ids.
func (r ApiGetDecisionRequirementsDefinitionsRequest) TenantIdIn(tenantIdIn string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include decision requirements definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsRequest) WithoutTenantId(withoutTenantId bool) ApiGetDecisionRequirementsDefinitionsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include decision requirements definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsRequest) IncludeDecisionRequirementsDefinitionsWithoutTenantId(includeDecisionRequirementsDefinitionsWithoutTenantId bool) ApiGetDecisionRequirementsDefinitionsRequest {
	r.includeDecisionRequirementsDefinitionsWithoutTenantId = &includeDecisionRequirementsDefinitionsWithoutTenantId
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetDecisionRequirementsDefinitionsRequest) SortBy(sortBy string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetDecisionRequirementsDefinitionsRequest) SortOrder(sortOrder string) ApiGetDecisionRequirementsDefinitionsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetDecisionRequirementsDefinitionsRequest) FirstResult(firstResult int32) ApiGetDecisionRequirementsDefinitionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetDecisionRequirementsDefinitionsRequest) MaxResults(maxResults int32) ApiGetDecisionRequirementsDefinitionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetDecisionRequirementsDefinitionsRequest) Execute() ([]DecisionRequirementsDefinitionDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionsExecute(r)
}

/*
GetDecisionRequirementsDefinitions Get Decision Requirements Definitions

Queries for decision requirements definitions that fulfill given parameters.
Parameters may be the properties of decision requirements definitions, such as the name,
key or version.  The size of the result set can be retrieved by using the
[Get Decision Requirements Definition Count](https://docs.operaton.org/manual/1.0/reference/rest/decision-requirements-definition/get-query-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDecisionRequirementsDefinitionsRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitions(ctx context.Context) ApiGetDecisionRequirementsDefinitionsRequest {
	return ApiGetDecisionRequirementsDefinitionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DecisionRequirementsDefinitionDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionsExecute(r ApiGetDecisionRequirementsDefinitionsRequest) ([]DecisionRequirementsDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DecisionRequirementsDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.decisionRequirementsDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionId", r.decisionRequirementsDefinitionId, "")
	}
	if r.decisionRequirementsDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionIdIn", r.decisionRequirementsDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeDecisionRequirementsDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDecisionRequirementsDefinitionsWithoutTenantId", r.includeDecisionRequirementsDefinitionsWithoutTenantId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDecisionRequirementsDefinitionsCountRequest struct {
	ctx                                                   context.Context
	ApiService                                            *DecisionRequirementsDefinitionAPIService
	decisionRequirementsDefinitionId                      *string
	decisionRequirementsDefinitionIdIn                    *string
	name                                                  *string
	nameLike                                              *string
	deploymentId                                          *string
	key                                                   *string
	keyLike                                               *string
	category                                              *string
	categoryLike                                          *string
	version                                               *int32
	latestVersion                                         *bool
	resourceName                                          *string
	resourceNameLike                                      *string
	tenantIdIn                                            *string
	withoutTenantId                                       *bool
	includeDecisionRequirementsDefinitionsWithoutTenantId *bool
}

// Filter by decision requirements definition id.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) DecisionRequirementsDefinitionId(decisionRequirementsDefinitionId string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.decisionRequirementsDefinitionId = &decisionRequirementsDefinitionId
	return r
}

// Filter by decision requirements definition ids.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) DecisionRequirementsDefinitionIdIn(decisionRequirementsDefinitionIdIn string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.decisionRequirementsDefinitionIdIn = &decisionRequirementsDefinitionIdIn
	return r
}

// Filter by decision requirements definition name.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) Name(name string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.name = &name
	return r
}

// Filter by decision requirements definition names that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) NameLike(nameLike string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the id of the deployment a decision requirement definition belongs to.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) DeploymentId(deploymentId string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by decision requirements definition key, i.e., the id in the DMN 1.3 XML. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) Key(key string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.key = &key
	return r
}

// Filter by decision requirements definition keys that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) KeyLike(keyLike string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by decision requirements definition category. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) Category(category string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.category = &category
	return r
}

// Filter by decision requirements definition categories that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) CategoryLike(categoryLike string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by decision requirements definition version.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) Version(version int32) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.version = &version
	return r
}

// Only include those decision requirements definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) LatestVersion(latestVersion bool) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the decision requirements definition resource. Exact match.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) ResourceName(resourceName string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those decision requirements definition resources that the parameter is a substring of.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) ResourceNameLike(resourceNameLike string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by a comma-separated list of tenant ids. A decision requirements definition must have one of the given tenant ids.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) TenantIdIn(tenantIdIn string) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include decision requirements definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include decision requirements definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDecisionRequirementsDefinitionsCountRequest) IncludeDecisionRequirementsDefinitionsWithoutTenantId(includeDecisionRequirementsDefinitionsWithoutTenantId bool) ApiGetDecisionRequirementsDefinitionsCountRequest {
	r.includeDecisionRequirementsDefinitionsWithoutTenantId = &includeDecisionRequirementsDefinitionsWithoutTenantId
	return r
}

func (r ApiGetDecisionRequirementsDefinitionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetDecisionRequirementsDefinitionsCountExecute(r)
}

/*
GetDecisionRequirementsDefinitionsCount Get Decision Requirements Definition Count

Requests the number of decision requirements definitions that fulfill the query
criteria.
Takes the same filtering parameters as the
[Get Decision Requirements Definitions](https://docs.operaton.org/manual/1.0/reference/rest/decision-requirements-definition/get-query/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDecisionRequirementsDefinitionsCountRequest
*/
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionsCount(ctx context.Context) ApiGetDecisionRequirementsDefinitionsCountRequest {
	return ApiGetDecisionRequirementsDefinitionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *DecisionRequirementsDefinitionAPIService) GetDecisionRequirementsDefinitionsCountExecute(r ApiGetDecisionRequirementsDefinitionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DecisionRequirementsDefinitionAPIService.GetDecisionRequirementsDefinitionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/decision-requirements-definition/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.decisionRequirementsDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionId", r.decisionRequirementsDefinitionId, "")
	}
	if r.decisionRequirementsDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionRequirementsDefinitionIdIn", r.decisionRequirementsDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeDecisionRequirementsDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDecisionRequirementsDefinitionsWithoutTenantId", r.includeDecisionRequirementsDefinitionsWithoutTenantId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
