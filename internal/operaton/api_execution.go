/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// ExecutionAPIService ExecutionAPI service
type ExecutionAPIService service

type ApiCreateIncidentRequest struct {
	ctx               context.Context
	ApiService        *ExecutionAPIService
	id                string
	createIncidentDto *CreateIncidentDto
}

func (r ApiCreateIncidentRequest) CreateIncidentDto(createIncidentDto CreateIncidentDto) ApiCreateIncidentRequest {
	r.createIncidentDto = &createIncidentDto
	return r
}

func (r ApiCreateIncidentRequest) Execute() (*IncidentDto, *http.Response, error) {
	return r.ApiService.CreateIncidentExecute(r)
}

/*
CreateIncident Create Incident

Creates a custom incident with given properties.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to create a new incident for.
	@return ApiCreateIncidentRequest
*/
func (a *ExecutionAPIService) CreateIncident(ctx context.Context, id string) ApiCreateIncidentRequest {
	return ApiCreateIncidentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IncidentDto
func (a *ExecutionAPIService) CreateIncidentExecute(r ApiCreateIncidentRequest) (*IncidentDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IncidentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.CreateIncident")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/create-incident"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIncidentDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLocalExecutionVariableRequest struct {
	ctx        context.Context
	ApiService *ExecutionAPIService
	id         string
	varName    string
}

func (r ApiDeleteLocalExecutionVariableRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLocalExecutionVariableExecute(r)
}

/*
DeleteLocalExecutionVariable Delete Local Execution Variable

Deletes a variable in the context of a given execution by id. Deletion does not
propagate upwards in the execution hierarchy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to delete the variable from.
	@param varName The name of the variable to delete.
	@return ApiDeleteLocalExecutionVariableRequest
*/
func (a *ExecutionAPIService) DeleteLocalExecutionVariable(ctx context.Context, id string, varName string) ApiDeleteLocalExecutionVariableRequest {
	return ApiDeleteLocalExecutionVariableRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		varName:    varName,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) DeleteLocalExecutionVariableExecute(r ApiDeleteLocalExecutionVariableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.DeleteLocalExecutionVariable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables/{varName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"varName"+"}", url.PathEscape(parameterValueToString(r.varName, "varName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetExecutionRequest struct {
	ctx        context.Context
	ApiService *ExecutionAPIService
	id         string
}

func (r ApiGetExecutionRequest) Execute() (*ExecutionDto, *http.Response, error) {
	return r.ApiService.GetExecutionExecute(r)
}

/*
GetExecution Get Execution

Retrieves an execution by id, according to the `Execution` interface in the
engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to be retrieved.
	@return ApiGetExecutionRequest
*/
func (a *ExecutionAPIService) GetExecution(ctx context.Context, id string) ApiGetExecutionRequest {
	return ApiGetExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ExecutionDto
func (a *ExecutionAPIService) GetExecutionExecute(r ApiGetExecutionRequest) (*ExecutionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExecutionsRequest struct {
	ctx                          context.Context
	ApiService                   *ExecutionAPIService
	businessKey                  *string
	processDefinitionId          *string
	processDefinitionKey         *string
	processInstanceId            *string
	activityId                   *string
	signalEventSubscriptionName  *string
	messageEventSubscriptionName *string
	active                       *bool
	suspended                    *bool
	incidentId                   *string
	incidentType                 *string
	incidentMessage              *string
	incidentMessageLike          *string
	tenantIdIn                   *string
	variables                    *string
	processVariables             *string
	variableNamesIgnoreCase      *bool
	variableValuesIgnoreCase     *bool
	sortBy                       *string
	sortOrder                    *string
	firstResult                  *int32
	maxResults                   *int32
}

// Filter by the business key of the process instances the executions belong to.
func (r ApiGetExecutionsRequest) BusinessKey(businessKey string) ApiGetExecutionsRequest {
	r.businessKey = &businessKey
	return r
}

// Filter by the process definition the executions run on.
func (r ApiGetExecutionsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetExecutionsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the key of the process definition the executions run on.
func (r ApiGetExecutionsRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetExecutionsRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Filter by the id of the process instance the execution belongs to.
func (r ApiGetExecutionsRequest) ProcessInstanceId(processInstanceId string) ApiGetExecutionsRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by the id of the activity the execution currently executes.
func (r ApiGetExecutionsRequest) ActivityId(activityId string) ApiGetExecutionsRequest {
	r.activityId = &activityId
	return r
}

// Select only those executions that expect a signal of the given name.
func (r ApiGetExecutionsRequest) SignalEventSubscriptionName(signalEventSubscriptionName string) ApiGetExecutionsRequest {
	r.signalEventSubscriptionName = &signalEventSubscriptionName
	return r
}

// Select only those executions that expect a message of the given name.
func (r ApiGetExecutionsRequest) MessageEventSubscriptionName(messageEventSubscriptionName string) ApiGetExecutionsRequest {
	r.messageEventSubscriptionName = &messageEventSubscriptionName
	return r
}

// Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetExecutionsRequest) Active(active bool) ApiGetExecutionsRequest {
	r.active = &active
	return r
}

// Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetExecutionsRequest) Suspended(suspended bool) ApiGetExecutionsRequest {
	r.suspended = &suspended
	return r
}

// Filter by the incident id.
func (r ApiGetExecutionsRequest) IncidentId(incidentId string) ApiGetExecutionsRequest {
	r.incidentId = &incidentId
	return r
}

// Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetExecutionsRequest) IncidentType(incidentType string) ApiGetExecutionsRequest {
	r.incidentType = &incidentType
	return r
}

// Filter by the incident message. Exact match.
func (r ApiGetExecutionsRequest) IncidentMessage(incidentMessage string) ApiGetExecutionsRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Filter by the incident message that the parameter is a substring of.
func (r ApiGetExecutionsRequest) IncidentMessageLike(incidentMessageLike string) ApiGetExecutionsRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
func (r ApiGetExecutionsRequest) TenantIdIn(tenantIdIn string) ApiGetExecutionsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExecutionsRequest) Variables(variables string) ApiGetExecutionsRequest {
	r.variables = &variables
	return r
}

// Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExecutionsRequest) ProcessVariables(processVariables string) ApiGetExecutionsRequest {
	r.processVariables = &processVariables
	return r
}

// Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
func (r ApiGetExecutionsRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetExecutionsRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
func (r ApiGetExecutionsRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetExecutionsRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetExecutionsRequest) SortBy(sortBy string) ApiGetExecutionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetExecutionsRequest) SortOrder(sortOrder string) ApiGetExecutionsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetExecutionsRequest) FirstResult(firstResult int32) ApiGetExecutionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetExecutionsRequest) MaxResults(maxResults int32) ApiGetExecutionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetExecutionsRequest) Execute() ([]ExecutionDto, *http.Response, error) {
	return r.ApiService.GetExecutionsExecute(r)
}

/*
GetExecutions Get Executions

Queries for the executions that fulfill given parameters.
Parameters may be static as well as dynamic runtime properties of
executions.
The size of the result set can be retrieved by using the [Get
Execution Count](https://docs.operaton.org/manual/1.0/reference/rest/execution/get-query-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExecutionsRequest
*/
func (a *ExecutionAPIService) GetExecutions(ctx context.Context) ApiGetExecutionsRequest {
	return ApiGetExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ExecutionDto
func (a *ExecutionAPIService) GetExecutionsExecute(r ApiGetExecutionsRequest) ([]ExecutionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.businessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessKey", r.businessKey, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.signalEventSubscriptionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signalEventSubscriptionName", r.signalEventSubscriptionName, "")
	}
	if r.messageEventSubscriptionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageEventSubscriptionName", r.messageEventSubscriptionName, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.variables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variables", r.variables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExecutionsCountRequest struct {
	ctx                          context.Context
	ApiService                   *ExecutionAPIService
	businessKey                  *string
	processDefinitionId          *string
	processDefinitionKey         *string
	processInstanceId            *string
	activityId                   *string
	signalEventSubscriptionName  *string
	messageEventSubscriptionName *string
	active                       *bool
	suspended                    *bool
	incidentId                   *string
	incidentType                 *string
	incidentMessage              *string
	incidentMessageLike          *string
	tenantIdIn                   *string
	variables                    *string
	processVariables             *string
	variableNamesIgnoreCase      *bool
	variableValuesIgnoreCase     *bool
}

// Filter by the business key of the process instances the executions belong to.
func (r ApiGetExecutionsCountRequest) BusinessKey(businessKey string) ApiGetExecutionsCountRequest {
	r.businessKey = &businessKey
	return r
}

// Filter by the process definition the executions run on.
func (r ApiGetExecutionsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetExecutionsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the key of the process definition the executions run on.
func (r ApiGetExecutionsCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetExecutionsCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Filter by the id of the process instance the execution belongs to.
func (r ApiGetExecutionsCountRequest) ProcessInstanceId(processInstanceId string) ApiGetExecutionsCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by the id of the activity the execution currently executes.
func (r ApiGetExecutionsCountRequest) ActivityId(activityId string) ApiGetExecutionsCountRequest {
	r.activityId = &activityId
	return r
}

// Select only those executions that expect a signal of the given name.
func (r ApiGetExecutionsCountRequest) SignalEventSubscriptionName(signalEventSubscriptionName string) ApiGetExecutionsCountRequest {
	r.signalEventSubscriptionName = &signalEventSubscriptionName
	return r
}

// Select only those executions that expect a message of the given name.
func (r ApiGetExecutionsCountRequest) MessageEventSubscriptionName(messageEventSubscriptionName string) ApiGetExecutionsCountRequest {
	r.messageEventSubscriptionName = &messageEventSubscriptionName
	return r
}

// Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetExecutionsCountRequest) Active(active bool) ApiGetExecutionsCountRequest {
	r.active = &active
	return r
}

// Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetExecutionsCountRequest) Suspended(suspended bool) ApiGetExecutionsCountRequest {
	r.suspended = &suspended
	return r
}

// Filter by the incident id.
func (r ApiGetExecutionsCountRequest) IncidentId(incidentId string) ApiGetExecutionsCountRequest {
	r.incidentId = &incidentId
	return r
}

// Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetExecutionsCountRequest) IncidentType(incidentType string) ApiGetExecutionsCountRequest {
	r.incidentType = &incidentType
	return r
}

// Filter by the incident message. Exact match.
func (r ApiGetExecutionsCountRequest) IncidentMessage(incidentMessage string) ApiGetExecutionsCountRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Filter by the incident message that the parameter is a substring of.
func (r ApiGetExecutionsCountRequest) IncidentMessageLike(incidentMessageLike string) ApiGetExecutionsCountRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
func (r ApiGetExecutionsCountRequest) TenantIdIn(tenantIdIn string) ApiGetExecutionsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExecutionsCountRequest) Variables(variables string) ApiGetExecutionsCountRequest {
	r.variables = &variables
	return r
}

// Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExecutionsCountRequest) ProcessVariables(processVariables string) ApiGetExecutionsCountRequest {
	r.processVariables = &processVariables
	return r
}

// Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
func (r ApiGetExecutionsCountRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetExecutionsCountRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
func (r ApiGetExecutionsCountRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetExecutionsCountRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

func (r ApiGetExecutionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetExecutionsCountExecute(r)
}

/*
GetExecutionsCount Get Execution Count

Queries for the number of executions that fulfill given parameters.
Takes the same parameters as the [Get
Executions](https://docs.operaton.org/manual/1.0/reference/rest/execution/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExecutionsCountRequest
*/
func (a *ExecutionAPIService) GetExecutionsCount(ctx context.Context) ApiGetExecutionsCountRequest {
	return ApiGetExecutionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *ExecutionAPIService) GetExecutionsCountExecute(r ApiGetExecutionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetExecutionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.businessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessKey", r.businessKey, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.signalEventSubscriptionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signalEventSubscriptionName", r.signalEventSubscriptionName, "")
	}
	if r.messageEventSubscriptionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageEventSubscriptionName", r.messageEventSubscriptionName, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.variables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variables", r.variables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalExecutionVariableRequest struct {
	ctx              context.Context
	ApiService       *ExecutionAPIService
	id               string
	varName          string
	deserializeValue *bool
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetLocalExecutionVariableRequest) DeserializeValue(deserializeValue bool) ApiGetLocalExecutionVariableRequest {
	r.deserializeValue = &deserializeValue
	return r
}

func (r ApiGetLocalExecutionVariableRequest) Execute() (*VariableValueDto, *http.Response, error) {
	return r.ApiService.GetLocalExecutionVariableExecute(r)
}

/*
GetLocalExecutionVariable Get Local Execution Variable

Retrieves a variable from the context of a given execution by id. Does not traverse
the parent execution hierarchy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to retrieve the variable from.
	@param varName The name of the variable to get.
	@return ApiGetLocalExecutionVariableRequest
*/
func (a *ExecutionAPIService) GetLocalExecutionVariable(ctx context.Context, id string, varName string) ApiGetLocalExecutionVariableRequest {
	return ApiGetLocalExecutionVariableRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		varName:    varName,
	}
}

// Execute executes the request
//
//	@return VariableValueDto
func (a *ExecutionAPIService) GetLocalExecutionVariableExecute(r ApiGetLocalExecutionVariableRequest) (*VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetLocalExecutionVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables/{varName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"varName"+"}", url.PathEscape(parameterValueToString(r.varName, "varName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deserializeValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValue", r.deserializeValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalExecutionVariableBinaryRequest struct {
	ctx        context.Context
	ApiService *ExecutionAPIService
	id         string
	varName    string
}

func (r ApiGetLocalExecutionVariableBinaryRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLocalExecutionVariableBinaryExecute(r)
}

/*
GetLocalExecutionVariableBinary Get Local Execution Variable (Binary)

Retrieves a binary variable from the context of a given execution by id. Does not
traverse the parent execution hierarchy. Applicable for byte array and
file variables.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to retrieve the variable from.
	@param varName The name of the variable to get.
	@return ApiGetLocalExecutionVariableBinaryRequest
*/
func (a *ExecutionAPIService) GetLocalExecutionVariableBinary(ctx context.Context, id string, varName string) ApiGetLocalExecutionVariableBinaryRequest {
	return ApiGetLocalExecutionVariableBinaryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		varName:    varName,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ExecutionAPIService) GetLocalExecutionVariableBinaryExecute(r ApiGetLocalExecutionVariableBinaryRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetLocalExecutionVariableBinary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables/{varName}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"varName"+"}", url.PathEscape(parameterValueToString(r.varName, "varName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalExecutionVariablesRequest struct {
	ctx               context.Context
	ApiService        *ExecutionAPIService
	id                string
	deserializeValues *bool
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetLocalExecutionVariablesRequest) DeserializeValues(deserializeValues bool) ApiGetLocalExecutionVariablesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetLocalExecutionVariablesRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetLocalExecutionVariablesExecute(r)
}

/*
GetLocalExecutionVariables Get Local Execution Variables

Retrieves all variables of a given execution by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to retrieve the variables from.
	@return ApiGetLocalExecutionVariablesRequest
*/
func (a *ExecutionAPIService) GetLocalExecutionVariables(ctx context.Context, id string) ApiGetLocalExecutionVariablesRequest {
	return ApiGetLocalExecutionVariablesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]VariableValueDto
func (a *ExecutionAPIService) GetLocalExecutionVariablesExecute(r ApiGetLocalExecutionVariablesRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetLocalExecutionVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageEventSubscriptionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionAPIService
	id          string
	messageName string
}

func (r ApiGetMessageEventSubscriptionRequest) Execute() (*EventSubscriptionDto, *http.Response, error) {
	return r.ApiService.GetMessageEventSubscriptionExecute(r)
}

/*
GetMessageEventSubscription Get Message Event Subscription

Retrieves a message event subscription for a given execution by id and a message
name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution that holds the subscription.
	@param messageName The name of the message that the subscription corresponds to.
	@return ApiGetMessageEventSubscriptionRequest
*/
func (a *ExecutionAPIService) GetMessageEventSubscription(ctx context.Context, id string, messageName string) ApiGetMessageEventSubscriptionRequest {
	return ApiGetMessageEventSubscriptionRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		messageName: messageName,
	}
}

// Execute executes the request
//
//	@return EventSubscriptionDto
func (a *ExecutionAPIService) GetMessageEventSubscriptionExecute(r ApiGetMessageEventSubscriptionRequest) (*EventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.GetMessageEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/messageSubscriptions/{messageName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageName"+"}", url.PathEscape(parameterValueToString(r.messageName, "messageName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyLocalExecutionVariablesRequest struct {
	ctx               context.Context
	ApiService        *ExecutionAPIService
	id                string
	patchVariablesDto *PatchVariablesDto
}

func (r ApiModifyLocalExecutionVariablesRequest) PatchVariablesDto(patchVariablesDto PatchVariablesDto) ApiModifyLocalExecutionVariablesRequest {
	r.patchVariablesDto = &patchVariablesDto
	return r
}

func (r ApiModifyLocalExecutionVariablesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ModifyLocalExecutionVariablesExecute(r)
}

/*
ModifyLocalExecutionVariables Update/Delete Local Execution Variables

Updates or deletes the variables in the context of an execution by id. The updates
do not propagate upwards in the execution hierarchy.
Updates precede deletions. So, if a variable is updated AND deleted,
the deletion overrides the update.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to set variables for.
	@return ApiModifyLocalExecutionVariablesRequest
*/
func (a *ExecutionAPIService) ModifyLocalExecutionVariables(ctx context.Context, id string) ApiModifyLocalExecutionVariablesRequest {
	return ApiModifyLocalExecutionVariablesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) ModifyLocalExecutionVariablesExecute(r ApiModifyLocalExecutionVariablesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ModifyLocalExecutionVariables")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchVariablesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutLocalExecutionVariableRequest struct {
	ctx              context.Context
	ApiService       *ExecutionAPIService
	id               string
	varName          string
	variableValueDto *VariableValueDto
}

func (r ApiPutLocalExecutionVariableRequest) VariableValueDto(variableValueDto VariableValueDto) ApiPutLocalExecutionVariableRequest {
	r.variableValueDto = &variableValueDto
	return r
}

func (r ApiPutLocalExecutionVariableRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutLocalExecutionVariableExecute(r)
}

/*
PutLocalExecutionVariable Put Local Execution Variable

Sets a variable in the context of a given execution by id. Update does not
propagate upwards in the execution hierarchy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to set the variable for.
	@param varName The name of the variable to set.
	@return ApiPutLocalExecutionVariableRequest
*/
func (a *ExecutionAPIService) PutLocalExecutionVariable(ctx context.Context, id string, varName string) ApiPutLocalExecutionVariableRequest {
	return ApiPutLocalExecutionVariableRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		varName:    varName,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) PutLocalExecutionVariableExecute(r ApiPutLocalExecutionVariableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.PutLocalExecutionVariable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables/{varName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"varName"+"}", url.PathEscape(parameterValueToString(r.varName, "varName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.variableValueDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryExecutionsRequest struct {
	ctx               context.Context
	ApiService        *ExecutionAPIService
	firstResult       *int32
	maxResults        *int32
	executionQueryDto *ExecutionQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryExecutionsRequest) FirstResult(firstResult int32) ApiQueryExecutionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryExecutionsRequest) MaxResults(maxResults int32) ApiQueryExecutionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryExecutionsRequest) ExecutionQueryDto(executionQueryDto ExecutionQueryDto) ApiQueryExecutionsRequest {
	r.executionQueryDto = &executionQueryDto
	return r
}

func (r ApiQueryExecutionsRequest) Execute() ([]ExecutionDto, *http.Response, error) {
	return r.ApiService.QueryExecutionsExecute(r)
}

/*
QueryExecutions Get Executions (POST)

Queries for executions that fulfill given parameters through a JSON object.
This method is slightly more powerful than the [Get
Executions](https://docs.operaton.org/manual/1.0/reference/rest/execution/get-query/) method
because it allows
to filter by multiple instance and execution variables of types
`String`, `Number` or `Boolean`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryExecutionsRequest
*/
func (a *ExecutionAPIService) QueryExecutions(ctx context.Context) ApiQueryExecutionsRequest {
	return ApiQueryExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ExecutionDto
func (a *ExecutionAPIService) QueryExecutionsExecute(r ApiQueryExecutionsRequest) ([]ExecutionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.QueryExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryExecutionsCountRequest struct {
	ctx               context.Context
	ApiService        *ExecutionAPIService
	executionQueryDto *ExecutionQueryDto
}

func (r ApiQueryExecutionsCountRequest) ExecutionQueryDto(executionQueryDto ExecutionQueryDto) ApiQueryExecutionsCountRequest {
	r.executionQueryDto = &executionQueryDto
	return r
}

func (r ApiQueryExecutionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryExecutionsCountExecute(r)
}

/*
QueryExecutionsCount Get Execution Count (POST)

Queries for the number of executions that fulfill given parameters. This method
takes the same message body as the [Get Executions
POST](https://docs.operaton.org/manual/1.0/reference/rest/execution/post-query/) method and
therefore it is slightly more powerful than the [Get Execution
Count](https://docs.operaton.org/manual/1.0/reference/rest/execution/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryExecutionsCountRequest
*/
func (a *ExecutionAPIService) QueryExecutionsCount(ctx context.Context) ApiQueryExecutionsCountRequest {
	return ApiQueryExecutionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *ExecutionAPIService) QueryExecutionsCountExecute(r ApiQueryExecutionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.QueryExecutionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLocalExecutionVariableBinaryRequest struct {
	ctx        context.Context
	ApiService *ExecutionAPIService
	id         string
	varName    string
	data       *os.File
	valueType  *string
}

// The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
func (r ApiSetLocalExecutionVariableBinaryRequest) Data(data *os.File) ApiSetLocalExecutionVariableBinaryRequest {
	r.data = data
	return r
}

// The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
func (r ApiSetLocalExecutionVariableBinaryRequest) ValueType(valueType string) ApiSetLocalExecutionVariableBinaryRequest {
	r.valueType = &valueType
	return r
}

func (r ApiSetLocalExecutionVariableBinaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetLocalExecutionVariableBinaryExecute(r)
}

/*
SetLocalExecutionVariableBinary Post Local Execution Variable (Binary)

Sets the serialized value for a binary variable or the binary value for a file
variable in the context of a given execution by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to set the variable for.
	@param varName The name of the variable to set.
	@return ApiSetLocalExecutionVariableBinaryRequest
*/
func (a *ExecutionAPIService) SetLocalExecutionVariableBinary(ctx context.Context, id string, varName string) ApiSetLocalExecutionVariableBinaryRequest {
	return ApiSetLocalExecutionVariableBinaryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		varName:    varName,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) SetLocalExecutionVariableBinaryExecute(r ApiSetLocalExecutionVariableBinaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.SetLocalExecutionVariableBinary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/localVariables/{varName}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"varName"+"}", url.PathEscape(parameterValueToString(r.varName, "varName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var dataLocalVarFormFileName string
	var dataLocalVarFileName string
	var dataLocalVarFileBytes []byte

	dataLocalVarFormFileName = "data"
	dataLocalVarFile := r.data

	if dataLocalVarFile != nil {
		fbs, _ := io.ReadAll(dataLocalVarFile)

		dataLocalVarFileBytes = fbs
		dataLocalVarFileName = dataLocalVarFile.Name()
		dataLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
	}
	if r.valueType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "valueType", r.valueType, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSignalExecutionRequest struct {
	ctx                 context.Context
	ApiService          *ExecutionAPIService
	id                  string
	executionTriggerDto *ExecutionTriggerDto
}

func (r ApiSignalExecutionRequest) ExecutionTriggerDto(executionTriggerDto ExecutionTriggerDto) ApiSignalExecutionRequest {
	r.executionTriggerDto = &executionTriggerDto
	return r
}

func (r ApiSignalExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.SignalExecutionExecute(r)
}

/*
SignalExecution Trigger Execution

Signals an execution by id. Can for example be used to explicitly skip user tasks
or signal asynchronous continuations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to signal.
	@return ApiSignalExecutionRequest
*/
func (a *ExecutionAPIService) SignalExecution(ctx context.Context, id string) ApiSignalExecutionRequest {
	return ApiSignalExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) SignalExecutionExecute(r ApiSignalExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.SignalExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/signal"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionTriggerDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTriggerEventRequest struct {
	ctx                 context.Context
	ApiService          *ExecutionAPIService
	id                  string
	messageName         string
	executionTriggerDto *ExecutionTriggerDto
}

func (r ApiTriggerEventRequest) ExecutionTriggerDto(executionTriggerDto ExecutionTriggerDto) ApiTriggerEventRequest {
	r.executionTriggerDto = &executionTriggerDto
	return r
}

func (r ApiTriggerEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.TriggerEventExecute(r)
}

/*
TriggerEvent Trigger Message Event Subscription

Delivers a message to a specific execution by id, to trigger an existing message
event subscription. Inject process variables as the message's
payload.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the execution to submit the message to.
	@param messageName The name of the message that the addressed subscription corresponds to.
	@return ApiTriggerEventRequest
*/
func (a *ExecutionAPIService) TriggerEvent(ctx context.Context, id string, messageName string) ApiTriggerEventRequest {
	return ApiTriggerEventRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		messageName: messageName,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) TriggerEventExecute(r ApiTriggerEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.TriggerEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/messageSubscriptions/{messageName}/trigger"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageName"+"}", url.PathEscape(parameterValueToString(r.messageName, "messageName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionTriggerDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
