/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ExternalTaskAPIService ExternalTaskAPI service
type ExternalTaskAPIService service

type ApiCompleteExternalTaskResourceRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	completeExternalTaskDto *CompleteExternalTaskDto
}

func (r ApiCompleteExternalTaskResourceRequest) CompleteExternalTaskDto(completeExternalTaskDto CompleteExternalTaskDto) ApiCompleteExternalTaskResourceRequest {
	r.completeExternalTaskDto = &completeExternalTaskDto
	return r
}

func (r ApiCompleteExternalTaskResourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompleteExternalTaskResourceExecute(r)
}

/*
CompleteExternalTaskResource Complete

Completes an external task by id and updates process variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to complete.
 @return ApiCompleteExternalTaskResourceRequest
*/
func (a *ExternalTaskAPIService) CompleteExternalTaskResource(ctx context.Context, id string) ApiCompleteExternalTaskResourceRequest {
	return ApiCompleteExternalTaskResourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) CompleteExternalTaskResourceExecute(r ApiCompleteExternalTaskResourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.CompleteExternalTaskResource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeExternalTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtendLockRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	extendLockOnExternalTaskDto *ExtendLockOnExternalTaskDto
}

func (r ApiExtendLockRequest) ExtendLockOnExternalTaskDto(extendLockOnExternalTaskDto ExtendLockOnExternalTaskDto) ApiExtendLockRequest {
	r.extendLockOnExternalTaskDto = &extendLockOnExternalTaskDto
	return r
}

func (r ApiExtendLockRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtendLockExecute(r)
}

/*
ExtendLock Extend Lock

Extends the timeout of the lock by a given amount of time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task.
 @return ApiExtendLockRequest
*/
func (a *ExternalTaskAPIService) ExtendLock(ctx context.Context, id string) ApiExtendLockRequest {
	return ApiExtendLockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) ExtendLockExecute(r ApiExtendLockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.ExtendLock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/extendLock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extendLockOnExternalTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchAndLockRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	fetchExternalTasksDto *FetchExternalTasksDto
}

func (r ApiFetchAndLockRequest) FetchExternalTasksDto(fetchExternalTasksDto FetchExternalTasksDto) ApiFetchAndLockRequest {
	r.fetchExternalTasksDto = &fetchExternalTasksDto
	return r
}

func (r ApiFetchAndLockRequest) Execute() ([]LockedExternalTaskDto, *http.Response, error) {
	return r.ApiService.FetchAndLockExecute(r)
}

/*
FetchAndLock Fetch and Lock

Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted
to specific task topics and for each task topic an individual lock time can be provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchAndLockRequest
*/
func (a *ExternalTaskAPIService) FetchAndLock(ctx context.Context) ApiFetchAndLockRequest {
	return ApiFetchAndLockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LockedExternalTaskDto
func (a *ExternalTaskAPIService) FetchAndLockExecute(r ApiFetchAndLockRequest) ([]LockedExternalTaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LockedExternalTaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.FetchAndLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/fetchAndLock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fetchExternalTasksDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTaskRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
}

func (r ApiGetExternalTaskRequest) Execute() (*ExternalTaskDto, *http.Response, error) {
	return r.ApiService.GetExternalTaskExecute(r)
}

/*
GetExternalTask Get

Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task to be retrieved.
 @return ApiGetExternalTaskRequest
*/
func (a *ExternalTaskAPIService) GetExternalTask(ctx context.Context, id string) ApiGetExternalTaskRequest {
	return ApiGetExternalTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalTaskDto
func (a *ExternalTaskAPIService) GetExternalTaskExecute(r ApiGetExternalTaskRequest) (*ExternalTaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.GetExternalTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTaskErrorDetailsRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
}

func (r ApiGetExternalTaskErrorDetailsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetExternalTaskErrorDetailsExecute(r)
}

/*
GetExternalTaskErrorDetails Get Error Details

Retrieves the error details in the context of a running external task by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task for which the error details should be retrieved.
 @return ApiGetExternalTaskErrorDetailsRequest
*/
func (a *ExternalTaskAPIService) GetExternalTaskErrorDetails(ctx context.Context, id string) ApiGetExternalTaskErrorDetailsRequest {
	return ApiGetExternalTaskErrorDetailsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return string
func (a *ExternalTaskAPIService) GetExternalTaskErrorDetailsExecute(r ApiGetExternalTaskErrorDetailsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.GetExternalTaskErrorDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/errorDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTasksRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	externalTaskId *string
	externalTaskIdIn *string
	topicName *string
	workerId *string
	locked *bool
	notLocked *bool
	withRetriesLeft *bool
	noRetriesLeft *bool
	lockExpirationAfter *time.Time
	lockExpirationBefore *time.Time
	activityId *string
	activityIdIn *string
	executionId *string
	processInstanceId *string
	processInstanceIdIn *string
	processDefinitionId *string
	tenantIdIn *string
	active *bool
	suspended *bool
	priorityHigherThanOrEquals *int64
	priorityLowerThanOrEquals *int64
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	processVariables *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by an external task&#39;s id.
func (r ApiGetExternalTasksRequest) ExternalTaskId(externalTaskId string) ApiGetExternalTasksRequest {
	r.externalTaskId = &externalTaskId
	return r
}

// Filter by the comma-separated list of external task ids.
func (r ApiGetExternalTasksRequest) ExternalTaskIdIn(externalTaskIdIn string) ApiGetExternalTasksRequest {
	r.externalTaskIdIn = &externalTaskIdIn
	return r
}

// Filter by an external task topic.
func (r ApiGetExternalTasksRequest) TopicName(topicName string) ApiGetExternalTasksRequest {
	r.topicName = &topicName
	return r
}

// Filter by the id of the worker that the task was most recently locked by.
func (r ApiGetExternalTasksRequest) WorkerId(workerId string) ApiGetExternalTasksRequest {
	r.workerId = &workerId
	return r
}

// Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) Locked(locked bool) ApiGetExternalTasksRequest {
	r.locked = &locked
	return r
}

// Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) NotLocked(notLocked bool) ApiGetExternalTasksRequest {
	r.notLocked = &notLocked
	return r
}

// Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) WithRetriesLeft(withRetriesLeft bool) ApiGetExternalTasksRequest {
	r.withRetriesLeft = &withRetriesLeft
	return r
}

// Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) NoRetriesLeft(noRetriesLeft bool) ApiGetExternalTasksRequest {
	r.noRetriesLeft = &noRetriesLeft
	return r
}

// Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetExternalTasksRequest) LockExpirationAfter(lockExpirationAfter time.Time) ApiGetExternalTasksRequest {
	r.lockExpirationAfter = &lockExpirationAfter
	return r
}

// Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetExternalTasksRequest) LockExpirationBefore(lockExpirationBefore time.Time) ApiGetExternalTasksRequest {
	r.lockExpirationBefore = &lockExpirationBefore
	return r
}

// Filter by the id of the activity that an external task is created for.
func (r ApiGetExternalTasksRequest) ActivityId(activityId string) ApiGetExternalTasksRequest {
	r.activityId = &activityId
	return r
}

// Filter by the comma-separated list of ids of the activities that an external task is created for.
func (r ApiGetExternalTasksRequest) ActivityIdIn(activityIdIn string) ApiGetExternalTasksRequest {
	r.activityIdIn = &activityIdIn
	return r
}

// Filter by the id of the execution that an external task belongs to.
func (r ApiGetExternalTasksRequest) ExecutionId(executionId string) ApiGetExternalTasksRequest {
	r.executionId = &executionId
	return r
}

// Filter by the id of the process instance that an external task belongs to.
func (r ApiGetExternalTasksRequest) ProcessInstanceId(processInstanceId string) ApiGetExternalTasksRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by a comma-separated list of process instance ids that an external task may belong to.
func (r ApiGetExternalTasksRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetExternalTasksRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Filter by the id of the process definition that an external task belongs to.
func (r ApiGetExternalTasksRequest) ProcessDefinitionId(processDefinitionId string) ApiGetExternalTasksRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
func (r ApiGetExternalTasksRequest) TenantIdIn(tenantIdIn string) ApiGetExternalTasksRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) Active(active bool) ApiGetExternalTasksRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksRequest) Suspended(suspended bool) ApiGetExternalTasksRequest {
	r.suspended = &suspended
	return r
}

// Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetExternalTasksRequest) PriorityHigherThanOrEquals(priorityHigherThanOrEquals int64) ApiGetExternalTasksRequest {
	r.priorityHigherThanOrEquals = &priorityHigherThanOrEquals
	return r
}

// Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetExternalTasksRequest) PriorityLowerThanOrEquals(priorityLowerThanOrEquals int64) ApiGetExternalTasksRequest {
	r.priorityLowerThanOrEquals = &priorityLowerThanOrEquals
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetExternalTasksRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetExternalTasksRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetExternalTasksRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetExternalTasksRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetExternalTasksRequest) ProcessDefinitionName(processDefinitionName string) ApiGetExternalTasksRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as a substring.
func (r ApiGetExternalTasksRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetExternalTasksRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetExternalTasksRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetExternalTasksRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetExternalTasksRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetExternalTasksRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExternalTasksRequest) ProcessVariables(processVariables string) ApiGetExternalTasksRequest {
	r.processVariables = &processVariables
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetExternalTasksRequest) SortBy(sortBy string) ApiGetExternalTasksRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetExternalTasksRequest) SortOrder(sortOrder string) ApiGetExternalTasksRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetExternalTasksRequest) FirstResult(firstResult int32) ApiGetExternalTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetExternalTasksRequest) MaxResults(maxResults int32) ApiGetExternalTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetExternalTasksRequest) Execute() ([]ExternalTaskDto, *http.Response, error) {
	return r.ApiService.GetExternalTasksExecute(r)
}

/*
GetExternalTasks Get List

Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic
runtime properties of executions. The size of the result set can be retrieved by using the
[Get External Task Count](https://docs.operaton.org/manual/1.0/reference/rest/external-task/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalTasksRequest
*/
func (a *ExternalTaskAPIService) GetExternalTasks(ctx context.Context) ApiGetExternalTasksRequest {
	return ApiGetExternalTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ExternalTaskDto
func (a *ExternalTaskAPIService) GetExternalTasksExecute(r ApiGetExternalTasksRequest) ([]ExternalTaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExternalTaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.GetExternalTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.externalTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalTaskId", r.externalTaskId, "")
	}
	if r.externalTaskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalTaskIdIn", r.externalTaskIdIn, "")
	}
	if r.topicName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topicName", r.topicName, "")
	}
	if r.workerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workerId", r.workerId, "")
	}
	if r.locked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locked", r.locked, "")
	}
	if r.notLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notLocked", r.notLocked, "")
	}
	if r.withRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRetriesLeft", r.withRetriesLeft, "")
	}
	if r.noRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noRetriesLeft", r.noRetriesLeft, "")
	}
	if r.lockExpirationAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lockExpirationAfter", r.lockExpirationAfter, "")
	}
	if r.lockExpirationBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lockExpirationBefore", r.lockExpirationBefore, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.activityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityIdIn", r.activityIdIn, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.priorityHigherThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityHigherThanOrEquals", r.priorityHigherThanOrEquals, "")
	}
	if r.priorityLowerThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityLowerThanOrEquals", r.priorityLowerThanOrEquals, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTasksCountRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	externalTaskId *string
	externalTaskIdIn *string
	topicName *string
	workerId *string
	locked *bool
	notLocked *bool
	withRetriesLeft *bool
	noRetriesLeft *bool
	lockExpirationAfter *time.Time
	lockExpirationBefore *time.Time
	activityId *string
	activityIdIn *string
	executionId *string
	processInstanceId *string
	processInstanceIdIn *string
	processDefinitionId *string
	tenantIdIn *string
	active *bool
	suspended *bool
	priorityHigherThanOrEquals *int64
	priorityLowerThanOrEquals *int64
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	processVariables *string
}

// Filter by an external task&#39;s id.
func (r ApiGetExternalTasksCountRequest) ExternalTaskId(externalTaskId string) ApiGetExternalTasksCountRequest {
	r.externalTaskId = &externalTaskId
	return r
}

// Filter by the comma-separated list of external task ids.
func (r ApiGetExternalTasksCountRequest) ExternalTaskIdIn(externalTaskIdIn string) ApiGetExternalTasksCountRequest {
	r.externalTaskIdIn = &externalTaskIdIn
	return r
}

// Filter by an external task topic.
func (r ApiGetExternalTasksCountRequest) TopicName(topicName string) ApiGetExternalTasksCountRequest {
	r.topicName = &topicName
	return r
}

// Filter by the id of the worker that the task was most recently locked by.
func (r ApiGetExternalTasksCountRequest) WorkerId(workerId string) ApiGetExternalTasksCountRequest {
	r.workerId = &workerId
	return r
}

// Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) Locked(locked bool) ApiGetExternalTasksCountRequest {
	r.locked = &locked
	return r
}

// Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) NotLocked(notLocked bool) ApiGetExternalTasksCountRequest {
	r.notLocked = &notLocked
	return r
}

// Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) WithRetriesLeft(withRetriesLeft bool) ApiGetExternalTasksCountRequest {
	r.withRetriesLeft = &withRetriesLeft
	return r
}

// Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) NoRetriesLeft(noRetriesLeft bool) ApiGetExternalTasksCountRequest {
	r.noRetriesLeft = &noRetriesLeft
	return r
}

// Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetExternalTasksCountRequest) LockExpirationAfter(lockExpirationAfter time.Time) ApiGetExternalTasksCountRequest {
	r.lockExpirationAfter = &lockExpirationAfter
	return r
}

// Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetExternalTasksCountRequest) LockExpirationBefore(lockExpirationBefore time.Time) ApiGetExternalTasksCountRequest {
	r.lockExpirationBefore = &lockExpirationBefore
	return r
}

// Filter by the id of the activity that an external task is created for.
func (r ApiGetExternalTasksCountRequest) ActivityId(activityId string) ApiGetExternalTasksCountRequest {
	r.activityId = &activityId
	return r
}

// Filter by the comma-separated list of ids of the activities that an external task is created for.
func (r ApiGetExternalTasksCountRequest) ActivityIdIn(activityIdIn string) ApiGetExternalTasksCountRequest {
	r.activityIdIn = &activityIdIn
	return r
}

// Filter by the id of the execution that an external task belongs to.
func (r ApiGetExternalTasksCountRequest) ExecutionId(executionId string) ApiGetExternalTasksCountRequest {
	r.executionId = &executionId
	return r
}

// Filter by the id of the process instance that an external task belongs to.
func (r ApiGetExternalTasksCountRequest) ProcessInstanceId(processInstanceId string) ApiGetExternalTasksCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by a comma-separated list of process instance ids that an external task may belong to.
func (r ApiGetExternalTasksCountRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetExternalTasksCountRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Filter by the id of the process definition that an external task belongs to.
func (r ApiGetExternalTasksCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetExternalTasksCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
func (r ApiGetExternalTasksCountRequest) TenantIdIn(tenantIdIn string) ApiGetExternalTasksCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) Active(active bool) ApiGetExternalTasksCountRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetExternalTasksCountRequest) Suspended(suspended bool) ApiGetExternalTasksCountRequest {
	r.suspended = &suspended
	return r
}

// Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetExternalTasksCountRequest) PriorityHigherThanOrEquals(priorityHigherThanOrEquals int64) ApiGetExternalTasksCountRequest {
	r.priorityHigherThanOrEquals = &priorityHigherThanOrEquals
	return r
}

// Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetExternalTasksCountRequest) PriorityLowerThanOrEquals(priorityLowerThanOrEquals int64) ApiGetExternalTasksCountRequest {
	r.priorityLowerThanOrEquals = &priorityLowerThanOrEquals
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetExternalTasksCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetExternalTasksCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetExternalTasksCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetExternalTasksCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetExternalTasksCountRequest) ProcessDefinitionName(processDefinitionName string) ApiGetExternalTasksCountRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as a substring.
func (r ApiGetExternalTasksCountRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetExternalTasksCountRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetExternalTasksCountRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetExternalTasksCountRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetExternalTasksCountRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetExternalTasksCountRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetExternalTasksCountRequest) ProcessVariables(processVariables string) ApiGetExternalTasksCountRequest {
	r.processVariables = &processVariables
	return r
}

func (r ApiGetExternalTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetExternalTasksCountExecute(r)
}

/*
GetExternalTasksCount Get List Count

Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the
[Get External Tasks](https://docs.operaton.org/manual/1.0/reference/rest/external-task/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalTasksCountRequest
*/
func (a *ExternalTaskAPIService) GetExternalTasksCount(ctx context.Context) ApiGetExternalTasksCountRequest {
	return ApiGetExternalTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *ExternalTaskAPIService) GetExternalTasksCountExecute(r ApiGetExternalTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.GetExternalTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.externalTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalTaskId", r.externalTaskId, "")
	}
	if r.externalTaskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalTaskIdIn", r.externalTaskIdIn, "")
	}
	if r.topicName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topicName", r.topicName, "")
	}
	if r.workerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workerId", r.workerId, "")
	}
	if r.locked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locked", r.locked, "")
	}
	if r.notLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notLocked", r.notLocked, "")
	}
	if r.withRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRetriesLeft", r.withRetriesLeft, "")
	}
	if r.noRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noRetriesLeft", r.noRetriesLeft, "")
	}
	if r.lockExpirationAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lockExpirationAfter", r.lockExpirationAfter, "")
	}
	if r.lockExpirationBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lockExpirationBefore", r.lockExpirationBefore, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.activityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityIdIn", r.activityIdIn, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.priorityHigherThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityHigherThanOrEquals", r.priorityHigherThanOrEquals, "")
	}
	if r.priorityLowerThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityLowerThanOrEquals", r.priorityLowerThanOrEquals, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopicNamesRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	withLockedTasks *bool
	withUnlockedTasks *bool
	withRetriesLeft *bool
}

// Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetTopicNamesRequest) WithLockedTasks(withLockedTasks bool) ApiGetTopicNamesRequest {
	r.withLockedTasks = &withLockedTasks
	return r
}

// Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetTopicNamesRequest) WithUnlockedTasks(withUnlockedTasks bool) ApiGetTopicNamesRequest {
	r.withUnlockedTasks = &withUnlockedTasks
	return r
}

// Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
func (r ApiGetTopicNamesRequest) WithRetriesLeft(withRetriesLeft bool) ApiGetTopicNamesRequest {
	r.withRetriesLeft = &withRetriesLeft
	return r
}

func (r ApiGetTopicNamesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetTopicNamesExecute(r)
}

/*
GetTopicNames Get External Task Topic Names

Queries for distinct topic names of external tasks that fulfill given parameters.
Query can be restricted to only tasks with retries left, tasks that are locked, or tasks
that are unlocked. The parameters withLockedTasks and withUnlockedTasks are
exclusive. Setting them both to true will return an empty list.
Providing no parameters will return a list of all distinct topic names with external tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTopicNamesRequest
*/
func (a *ExternalTaskAPIService) GetTopicNames(ctx context.Context) ApiGetTopicNamesRequest {
	return ApiGetTopicNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *ExternalTaskAPIService) GetTopicNamesExecute(r ApiGetTopicNamesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.GetTopicNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/topic-names"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withLockedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withLockedTasks", r.withLockedTasks, "")
	}
	if r.withUnlockedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withUnlockedTasks", r.withUnlockedTasks, "")
	}
	if r.withRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRetriesLeft", r.withRetriesLeft, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHandleExternalTaskBpmnErrorRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	externalTaskBpmnError *ExternalTaskBpmnError
}

func (r ApiHandleExternalTaskBpmnErrorRequest) ExternalTaskBpmnError(externalTaskBpmnError ExternalTaskBpmnError) ApiHandleExternalTaskBpmnErrorRequest {
	r.externalTaskBpmnError = &externalTaskBpmnError
	return r
}

func (r ApiHandleExternalTaskBpmnErrorRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleExternalTaskBpmnErrorExecute(r)
}

/*
HandleExternalTaskBpmnError Handle BPMN Error

Reports a business error in the context of a running external task by id. The error code must be specified
to identify the BPMN error handler.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task in which context a BPMN error is reported.
 @return ApiHandleExternalTaskBpmnErrorRequest
*/
func (a *ExternalTaskAPIService) HandleExternalTaskBpmnError(ctx context.Context, id string) ApiHandleExternalTaskBpmnErrorRequest {
	return ApiHandleExternalTaskBpmnErrorRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) HandleExternalTaskBpmnErrorExecute(r ApiHandleExternalTaskBpmnErrorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.HandleExternalTaskBpmnError")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/bpmnError"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.externalTaskBpmnError
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiHandleFailureRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	externalTaskFailureDto *ExternalTaskFailureDto
}

func (r ApiHandleFailureRequest) ExternalTaskFailureDto(externalTaskFailureDto ExternalTaskFailureDto) ApiHandleFailureRequest {
	r.externalTaskFailureDto = &externalTaskFailureDto
	return r
}

func (r ApiHandleFailureRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleFailureExecute(r)
}

/*
HandleFailure Handle Failure

Reports a failure to execute an external task by id. A number of retries and a timeout until the task can
be retried can be specified. If retries are set to 0, an incident for this task is created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task to report a failure for.
 @return ApiHandleFailureRequest
*/
func (a *ExternalTaskAPIService) HandleFailure(ctx context.Context, id string) ApiHandleFailureRequest {
	return ApiHandleFailureRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) HandleFailureExecute(r ApiHandleFailureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.HandleFailure")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/failure"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.externalTaskFailureDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLockRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	lockExternalTaskDto *LockExternalTaskDto
}

func (r ApiLockRequest) LockExternalTaskDto(lockExternalTaskDto LockExternalTaskDto) ApiLockRequest {
	r.lockExternalTaskDto = &lockExternalTaskDto
	return r
}

func (r ApiLockRequest) Execute() (*http.Response, error) {
	return r.ApiService.LockExecute(r)
}

/*
Lock Method for Lock

Lock an external task by a given id for a specified worker and amount of time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task.
 @return ApiLockRequest
*/
func (a *ExternalTaskAPIService) Lock(ctx context.Context, id string) ApiLockRequest {
	return ApiLockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) LockExecute(r ApiLockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.Lock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lockExternalTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryExternalTasksRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	firstResult *int32
	maxResults *int32
	externalTaskQueryDto *ExternalTaskQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryExternalTasksRequest) FirstResult(firstResult int32) ApiQueryExternalTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryExternalTasksRequest) MaxResults(maxResults int32) ApiQueryExternalTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryExternalTasksRequest) ExternalTaskQueryDto(externalTaskQueryDto ExternalTaskQueryDto) ApiQueryExternalTasksRequest {
	r.externalTaskQueryDto = &externalTaskQueryDto
	return r
}

func (r ApiQueryExternalTasksRequest) Execute() ([]ExternalTaskDto, *http.Response, error) {
	return r.ApiService.QueryExternalTasksExecute(r)
}

/*
QueryExternalTasks Get List (POST)

Queries for external tasks that fulfill given parameters in the form of a JSON object.

This method is slightly more powerful than the
[Get External Tasks](https://docs.operaton.org/manual/1.0/reference/rest/external-task/get-query/) method because it allows to
specify a hierarchical result sorting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryExternalTasksRequest
*/
func (a *ExternalTaskAPIService) QueryExternalTasks(ctx context.Context) ApiQueryExternalTasksRequest {
	return ApiQueryExternalTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ExternalTaskDto
func (a *ExternalTaskAPIService) QueryExternalTasksExecute(r ApiQueryExternalTasksRequest) ([]ExternalTaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExternalTaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.QueryExternalTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.externalTaskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryExternalTasksCountRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	externalTaskQueryDto *ExternalTaskQueryDto
}

func (r ApiQueryExternalTasksCountRequest) ExternalTaskQueryDto(externalTaskQueryDto ExternalTaskQueryDto) ApiQueryExternalTasksCountRequest {
	r.externalTaskQueryDto = &externalTaskQueryDto
	return r
}

func (r ApiQueryExternalTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryExternalTasksCountExecute(r)
}

/*
QueryExternalTasksCount Get List Count (POST)

Queries for the number of external tasks that fulfill given parameters. This method takes the same message
body as the [Get External Tasks (POST)](https://docs.operaton.org/manual/1.0/reference/rest/external-task/post-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryExternalTasksCountRequest
*/
func (a *ExternalTaskAPIService) QueryExternalTasksCount(ctx context.Context) ApiQueryExternalTasksCountRequest {
	return ApiQueryExternalTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *ExternalTaskAPIService) QueryExternalTasksCountExecute(r ApiQueryExternalTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.QueryExternalTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.externalTaskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetExternalTaskResourcePriorityRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	priorityDto *PriorityDto
}

func (r ApiSetExternalTaskResourcePriorityRequest) PriorityDto(priorityDto PriorityDto) ApiSetExternalTaskResourcePriorityRequest {
	r.priorityDto = &priorityDto
	return r
}

func (r ApiSetExternalTaskResourcePriorityRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetExternalTaskResourcePriorityExecute(r)
}

/*
SetExternalTaskResourcePriority Set Priority

Sets the priority of an existing external task by id. The default value of a priority is 0.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task to set the priority for.
 @return ApiSetExternalTaskResourcePriorityRequest
*/
func (a *ExternalTaskAPIService) SetExternalTaskResourcePriority(ctx context.Context, id string) ApiSetExternalTaskResourcePriorityRequest {
	return ApiSetExternalTaskResourcePriorityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) SetExternalTaskResourcePriorityExecute(r ApiSetExternalTaskResourcePriorityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.SetExternalTaskResourcePriority")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/priority"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.priorityDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetExternalTaskResourceRetriesRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
	retriesDto *RetriesDto
}

func (r ApiSetExternalTaskResourceRetriesRequest) RetriesDto(retriesDto RetriesDto) ApiSetExternalTaskResourceRetriesRequest {
	r.retriesDto = &retriesDto
	return r
}

func (r ApiSetExternalTaskResourceRetriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetExternalTaskResourceRetriesExecute(r)
}

/*
SetExternalTaskResourceRetries Set Retries

Sets the number of retries left to execute an external task by id. If retries are set to 0, an 
incident is created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task to set the number of retries for.
 @return ApiSetExternalTaskResourceRetriesRequest
*/
func (a *ExternalTaskAPIService) SetExternalTaskResourceRetries(ctx context.Context, id string) ApiSetExternalTaskResourceRetriesRequest {
	return ApiSetExternalTaskResourceRetriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) SetExternalTaskResourceRetriesExecute(r ApiSetExternalTaskResourceRetriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.SetExternalTaskResourceRetries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/retries"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.retriesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetExternalTaskRetriesRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	setRetriesForExternalTasksDto *SetRetriesForExternalTasksDto
}

func (r ApiSetExternalTaskRetriesRequest) SetRetriesForExternalTasksDto(setRetriesForExternalTasksDto SetRetriesForExternalTasksDto) ApiSetExternalTaskRetriesRequest {
	r.setRetriesForExternalTasksDto = &setRetriesForExternalTasksDto
	return r
}

func (r ApiSetExternalTaskRetriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetExternalTaskRetriesExecute(r)
}

/*
SetExternalTaskRetries Set Retries Sync

Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0, 
an incident is created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetExternalTaskRetriesRequest
*/
func (a *ExternalTaskAPIService) SetExternalTaskRetries(ctx context.Context) ApiSetExternalTaskRetriesRequest {
	return ApiSetExternalTaskRetriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) SetExternalTaskRetriesExecute(r ApiSetExternalTaskRetriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.SetExternalTaskRetries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/retries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setRetriesForExternalTasksDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetExternalTaskRetriesAsyncOperationRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	setRetriesForExternalTasksDto *SetRetriesForExternalTasksDto
}

func (r ApiSetExternalTaskRetriesAsyncOperationRequest) SetRetriesForExternalTasksDto(setRetriesForExternalTasksDto SetRetriesForExternalTasksDto) ApiSetExternalTaskRetriesAsyncOperationRequest {
	r.setRetriesForExternalTasksDto = &setRetriesForExternalTasksDto
	return r
}

func (r ApiSetExternalTaskRetriesAsyncOperationRequest) Execute() (*BatchDto, *http.Response, error) {
	return r.ApiService.SetExternalTaskRetriesAsyncOperationExecute(r)
}

/*
SetExternalTaskRetriesAsyncOperation Set Retries Async

Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0,
an incident is created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetExternalTaskRetriesAsyncOperationRequest
*/
func (a *ExternalTaskAPIService) SetExternalTaskRetriesAsyncOperation(ctx context.Context) ApiSetExternalTaskRetriesAsyncOperationRequest {
	return ApiSetExternalTaskRetriesAsyncOperationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchDto
func (a *ExternalTaskAPIService) SetExternalTaskRetriesAsyncOperationExecute(r ApiSetExternalTaskRetriesAsyncOperationRequest) (*BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.SetExternalTaskRetriesAsyncOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/retries-async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setRetriesForExternalTasksDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlockRequest struct {
	ctx context.Context
	ApiService *ExternalTaskAPIService
	id string
}

func (r ApiUnlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnlockExecute(r)
}

/*
Unlock Unlock

Unlocks an external task by id. Clears the task's lock expiration time and worker id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the external task to unlock.
 @return ApiUnlockRequest
*/
func (a *ExternalTaskAPIService) Unlock(ctx context.Context, id string) ApiUnlockRequest {
	return ApiUnlockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTaskAPIService) UnlockExecute(r ApiUnlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTaskAPIService.Unlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external-task/{id}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
