/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// HistoricActivityInstanceAPIService HistoricActivityInstanceAPI service
type HistoricActivityInstanceAPIService service

type ApiGetHistoricActivityInstanceRequest struct {
	ctx        context.Context
	ApiService *HistoricActivityInstanceAPIService
	id         string
}

func (r ApiGetHistoricActivityInstanceRequest) Execute() (*HistoricActivityInstanceDto, *http.Response, error) {
	return r.ApiService.GetHistoricActivityInstanceExecute(r)
}

/*
GetHistoricActivityInstance Get

Retrieves a historic activity instance by id, according to the `HistoricActivityInstance` interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the historic activity instance to be retrieved.
	@return ApiGetHistoricActivityInstanceRequest
*/
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstance(ctx context.Context, id string) ApiGetHistoricActivityInstanceRequest {
	return ApiGetHistoricActivityInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return HistoricActivityInstanceDto
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstanceExecute(r ApiGetHistoricActivityInstanceRequest) (*HistoricActivityInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HistoricActivityInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricActivityInstanceAPIService.GetHistoricActivityInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/activity-instance/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricActivityInstancesRequest struct {
	ctx                 context.Context
	ApiService          *HistoricActivityInstanceAPIService
	sortBy              *string
	sortOrder           *string
	firstResult         *int32
	maxResults          *int32
	activityInstanceId  *string
	processInstanceId   *string
	processDefinitionId *string
	executionId         *string
	activityId          *string
	activityName        *string
	activityType        *string
	taskAssignee        *string
	finished            *bool
	unfinished          *bool
	canceled            *bool
	completeScope       *bool
	startedBefore       *time.Time
	startedAfter        *time.Time
	finishedBefore      *time.Time
	finishedAfter       *time.Time
	tenantIdIn          *string
	withoutTenantId     *bool
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetHistoricActivityInstancesRequest) SortBy(sortBy string) ApiGetHistoricActivityInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetHistoricActivityInstancesRequest) SortOrder(sortOrder string) ApiGetHistoricActivityInstancesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetHistoricActivityInstancesRequest) FirstResult(firstResult int32) ApiGetHistoricActivityInstancesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetHistoricActivityInstancesRequest) MaxResults(maxResults int32) ApiGetHistoricActivityInstancesRequest {
	r.maxResults = &maxResults
	return r
}

// Filter by activity instance id.
func (r ApiGetHistoricActivityInstancesRequest) ActivityInstanceId(activityInstanceId string) ApiGetHistoricActivityInstancesRequest {
	r.activityInstanceId = &activityInstanceId
	return r
}

// Filter by process instance id.
func (r ApiGetHistoricActivityInstancesRequest) ProcessInstanceId(processInstanceId string) ApiGetHistoricActivityInstancesRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by process definition id.
func (r ApiGetHistoricActivityInstancesRequest) ProcessDefinitionId(processDefinitionId string) ApiGetHistoricActivityInstancesRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the id of the execution that executed the activity instance.
func (r ApiGetHistoricActivityInstancesRequest) ExecutionId(executionId string) ApiGetHistoricActivityInstancesRequest {
	r.executionId = &executionId
	return r
}

// Filter by the activity id (according to BPMN 2.0 XML).
func (r ApiGetHistoricActivityInstancesRequest) ActivityId(activityId string) ApiGetHistoricActivityInstancesRequest {
	r.activityId = &activityId
	return r
}

// Filter by the activity name (according to BPMN 2.0 XML).
func (r ApiGetHistoricActivityInstancesRequest) ActivityName(activityName string) ApiGetHistoricActivityInstancesRequest {
	r.activityName = &activityName
	return r
}

// Filter by activity type.
func (r ApiGetHistoricActivityInstancesRequest) ActivityType(activityType string) ApiGetHistoricActivityInstancesRequest {
	r.activityType = &activityType
	return r
}

// Only include activity instances that are user tasks and assigned to a given user.
func (r ApiGetHistoricActivityInstancesRequest) TaskAssignee(taskAssignee string) ApiGetHistoricActivityInstancesRequest {
	r.taskAssignee = &taskAssignee
	return r
}

// Only include finished activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesRequest) Finished(finished bool) ApiGetHistoricActivityInstancesRequest {
	r.finished = &finished
	return r
}

// Only include unfinished activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesRequest) Unfinished(unfinished bool) ApiGetHistoricActivityInstancesRequest {
	r.unfinished = &unfinished
	return r
}

// Only include canceled activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesRequest) Canceled(canceled bool) ApiGetHistoricActivityInstancesRequest {
	r.canceled = &canceled
	return r
}

// Only include activity instances which completed a scope. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesRequest) CompleteScope(completeScope bool) ApiGetHistoricActivityInstancesRequest {
	r.completeScope = &completeScope
	return r
}

// Restrict to instances that were started before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesRequest) StartedBefore(startedBefore time.Time) ApiGetHistoricActivityInstancesRequest {
	r.startedBefore = &startedBefore
	return r
}

// Restrict to instances that were started after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesRequest) StartedAfter(startedAfter time.Time) ApiGetHistoricActivityInstancesRequest {
	r.startedAfter = &startedAfter
	return r
}

// Restrict to instances that were finished before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesRequest) FinishedBefore(finishedBefore time.Time) ApiGetHistoricActivityInstancesRequest {
	r.finishedBefore = &finishedBefore
	return r
}

// Restrict to instances that were finished after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesRequest) FinishedAfter(finishedAfter time.Time) ApiGetHistoricActivityInstancesRequest {
	r.finishedAfter = &finishedAfter
	return r
}

// Filter by a comma-separated list of ids. An activity instance must have one of the given tenant ids.
func (r ApiGetHistoricActivityInstancesRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricActivityInstancesRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include historic activity instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricActivityInstancesRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricActivityInstancesRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

func (r ApiGetHistoricActivityInstancesRequest) Execute() ([]HistoricActivityInstanceDto, *http.Response, error) {
	return r.ApiService.GetHistoricActivityInstancesExecute(r)
}

/*
GetHistoricActivityInstances Get List

Queries for historic activity instances that fulfill the given parameters.
The size of the result set can be retrieved by using the
[Get Historic Activity Instance Count](https://docs.operaton.org/manual/1.0/reference/rest/history/activity-instance/get-activity-instance-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetHistoricActivityInstancesRequest
*/
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstances(ctx context.Context) ApiGetHistoricActivityInstancesRequest {
	return ApiGetHistoricActivityInstancesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []HistoricActivityInstanceDto
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstancesExecute(r ApiGetHistoricActivityInstancesRequest) ([]HistoricActivityInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []HistoricActivityInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricActivityInstanceAPIService.GetHistoricActivityInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/activity-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.activityInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceId", r.activityInstanceId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.activityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityName", r.activityName, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.taskAssignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskAssignee", r.taskAssignee, "")
	}
	if r.finished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished", r.finished, "")
	}
	if r.unfinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unfinished", r.unfinished, "")
	}
	if r.canceled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canceled", r.canceled, "")
	}
	if r.completeScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completeScope", r.completeScope, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.finishedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedBefore", r.finishedBefore, "")
	}
	if r.finishedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedAfter", r.finishedAfter, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricActivityInstancesCountRequest struct {
	ctx                 context.Context
	ApiService          *HistoricActivityInstanceAPIService
	activityInstanceId  *string
	processInstanceId   *string
	processDefinitionId *string
	executionId         *string
	activityId          *string
	activityName        *string
	activityType        *string
	taskAssignee        *string
	finished            *bool
	unfinished          *bool
	canceled            *bool
	completeScope       *bool
	startedBefore       *time.Time
	startedAfter        *time.Time
	finishedBefore      *time.Time
	finishedAfter       *time.Time
	tenantIdIn          *string
	withoutTenantId     *bool
}

// Filter by activity instance id.
func (r ApiGetHistoricActivityInstancesCountRequest) ActivityInstanceId(activityInstanceId string) ApiGetHistoricActivityInstancesCountRequest {
	r.activityInstanceId = &activityInstanceId
	return r
}

// Filter by process instance id.
func (r ApiGetHistoricActivityInstancesCountRequest) ProcessInstanceId(processInstanceId string) ApiGetHistoricActivityInstancesCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Filter by process definition id.
func (r ApiGetHistoricActivityInstancesCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetHistoricActivityInstancesCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the id of the execution that executed the activity instance.
func (r ApiGetHistoricActivityInstancesCountRequest) ExecutionId(executionId string) ApiGetHistoricActivityInstancesCountRequest {
	r.executionId = &executionId
	return r
}

// Filter by the activity id (according to BPMN 2.0 XML).
func (r ApiGetHistoricActivityInstancesCountRequest) ActivityId(activityId string) ApiGetHistoricActivityInstancesCountRequest {
	r.activityId = &activityId
	return r
}

// Filter by the activity name (according to BPMN 2.0 XML).
func (r ApiGetHistoricActivityInstancesCountRequest) ActivityName(activityName string) ApiGetHistoricActivityInstancesCountRequest {
	r.activityName = &activityName
	return r
}

// Filter by activity type.
func (r ApiGetHistoricActivityInstancesCountRequest) ActivityType(activityType string) ApiGetHistoricActivityInstancesCountRequest {
	r.activityType = &activityType
	return r
}

// Only include activity instances that are user tasks and assigned to a given user.
func (r ApiGetHistoricActivityInstancesCountRequest) TaskAssignee(taskAssignee string) ApiGetHistoricActivityInstancesCountRequest {
	r.taskAssignee = &taskAssignee
	return r
}

// Only include finished activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesCountRequest) Finished(finished bool) ApiGetHistoricActivityInstancesCountRequest {
	r.finished = &finished
	return r
}

// Only include unfinished activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesCountRequest) Unfinished(unfinished bool) ApiGetHistoricActivityInstancesCountRequest {
	r.unfinished = &unfinished
	return r
}

// Only include canceled activity instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesCountRequest) Canceled(canceled bool) ApiGetHistoricActivityInstancesCountRequest {
	r.canceled = &canceled
	return r
}

// Only include activity instances which completed a scope. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; behaves the same as when the property is not set.
func (r ApiGetHistoricActivityInstancesCountRequest) CompleteScope(completeScope bool) ApiGetHistoricActivityInstancesCountRequest {
	r.completeScope = &completeScope
	return r
}

// Restrict to instances that were started before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesCountRequest) StartedBefore(startedBefore time.Time) ApiGetHistoricActivityInstancesCountRequest {
	r.startedBefore = &startedBefore
	return r
}

// Restrict to instances that were started after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesCountRequest) StartedAfter(startedAfter time.Time) ApiGetHistoricActivityInstancesCountRequest {
	r.startedAfter = &startedAfter
	return r
}

// Restrict to instances that were finished before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesCountRequest) FinishedBefore(finishedBefore time.Time) ApiGetHistoricActivityInstancesCountRequest {
	r.finishedBefore = &finishedBefore
	return r
}

// Restrict to instances that were finished after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityInstancesCountRequest) FinishedAfter(finishedAfter time.Time) ApiGetHistoricActivityInstancesCountRequest {
	r.finishedAfter = &finishedAfter
	return r
}

// Filter by a comma-separated list of ids. An activity instance must have one of the given tenant ids.
func (r ApiGetHistoricActivityInstancesCountRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricActivityInstancesCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include historic activity instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricActivityInstancesCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricActivityInstancesCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

func (r ApiGetHistoricActivityInstancesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetHistoricActivityInstancesCountExecute(r)
}

/*
GetHistoricActivityInstancesCount Get List Count

Queries for the number of historic activity instances that fulfill the given parameters.
Takes the same parameters as the [Get Historic Activity Instance](https://docs.operaton.org/manual/1.0/reference/rest/history/activity-instance/get-activity-instance-query/)  method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetHistoricActivityInstancesCountRequest
*/
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstancesCount(ctx context.Context) ApiGetHistoricActivityInstancesCountRequest {
	return ApiGetHistoricActivityInstancesCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *HistoricActivityInstanceAPIService) GetHistoricActivityInstancesCountExecute(r ApiGetHistoricActivityInstancesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricActivityInstanceAPIService.GetHistoricActivityInstancesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/activity-instance/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activityInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceId", r.activityInstanceId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.activityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityName", r.activityName, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.taskAssignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskAssignee", r.taskAssignee, "")
	}
	if r.finished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished", r.finished, "")
	}
	if r.unfinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unfinished", r.unfinished, "")
	}
	if r.canceled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canceled", r.canceled, "")
	}
	if r.completeScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completeScope", r.completeScope, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.finishedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedBefore", r.finishedBefore, "")
	}
	if r.finishedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedAfter", r.finishedAfter, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryHistoricActivityInstancesRequest struct {
	ctx                              context.Context
	ApiService                       *HistoricActivityInstanceAPIService
	firstResult                      *int32
	maxResults                       *int32
	historicActivityInstanceQueryDto *HistoricActivityInstanceQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryHistoricActivityInstancesRequest) FirstResult(firstResult int32) ApiQueryHistoricActivityInstancesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryHistoricActivityInstancesRequest) MaxResults(maxResults int32) ApiQueryHistoricActivityInstancesRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryHistoricActivityInstancesRequest) HistoricActivityInstanceQueryDto(historicActivityInstanceQueryDto HistoricActivityInstanceQueryDto) ApiQueryHistoricActivityInstancesRequest {
	r.historicActivityInstanceQueryDto = &historicActivityInstanceQueryDto
	return r
}

func (r ApiQueryHistoricActivityInstancesRequest) Execute() ([]HistoricActivityInstanceDto, *http.Response, error) {
	return r.ApiService.QueryHistoricActivityInstancesExecute(r)
}

/*
QueryHistoricActivityInstances Get List (POST)

Queries for historic activity instances that fulfill the given parameters.
The size of the result set can be retrieved by using the
[Get Historic Activity Instance Count](https://docs.operaton.org/manual/1.0/reference/rest/history/activity-instance/get-activity-instance-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryHistoricActivityInstancesRequest
*/
func (a *HistoricActivityInstanceAPIService) QueryHistoricActivityInstances(ctx context.Context) ApiQueryHistoricActivityInstancesRequest {
	return ApiQueryHistoricActivityInstancesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []HistoricActivityInstanceDto
func (a *HistoricActivityInstanceAPIService) QueryHistoricActivityInstancesExecute(r ApiQueryHistoricActivityInstancesRequest) ([]HistoricActivityInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []HistoricActivityInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricActivityInstanceAPIService.QueryHistoricActivityInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/activity-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historicActivityInstanceQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryHistoricActivityInstancesCountRequest struct {
	ctx                              context.Context
	ApiService                       *HistoricActivityInstanceAPIService
	historicActivityInstanceQueryDto *HistoricActivityInstanceQueryDto
}

func (r ApiQueryHistoricActivityInstancesCountRequest) HistoricActivityInstanceQueryDto(historicActivityInstanceQueryDto HistoricActivityInstanceQueryDto) ApiQueryHistoricActivityInstancesCountRequest {
	r.historicActivityInstanceQueryDto = &historicActivityInstanceQueryDto
	return r
}

func (r ApiQueryHistoricActivityInstancesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryHistoricActivityInstancesCountExecute(r)
}

/*
QueryHistoricActivityInstancesCount Get List Count (POST)

Queries for the number of historic activity instances that fulfill the given parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryHistoricActivityInstancesCountRequest
*/
func (a *HistoricActivityInstanceAPIService) QueryHistoricActivityInstancesCount(ctx context.Context) ApiQueryHistoricActivityInstancesCountRequest {
	return ApiQueryHistoricActivityInstancesCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *HistoricActivityInstanceAPIService) QueryHistoricActivityInstancesCountExecute(r ApiQueryHistoricActivityInstancesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricActivityInstanceAPIService.QueryHistoricActivityInstancesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/activity-instance/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historicActivityInstanceQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
