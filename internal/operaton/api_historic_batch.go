/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// HistoricBatchAPIService HistoricBatchAPI service
type HistoricBatchAPIService service

type ApiDeleteHistoricBatchRequest struct {
	ctx        context.Context
	ApiService *HistoricBatchAPIService
	id         string
}

func (r ApiDeleteHistoricBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHistoricBatchExecute(r)
}

/*
DeleteHistoricBatch Delete Historic Batch

Deletes a historic batch by id, including related historic job logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the batch to be deleted.
	@return ApiDeleteHistoricBatchRequest
*/
func (a *HistoricBatchAPIService) DeleteHistoricBatch(ctx context.Context, id string) ApiDeleteHistoricBatchRequest {
	return ApiDeleteHistoricBatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *HistoricBatchAPIService) DeleteHistoricBatchExecute(r ApiDeleteHistoricBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.DeleteHistoricBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCleanableHistoricBatchesReportRequest struct {
	ctx         context.Context
	ApiService  *HistoricBatchAPIService
	sortBy      *string
	sortOrder   *string
	firstResult *int32
	maxResults  *int32
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetCleanableHistoricBatchesReportRequest) SortBy(sortBy string) ApiGetCleanableHistoricBatchesReportRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetCleanableHistoricBatchesReportRequest) SortOrder(sortOrder string) ApiGetCleanableHistoricBatchesReportRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetCleanableHistoricBatchesReportRequest) FirstResult(firstResult int32) ApiGetCleanableHistoricBatchesReportRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetCleanableHistoricBatchesReportRequest) MaxResults(maxResults int32) ApiGetCleanableHistoricBatchesReportRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetCleanableHistoricBatchesReportRequest) Execute() ([]CleanableHistoricBatchReportResultDto, *http.Response, error) {
	return r.ApiService.GetCleanableHistoricBatchesReportExecute(r)
}

/*
GetCleanableHistoricBatchesReport Get Cleanable Batch Report

Retrieves a report about a historic batch operations relevant to history cleanup
(see
[History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup)
) so that you can tune the history time to live.
These reports include the count of the finished batches, cleanable
batches and type of the batch.
The size of the result set can be retrieved by using the
[Get Cleanable Batch Report Count](https://docs.operaton.org/manual/1.0/reference/rest/history/batch/get-cleanable-batch-report-count/)
method.

**Please note:**
The history time to live for batch operations does not support [Multi-Tenancy](https://docs.operaton.org/manual/1.0/user-guide/process-engine/multi-tenancy.md).
The report will return an information for all batch operations (for all tenants) if you have permissions
to see the history.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCleanableHistoricBatchesReportRequest
*/
func (a *HistoricBatchAPIService) GetCleanableHistoricBatchesReport(ctx context.Context) ApiGetCleanableHistoricBatchesReportRequest {
	return ApiGetCleanableHistoricBatchesReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []CleanableHistoricBatchReportResultDto
func (a *HistoricBatchAPIService) GetCleanableHistoricBatchesReportExecute(r ApiGetCleanableHistoricBatchesReportRequest) ([]CleanableHistoricBatchReportResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CleanableHistoricBatchReportResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.GetCleanableHistoricBatchesReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/cleanable-batch-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCleanableHistoricBatchesReportCountRequest struct {
	ctx        context.Context
	ApiService *HistoricBatchAPIService
}

func (r ApiGetCleanableHistoricBatchesReportCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetCleanableHistoricBatchesReportCountExecute(r)
}

/*
GetCleanableHistoricBatchesReportCount Get Cleanable Batch Report Count

Queries for the number of report results about a historic batch operations relevant
to history cleanup (see
[History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup)
).
Takes the same parameters as the
[Get Cleanable Batch Report](https://docs.operaton.org/manual/1.0/reference/rest/history/batch/get-cleanable-batch-report/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCleanableHistoricBatchesReportCountRequest
*/
func (a *HistoricBatchAPIService) GetCleanableHistoricBatchesReportCount(ctx context.Context) ApiGetCleanableHistoricBatchesReportCountRequest {
	return ApiGetCleanableHistoricBatchesReportCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *HistoricBatchAPIService) GetCleanableHistoricBatchesReportCountExecute(r ApiGetCleanableHistoricBatchesReportCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.GetCleanableHistoricBatchesReportCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/cleanable-batch-report/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricBatchRequest struct {
	ctx        context.Context
	ApiService *HistoricBatchAPIService
	id         string
}

func (r ApiGetHistoricBatchRequest) Execute() (*HistoricBatchDto, *http.Response, error) {
	return r.ApiService.GetHistoricBatchExecute(r)
}

/*
GetHistoricBatch Get Historic Batch

Retrieves a historic batch by id, according to the `HistoricBatch` interface in the
engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the historic batch to be retrieved.
	@return ApiGetHistoricBatchRequest
*/
func (a *HistoricBatchAPIService) GetHistoricBatch(ctx context.Context, id string) ApiGetHistoricBatchRequest {
	return ApiGetHistoricBatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return HistoricBatchDto
func (a *HistoricBatchAPIService) GetHistoricBatchExecute(r ApiGetHistoricBatchRequest) (*HistoricBatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HistoricBatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.GetHistoricBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricBatchesRequest struct {
	ctx             context.Context
	ApiService      *HistoricBatchAPIService
	batchId         *string
	type_           *string
	completed       *bool
	tenantIdIn      *string
	withoutTenantId *bool
	sortBy          *string
	sortOrder       *string
	firstResult     *int32
	maxResults      *int32
}

// Filter by batch id.
func (r ApiGetHistoricBatchesRequest) BatchId(batchId string) ApiGetHistoricBatchesRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetHistoricBatchesRequest) Type_(type_ string) ApiGetHistoricBatchesRequest {
	r.type_ = &type_
	return r
}

// Filter completed or not completed batches. If the value is &#x60;true&#x60;, only completed batches, i.e., end time is set, are returned. Otherwise, if the value is &#x60;false&#x60;, only running batches, i.e., end time is null, are returned.
func (r ApiGetHistoricBatchesRequest) Completed(completed bool) ApiGetHistoricBatchesRequest {
	r.completed = &completed
	return r
}

// Filter by a comma-separated list of tenant ids. A batch matches if it has one of the given tenant ids.
func (r ApiGetHistoricBatchesRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricBatchesRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricBatchesRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricBatchesRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetHistoricBatchesRequest) SortBy(sortBy string) ApiGetHistoricBatchesRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetHistoricBatchesRequest) SortOrder(sortOrder string) ApiGetHistoricBatchesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetHistoricBatchesRequest) FirstResult(firstResult int32) ApiGetHistoricBatchesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetHistoricBatchesRequest) MaxResults(maxResults int32) ApiGetHistoricBatchesRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetHistoricBatchesRequest) Execute() ([]HistoricBatchDto, *http.Response, error) {
	return r.ApiService.GetHistoricBatchesExecute(r)
}

/*
GetHistoricBatches Get Historic Batches

Queries for historic batches that fulfill given parameters. Parameters may be
the properties of batches, such as the id or type. The
size of the result set can be retrieved by using the
[Get Historic Batch Count](https://docs.operaton.org/manual/1.0/reference/rest/history/batch/get-query-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetHistoricBatchesRequest
*/
func (a *HistoricBatchAPIService) GetHistoricBatches(ctx context.Context) ApiGetHistoricBatchesRequest {
	return ApiGetHistoricBatchesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []HistoricBatchDto
func (a *HistoricBatchAPIService) GetHistoricBatchesExecute(r ApiGetHistoricBatchesRequest) ([]HistoricBatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []HistoricBatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.GetHistoricBatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricBatchesCountRequest struct {
	ctx             context.Context
	ApiService      *HistoricBatchAPIService
	batchId         *string
	type_           *string
	completed       *bool
	tenantIdIn      *string
	withoutTenantId *bool
}

// Filter by batch id.
func (r ApiGetHistoricBatchesCountRequest) BatchId(batchId string) ApiGetHistoricBatchesCountRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetHistoricBatchesCountRequest) Type_(type_ string) ApiGetHistoricBatchesCountRequest {
	r.type_ = &type_
	return r
}

// Filter completed or not completed batches. If the value is &#x60;true&#x60;, only completed batches, i.e., end time is set, are returned. Otherwise, if the value is &#x60;false&#x60;, only running batches, i.e., end time is null, are returned.
func (r ApiGetHistoricBatchesCountRequest) Completed(completed bool) ApiGetHistoricBatchesCountRequest {
	r.completed = &completed
	return r
}

// Filter by a comma-separated list of tenant ids. A batch matches if it has one of the given tenant ids.
func (r ApiGetHistoricBatchesCountRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricBatchesCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricBatchesCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricBatchesCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

func (r ApiGetHistoricBatchesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetHistoricBatchesCountExecute(r)
}

/*
GetHistoricBatchesCount Get Historic Batch Count

Requests the number of historic batches that fulfill the query criteria.
Takes the same filtering parameters as the
[Get Historic Batches](https://docs.operaton.org/manual/1.0/reference/rest/history/batch/get-query/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetHistoricBatchesCountRequest
*/
func (a *HistoricBatchAPIService) GetHistoricBatchesCount(ctx context.Context) ApiGetHistoricBatchesCountRequest {
	return ApiGetHistoricBatchesCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *HistoricBatchAPIService) GetHistoricBatchesCountExecute(r ApiGetHistoricBatchesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.GetHistoricBatchesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetRemovalTimeAsyncHistoricBatchRequest struct {
	ctx                                context.Context
	ApiService                         *HistoricBatchAPIService
	setRemovalTimeToHistoricBatchesDto *SetRemovalTimeToHistoricBatchesDto
}

func (r ApiSetRemovalTimeAsyncHistoricBatchRequest) SetRemovalTimeToHistoricBatchesDto(setRemovalTimeToHistoricBatchesDto SetRemovalTimeToHistoricBatchesDto) ApiSetRemovalTimeAsyncHistoricBatchRequest {
	r.setRemovalTimeToHistoricBatchesDto = &setRemovalTimeToHistoricBatchesDto
	return r
}

func (r ApiSetRemovalTimeAsyncHistoricBatchRequest) Execute() (*BatchDto, *http.Response, error) {
	return r.ApiService.SetRemovalTimeAsyncHistoricBatchExecute(r)
}

/*
SetRemovalTimeAsyncHistoricBatch Set Removal Time Async (POST)

Sets the removal time to multiple historic batches asynchronously (batch).

At least __historicBatchIds__ or __historicBatchQuery__ has to be
provided. If both are provided,
all instances matching query criterion and instances from the list
will be updated with a removal time.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetRemovalTimeAsyncHistoricBatchRequest
*/
func (a *HistoricBatchAPIService) SetRemovalTimeAsyncHistoricBatch(ctx context.Context) ApiSetRemovalTimeAsyncHistoricBatchRequest {
	return ApiSetRemovalTimeAsyncHistoricBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BatchDto
func (a *HistoricBatchAPIService) SetRemovalTimeAsyncHistoricBatchExecute(r ApiSetRemovalTimeAsyncHistoricBatchRequest) (*BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricBatchAPIService.SetRemovalTimeAsyncHistoricBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/batch/set-removal-time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setRemovalTimeToHistoricBatchesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
