/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// HistoricVariableInstanceAPIService HistoricVariableInstanceAPI service
type HistoricVariableInstanceAPIService service

type ApiDeleteHistoricVariableInstanceRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	id string
}

func (r ApiDeleteHistoricVariableInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHistoricVariableInstanceExecute(r)
}

/*
DeleteHistoricVariableInstance Delete Variable Instance

Deletes a historic variable instance by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the variable instance.
 @return ApiDeleteHistoricVariableInstanceRequest
*/
func (a *HistoricVariableInstanceAPIService) DeleteHistoricVariableInstance(ctx context.Context, id string) ApiDeleteHistoricVariableInstanceRequest {
	return ApiDeleteHistoricVariableInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *HistoricVariableInstanceAPIService) DeleteHistoricVariableInstanceExecute(r ApiDeleteHistoricVariableInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.DeleteHistoricVariableInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetHistoricVariableInstanceRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	id string
	deserializeValues *bool
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetHistoricVariableInstanceRequest) DeserializeValues(deserializeValues bool) ApiGetHistoricVariableInstanceRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetHistoricVariableInstanceRequest) Execute() (*HistoricVariableInstanceDto, *http.Response, error) {
	return r.ApiService.GetHistoricVariableInstanceExecute(r)
}

/*
GetHistoricVariableInstance Get Variable Instance

Retrieves a historic variable by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the variable instance.
 @return ApiGetHistoricVariableInstanceRequest
*/
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstance(ctx context.Context, id string) ApiGetHistoricVariableInstanceRequest {
	return ApiGetHistoricVariableInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return HistoricVariableInstanceDto
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstanceExecute(r ApiGetHistoricVariableInstanceRequest) (*HistoricVariableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoricVariableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.GetHistoricVariableInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricVariableInstanceBinaryRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	id string
}

func (r ApiGetHistoricVariableInstanceBinaryRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetHistoricVariableInstanceBinaryExecute(r)
}

/*
GetHistoricVariableInstanceBinary Get Variable Instance (Binary)

Retrieves the content of a historic variable by id. Applicable for variables that
are serialized as binary data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the variable instance.
 @return ApiGetHistoricVariableInstanceBinaryRequest
*/
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstanceBinary(ctx context.Context, id string) ApiGetHistoricVariableInstanceBinaryRequest {
	return ApiGetHistoricVariableInstanceBinaryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstanceBinaryExecute(r ApiGetHistoricVariableInstanceBinaryRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.GetHistoricVariableInstanceBinary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance/{id}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricVariableInstancesRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	variableName *string
	variableNameLike *string
	variableValue *map[string]interface{}
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	variableTypeIn *string
	includeDeleted *bool
	processInstanceId *string
	processInstanceIdIn *string
	processDefinitionId *string
	processDefinitionKey *string
	executionIdIn *string
	caseInstanceId *string
	caseExecutionIdIn *string
	caseActivityIdIn *string
	taskIdIn *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	variableNameIn *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
	deserializeValues *bool
}

// Filter by variable name.
func (r ApiGetHistoricVariableInstancesRequest) VariableName(variableName string) ApiGetHistoricVariableInstancesRequest {
	r.variableName = &variableName
	return r
}

// Restrict to variables with a name like the parameter.
func (r ApiGetHistoricVariableInstancesRequest) VariableNameLike(variableNameLike string) ApiGetHistoricVariableInstancesRequest {
	r.variableNameLike = &variableNameLike
	return r
}

// Filter by variable value. Is treated as a &#x60;String&#x60; object on server side.
func (r ApiGetHistoricVariableInstancesRequest) VariableValue(variableValue map[string]interface{}) ApiGetHistoricVariableInstancesRequest {
	r.variableValue = &variableValue
	return r
}

// Match the variable name provided in &#x60;variableName&#x60; and &#x60;variableNameLike&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
func (r ApiGetHistoricVariableInstancesRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetHistoricVariableInstancesRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match the variable value provided in &#x60;variableValue&#x60; case-insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
func (r ApiGetHistoricVariableInstancesRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetHistoricVariableInstancesRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Only include historic variable instances which belong to one of the passed and comma- separated variable types. A list of all supported variable types can be found [here](https://docs.operaton.org/manual/1.0/user-guide/process-engine/variables/#supported-variable-values). **Note:** All non-primitive variables are associated with the type &#39;serializable&#39;.
func (r ApiGetHistoricVariableInstancesRequest) VariableTypeIn(variableTypeIn string) ApiGetHistoricVariableInstancesRequest {
	r.variableTypeIn = &variableTypeIn
	return r
}

// Include variables that has already been deleted during the execution.
func (r ApiGetHistoricVariableInstancesRequest) IncludeDeleted(includeDeleted bool) ApiGetHistoricVariableInstancesRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// Filter by the process instance the variable belongs to.
func (r ApiGetHistoricVariableInstancesRequest) ProcessInstanceId(processInstanceId string) ApiGetHistoricVariableInstancesRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Only include historic variable instances which belong to one of the passed and comma-separated process instance ids.
func (r ApiGetHistoricVariableInstancesRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Filter by the process definition the variable belongs to.
func (r ApiGetHistoricVariableInstancesRequest) ProcessDefinitionId(processDefinitionId string) ApiGetHistoricVariableInstancesRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a key of the process definition the variable belongs to.
func (r ApiGetHistoricVariableInstancesRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetHistoricVariableInstancesRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated execution ids.
func (r ApiGetHistoricVariableInstancesRequest) ExecutionIdIn(executionIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.executionIdIn = &executionIdIn
	return r
}

// Filter by the case instance the variable belongs to.
func (r ApiGetHistoricVariableInstancesRequest) CaseInstanceId(caseInstanceId string) ApiGetHistoricVariableInstancesRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated case execution ids.
func (r ApiGetHistoricVariableInstancesRequest) CaseExecutionIdIn(caseExecutionIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.caseExecutionIdIn = &caseExecutionIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated case activity ids.
func (r ApiGetHistoricVariableInstancesRequest) CaseActivityIdIn(caseActivityIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.caseActivityIdIn = &caseActivityIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated task ids.
func (r ApiGetHistoricVariableInstancesRequest) TaskIdIn(taskIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated activity instance ids.
func (r ApiGetHistoricVariableInstancesRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and comma- separated tenant ids.
func (r ApiGetHistoricVariableInstancesRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricVariableInstancesRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include historic variable instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricVariableInstancesRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricVariableInstancesRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Only include historic variable instances which belong to one of the passed and comma-separated variable names.
func (r ApiGetHistoricVariableInstancesRequest) VariableNameIn(variableNameIn string) ApiGetHistoricVariableInstancesRequest {
	r.variableNameIn = &variableNameIn
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetHistoricVariableInstancesRequest) SortBy(sortBy string) ApiGetHistoricVariableInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetHistoricVariableInstancesRequest) SortOrder(sortOrder string) ApiGetHistoricVariableInstancesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetHistoricVariableInstancesRequest) FirstResult(firstResult int32) ApiGetHistoricVariableInstancesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetHistoricVariableInstancesRequest) MaxResults(maxResults int32) ApiGetHistoricVariableInstancesRequest {
	r.maxResults = &maxResults
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetHistoricVariableInstancesRequest) DeserializeValues(deserializeValues bool) ApiGetHistoricVariableInstancesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetHistoricVariableInstancesRequest) Execute() ([]HistoricVariableInstanceDto, *http.Response, error) {
	return r.ApiService.GetHistoricVariableInstancesExecute(r)
}

/*
GetHistoricVariableInstances Get Variable Instances

Queries for historic variable instances that fulfill the given parameters.
The size of the result set can be retrieved by using the
[Get Variable Instance Count](https://docs.operaton.org/manual/1.0/reference/rest/history/variable-instance/get-variable-instance-query-count/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoricVariableInstancesRequest
*/
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstances(ctx context.Context) ApiGetHistoricVariableInstancesRequest {
	return ApiGetHistoricVariableInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HistoricVariableInstanceDto
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstancesExecute(r ApiGetHistoricVariableInstancesRequest) ([]HistoricVariableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HistoricVariableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.GetHistoricVariableInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableName", r.variableName, "")
	}
	if r.variableNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNameLike", r.variableNameLike, "")
	}
	if r.variableValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValue", r.variableValue, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	}
	if r.variableTypeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableTypeIn", r.variableTypeIn, "")
	}
	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeleted", r.includeDeleted, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.executionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionIdIn", r.executionIdIn, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseExecutionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionIdIn", r.caseExecutionIdIn, "")
	}
	if r.caseActivityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseActivityIdIn", r.caseActivityIdIn, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.variableNameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNameIn", r.variableNameIn, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricVariableInstancesCountRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	variableName *string
	variableNameLike *string
	variableValue *map[string]interface{}
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	variableTypeIn *string
	includeDeleted *bool
	processInstanceId *string
	processInstanceIdIn *string
	processDefinitionId *string
	processDefinitionKey *string
	executionIdIn *string
	caseInstanceId *string
	caseExecutionIdIn *string
	caseActivityIdIn *string
	taskIdIn *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	variableNameIn *string
}

// Filter by variable name.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableName(variableName string) ApiGetHistoricVariableInstancesCountRequest {
	r.variableName = &variableName
	return r
}

// Restrict to variables with a name like the parameter.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableNameLike(variableNameLike string) ApiGetHistoricVariableInstancesCountRequest {
	r.variableNameLike = &variableNameLike
	return r
}

// Filter by variable value. Is treated as a &#x60;String&#x60; object on server side.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableValue(variableValue map[string]interface{}) ApiGetHistoricVariableInstancesCountRequest {
	r.variableValue = &variableValue
	return r
}

// Match the variable name provided in &#x60;variableName&#x60; and &#x60;variableNameLike&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetHistoricVariableInstancesCountRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match the variable value provided in &#x60;variableValue&#x60; case-insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetHistoricVariableInstancesCountRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Only include historic variable instances which belong to one of the passed and comma- separated variable types. A list of all supported variable types can be found [here](https://docs.operaton.org/manual/1.0/user-guide/process-engine/variables/#supported-variable-values). **Note:** All non-primitive variables are associated with the type &#39;serializable&#39;.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableTypeIn(variableTypeIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.variableTypeIn = &variableTypeIn
	return r
}

// Include variables that has already been deleted during the execution.
func (r ApiGetHistoricVariableInstancesCountRequest) IncludeDeleted(includeDeleted bool) ApiGetHistoricVariableInstancesCountRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// Filter by the process instance the variable belongs to.
func (r ApiGetHistoricVariableInstancesCountRequest) ProcessInstanceId(processInstanceId string) ApiGetHistoricVariableInstancesCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Only include historic variable instances which belong to one of the passed and comma-separated process instance ids.
func (r ApiGetHistoricVariableInstancesCountRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Filter by the process definition the variable belongs to.
func (r ApiGetHistoricVariableInstancesCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetHistoricVariableInstancesCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a key of the process definition the variable belongs to.
func (r ApiGetHistoricVariableInstancesCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetHistoricVariableInstancesCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated execution ids.
func (r ApiGetHistoricVariableInstancesCountRequest) ExecutionIdIn(executionIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.executionIdIn = &executionIdIn
	return r
}

// Filter by the case instance the variable belongs to.
func (r ApiGetHistoricVariableInstancesCountRequest) CaseInstanceId(caseInstanceId string) ApiGetHistoricVariableInstancesCountRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated case execution ids.
func (r ApiGetHistoricVariableInstancesCountRequest) CaseExecutionIdIn(caseExecutionIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.caseExecutionIdIn = &caseExecutionIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated case activity ids.
func (r ApiGetHistoricVariableInstancesCountRequest) CaseActivityIdIn(caseActivityIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.caseActivityIdIn = &caseActivityIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated task ids.
func (r ApiGetHistoricVariableInstancesCountRequest) TaskIdIn(taskIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and and comma-separated activity instance ids.
func (r ApiGetHistoricVariableInstancesCountRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include historic variable instances which belong to one of the passed and comma- separated tenant ids.
func (r ApiGetHistoricVariableInstancesCountRequest) TenantIdIn(tenantIdIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include historic variable instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetHistoricVariableInstancesCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetHistoricVariableInstancesCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Only include historic variable instances which belong to one of the passed and comma-separated variable names.
func (r ApiGetHistoricVariableInstancesCountRequest) VariableNameIn(variableNameIn string) ApiGetHistoricVariableInstancesCountRequest {
	r.variableNameIn = &variableNameIn
	return r
}

func (r ApiGetHistoricVariableInstancesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetHistoricVariableInstancesCountExecute(r)
}

/*
GetHistoricVariableInstancesCount Get Variable Instance Count

Queries for the number of historic variable instances that fulfill the given
parameters.
Takes the same parameters as the
[Get Variable Instances](https://docs.operaton.org/manual/1.0/reference/rest/history/variable-instance/get-variable-instance-query/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoricVariableInstancesCountRequest
*/
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstancesCount(ctx context.Context) ApiGetHistoricVariableInstancesCountRequest {
	return ApiGetHistoricVariableInstancesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *HistoricVariableInstanceAPIService) GetHistoricVariableInstancesCountExecute(r ApiGetHistoricVariableInstancesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.GetHistoricVariableInstancesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableName", r.variableName, "")
	}
	if r.variableNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNameLike", r.variableNameLike, "")
	}
	if r.variableValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValue", r.variableValue, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	}
	if r.variableTypeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableTypeIn", r.variableTypeIn, "")
	}
	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeleted", r.includeDeleted, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.executionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionIdIn", r.executionIdIn, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseExecutionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionIdIn", r.caseExecutionIdIn, "")
	}
	if r.caseActivityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseActivityIdIn", r.caseActivityIdIn, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.variableNameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNameIn", r.variableNameIn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryHistoricVariableInstancesRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	firstResult *int32
	maxResults *int32
	deserializeValues *bool
	historicVariableInstanceQueryDto *HistoricVariableInstanceQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryHistoricVariableInstancesRequest) FirstResult(firstResult int32) ApiQueryHistoricVariableInstancesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryHistoricVariableInstancesRequest) MaxResults(maxResults int32) ApiQueryHistoricVariableInstancesRequest {
	r.maxResults = &maxResults
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiQueryHistoricVariableInstancesRequest) DeserializeValues(deserializeValues bool) ApiQueryHistoricVariableInstancesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiQueryHistoricVariableInstancesRequest) HistoricVariableInstanceQueryDto(historicVariableInstanceQueryDto HistoricVariableInstanceQueryDto) ApiQueryHistoricVariableInstancesRequest {
	r.historicVariableInstanceQueryDto = &historicVariableInstanceQueryDto
	return r
}

func (r ApiQueryHistoricVariableInstancesRequest) Execute() ([]HistoricVariableInstanceDto, *http.Response, error) {
	return r.ApiService.QueryHistoricVariableInstancesExecute(r)
}

/*
QueryHistoricVariableInstances Get Variable Instances (POST)

Queries for historic variable instances that fulfill the given parameters.
This method is slightly more powerful than the
[Get Variable Instances](https://docs.operaton.org/manual/1.0/reference/rest/history/variable-instance/get-variable-instance-query/)
method because it allows filtering by variable values of the different
types `String`, `Number` or `Boolean`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryHistoricVariableInstancesRequest
*/
func (a *HistoricVariableInstanceAPIService) QueryHistoricVariableInstances(ctx context.Context) ApiQueryHistoricVariableInstancesRequest {
	return ApiQueryHistoricVariableInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HistoricVariableInstanceDto
func (a *HistoricVariableInstanceAPIService) QueryHistoricVariableInstancesExecute(r ApiQueryHistoricVariableInstancesRequest) ([]HistoricVariableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HistoricVariableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.QueryHistoricVariableInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historicVariableInstanceQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryHistoricVariableInstancesCountRequest struct {
	ctx context.Context
	ApiService *HistoricVariableInstanceAPIService
	historicVariableInstanceQueryDto *HistoricVariableInstanceQueryDto
}

func (r ApiQueryHistoricVariableInstancesCountRequest) HistoricVariableInstanceQueryDto(historicVariableInstanceQueryDto HistoricVariableInstanceQueryDto) ApiQueryHistoricVariableInstancesCountRequest {
	r.historicVariableInstanceQueryDto = &historicVariableInstanceQueryDto
	return r
}

func (r ApiQueryHistoricVariableInstancesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryHistoricVariableInstancesCountExecute(r)
}

/*
QueryHistoricVariableInstancesCount Get Variable Instance Count (POST)

Queries for historic variable instances that fulfill the given parameters.
This method takes the same message body as the
[Get Variable Instances (POST)](https://docs.operaton.org/manual/1.0/reference/rest/history/variable-instance/post-variable-instance-query/)
method and therefore it is more powerful regarding variable values
than the
[Get Variable Instance Count](https://docs.operaton.org/manual/1.0/reference/rest/history/variable-instance/get-variable-instance-query-count/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryHistoricVariableInstancesCountRequest
*/
func (a *HistoricVariableInstanceAPIService) QueryHistoricVariableInstancesCount(ctx context.Context) ApiQueryHistoricVariableInstancesCountRequest {
	return ApiQueryHistoricVariableInstancesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *HistoricVariableInstanceAPIService) QueryHistoricVariableInstancesCountExecute(r ApiQueryHistoricVariableInstancesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricVariableInstanceAPIService.QueryHistoricVariableInstancesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/variable-instance/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historicVariableInstanceQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
