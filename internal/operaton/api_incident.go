/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// IncidentAPIService IncidentAPI service
type IncidentAPIService service

type ApiClearIncidentAnnotationRequest struct {
	ctx        context.Context
	ApiService *IncidentAPIService
	id         string
}

func (r ApiClearIncidentAnnotationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearIncidentAnnotationExecute(r)
}

/*
ClearIncidentAnnotation Clear Incident Annotation

Clears the annotation of an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to clear the annotation at.
	@return ApiClearIncidentAnnotationRequest
*/
func (a *IncidentAPIService) ClearIncidentAnnotation(ctx context.Context, id string) ApiClearIncidentAnnotationRequest {
	return ApiClearIncidentAnnotationRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) ClearIncidentAnnotationExecute(r ApiClearIncidentAnnotationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.ClearIncidentAnnotation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIncidentRequest struct {
	ctx        context.Context
	ApiService *IncidentAPIService
	id         string
}

func (r ApiGetIncidentRequest) Execute() (*IncidentDto, *http.Response, error) {
	return r.ApiService.GetIncidentExecute(r)
}

/*
GetIncident Get Incident

Retrieves an incident by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to be retrieved.
	@return ApiGetIncidentRequest
*/
func (a *IncidentAPIService) GetIncident(ctx context.Context, id string) ApiGetIncidentRequest {
	return ApiGetIncidentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IncidentDto
func (a *IncidentAPIService) GetIncidentExecute(r ApiGetIncidentRequest) (*IncidentDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IncidentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncident")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIncidentsRequest struct {
	ctx                     context.Context
	ApiService              *IncidentAPIService
	incidentId              *string
	incidentType            *string
	incidentMessage         *string
	incidentMessageLike     *string
	processDefinitionId     *string
	processDefinitionKeyIn  *string
	processInstanceId       *string
	executionId             *string
	incidentTimestampBefore *time.Time
	incidentTimestampAfter  *time.Time
	activityId              *string
	failedActivityId        *string
	causeIncidentId         *string
	rootCauseIncidentId     *string
	configuration           *string
	tenantIdIn              *string
	jobDefinitionIdIn       *string
	sortBy                  *string
	sortOrder               *string
	firstResult             *int32
	maxResults              *int32
}

// Restricts to incidents that have the given id.
func (r ApiGetIncidentsRequest) IncidentId(incidentId string) ApiGetIncidentsRequest {
	r.incidentId = &incidentId
	return r
}

// Restricts to incidents that belong to the given incident type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetIncidentsRequest) IncidentType(incidentType string) ApiGetIncidentsRequest {
	r.incidentType = &incidentType
	return r
}

// Restricts to incidents that have the given incident message.
func (r ApiGetIncidentsRequest) IncidentMessage(incidentMessage string) ApiGetIncidentsRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Restricts to incidents that incidents message is a substring of the given value. The string can include the wildcard character &#39;%&#39; to express like-strategy: starts with (&#x60;string%&#x60;), ends with (&#x60;%string&#x60;) or contains (&#x60;%string%&#x60;).
func (r ApiGetIncidentsRequest) IncidentMessageLike(incidentMessageLike string) ApiGetIncidentsRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Restricts to incidents that belong to a process definition with the given id.
func (r ApiGetIncidentsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetIncidentsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restricts to incidents that belong to a process definition with the given keys. Must be a comma-separated list.
func (r ApiGetIncidentsRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetIncidentsRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restricts to incidents that belong to a process instance with the given id.
func (r ApiGetIncidentsRequest) ProcessInstanceId(processInstanceId string) ApiGetIncidentsRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restricts to incidents that belong to an execution with the given id.
func (r ApiGetIncidentsRequest) ExecutionId(executionId string) ApiGetIncidentsRequest {
	r.executionId = &executionId
	return r
}

// Restricts to incidents that have an incidentTimestamp date before the given date.  By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsRequest) IncidentTimestampBefore(incidentTimestampBefore time.Time) ApiGetIncidentsRequest {
	r.incidentTimestampBefore = &incidentTimestampBefore
	return r
}

// Restricts to incidents that have an incidentTimestamp date after the given date.  By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsRequest) IncidentTimestampAfter(incidentTimestampAfter time.Time) ApiGetIncidentsRequest {
	r.incidentTimestampAfter = &incidentTimestampAfter
	return r
}

// Restricts to incidents that belong to an activity with the given id.
func (r ApiGetIncidentsRequest) ActivityId(activityId string) ApiGetIncidentsRequest {
	r.activityId = &activityId
	return r
}

// Restricts to incidents that were created due to the failure of an activity with the given id.
func (r ApiGetIncidentsRequest) FailedActivityId(failedActivityId string) ApiGetIncidentsRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Restricts to incidents that have the given incident id as cause incident.
func (r ApiGetIncidentsRequest) CauseIncidentId(causeIncidentId string) ApiGetIncidentsRequest {
	r.causeIncidentId = &causeIncidentId
	return r
}

// Restricts to incidents that have the given incident id as root cause incident.
func (r ApiGetIncidentsRequest) RootCauseIncidentId(rootCauseIncidentId string) ApiGetIncidentsRequest {
	r.rootCauseIncidentId = &rootCauseIncidentId
	return r
}

// Restricts to incidents that have the given parameter set as configuration.
func (r ApiGetIncidentsRequest) Configuration(configuration string) ApiGetIncidentsRequest {
	r.configuration = &configuration
	return r
}

// Restricts to incidents that have one of the given comma-separated tenant ids.
func (r ApiGetIncidentsRequest) TenantIdIn(tenantIdIn string) ApiGetIncidentsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Restricts to incidents that have one of the given comma-separated job definition ids.
func (r ApiGetIncidentsRequest) JobDefinitionIdIn(jobDefinitionIdIn string) ApiGetIncidentsRequest {
	r.jobDefinitionIdIn = &jobDefinitionIdIn
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetIncidentsRequest) SortBy(sortBy string) ApiGetIncidentsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetIncidentsRequest) SortOrder(sortOrder string) ApiGetIncidentsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetIncidentsRequest) FirstResult(firstResult int32) ApiGetIncidentsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetIncidentsRequest) MaxResults(maxResults int32) ApiGetIncidentsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetIncidentsRequest) Execute() ([]IncidentDto, *http.Response, error) {
	return r.ApiService.GetIncidentsExecute(r)
}

/*
GetIncidents Get List

Queries for incidents that fulfill given parameters. The size of the result set can be retrieved by using
the [Get Incident Count](https://docs.operaton.org/manual/1.0/reference/rest/incident/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIncidentsRequest
*/
func (a *IncidentAPIService) GetIncidents(ctx context.Context) ApiGetIncidentsRequest {
	return ApiGetIncidentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IncidentDto
func (a *IncidentAPIService) GetIncidentsExecute(r ApiGetIncidentsRequest) ([]IncidentDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IncidentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.incidentTimestampBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampBefore", r.incidentTimestampBefore, "")
	}
	if r.incidentTimestampAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampAfter", r.incidentTimestampAfter, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.causeIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "causeIncidentId", r.causeIncidentId, "")
	}
	if r.rootCauseIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootCauseIncidentId", r.rootCauseIncidentId, "")
	}
	if r.configuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configuration", r.configuration, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.jobDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionIdIn", r.jobDefinitionIdIn, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIncidentsCountRequest struct {
	ctx                     context.Context
	ApiService              *IncidentAPIService
	incidentId              *string
	incidentType            *string
	incidentMessage         *string
	incidentMessageLike     *string
	processDefinitionId     *string
	processDefinitionKeyIn  *string
	processInstanceId       *string
	executionId             *string
	incidentTimestampBefore *time.Time
	incidentTimestampAfter  *time.Time
	activityId              *string
	failedActivityId        *string
	causeIncidentId         *string
	rootCauseIncidentId     *string
	configuration           *string
	tenantIdIn              *string
	jobDefinitionIdIn       *string
}

// Restricts to incidents that have the given id.
func (r ApiGetIncidentsCountRequest) IncidentId(incidentId string) ApiGetIncidentsCountRequest {
	r.incidentId = &incidentId
	return r
}

// Restricts to incidents that belong to the given incident type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetIncidentsCountRequest) IncidentType(incidentType string) ApiGetIncidentsCountRequest {
	r.incidentType = &incidentType
	return r
}

// Restricts to incidents that have the given incident message.
func (r ApiGetIncidentsCountRequest) IncidentMessage(incidentMessage string) ApiGetIncidentsCountRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Restricts to incidents that incidents message is a substring of the given value. The string can include the wildcard character &#39;%&#39; to express like-strategy: starts with (&#x60;string%&#x60;), ends with (&#x60;%string&#x60;) or contains (&#x60;%string%&#x60;).
func (r ApiGetIncidentsCountRequest) IncidentMessageLike(incidentMessageLike string) ApiGetIncidentsCountRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Restricts to incidents that belong to a process definition with the given id.
func (r ApiGetIncidentsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetIncidentsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restricts to incidents that belong to a process definition with the given keys. Must be a comma-separated list.
func (r ApiGetIncidentsCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetIncidentsCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restricts to incidents that belong to a process instance with the given id.
func (r ApiGetIncidentsCountRequest) ProcessInstanceId(processInstanceId string) ApiGetIncidentsCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restricts to incidents that belong to an execution with the given id.
func (r ApiGetIncidentsCountRequest) ExecutionId(executionId string) ApiGetIncidentsCountRequest {
	r.executionId = &executionId
	return r
}

// Restricts to incidents that have an incidentTimestamp date before the given date.  By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsCountRequest) IncidentTimestampBefore(incidentTimestampBefore time.Time) ApiGetIncidentsCountRequest {
	r.incidentTimestampBefore = &incidentTimestampBefore
	return r
}

// Restricts to incidents that have an incidentTimestamp date after the given date.  By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsCountRequest) IncidentTimestampAfter(incidentTimestampAfter time.Time) ApiGetIncidentsCountRequest {
	r.incidentTimestampAfter = &incidentTimestampAfter
	return r
}

// Restricts to incidents that belong to an activity with the given id.
func (r ApiGetIncidentsCountRequest) ActivityId(activityId string) ApiGetIncidentsCountRequest {
	r.activityId = &activityId
	return r
}

// Restricts to incidents that were created due to the failure of an activity with the given id.
func (r ApiGetIncidentsCountRequest) FailedActivityId(failedActivityId string) ApiGetIncidentsCountRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Restricts to incidents that have the given incident id as cause incident.
func (r ApiGetIncidentsCountRequest) CauseIncidentId(causeIncidentId string) ApiGetIncidentsCountRequest {
	r.causeIncidentId = &causeIncidentId
	return r
}

// Restricts to incidents that have the given incident id as root cause incident.
func (r ApiGetIncidentsCountRequest) RootCauseIncidentId(rootCauseIncidentId string) ApiGetIncidentsCountRequest {
	r.rootCauseIncidentId = &rootCauseIncidentId
	return r
}

// Restricts to incidents that have the given parameter set as configuration.
func (r ApiGetIncidentsCountRequest) Configuration(configuration string) ApiGetIncidentsCountRequest {
	r.configuration = &configuration
	return r
}

// Restricts to incidents that have one of the given comma-separated tenant ids.
func (r ApiGetIncidentsCountRequest) TenantIdIn(tenantIdIn string) ApiGetIncidentsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Restricts to incidents that have one of the given comma-separated job definition ids.
func (r ApiGetIncidentsCountRequest) JobDefinitionIdIn(jobDefinitionIdIn string) ApiGetIncidentsCountRequest {
	r.jobDefinitionIdIn = &jobDefinitionIdIn
	return r
}

func (r ApiGetIncidentsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetIncidentsCountExecute(r)
}

/*
GetIncidentsCount Get List Count

Queries for the number of incidents that fulfill given parameters. Takes the same parameters as the
[Get Incidents](https://docs.operaton.org/manual/1.0/reference/rest/incident/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIncidentsCountRequest
*/
func (a *IncidentAPIService) GetIncidentsCount(ctx context.Context) ApiGetIncidentsCountRequest {
	return ApiGetIncidentsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *IncidentAPIService) GetIncidentsCountExecute(r ApiGetIncidentsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncidentsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.incidentTimestampBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampBefore", r.incidentTimestampBefore, "")
	}
	if r.incidentTimestampAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampAfter", r.incidentTimestampAfter, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.causeIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "causeIncidentId", r.causeIncidentId, "")
	}
	if r.rootCauseIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootCauseIncidentId", r.rootCauseIncidentId, "")
	}
	if r.configuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configuration", r.configuration, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.jobDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionIdIn", r.jobDefinitionIdIn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveIncidentRequest struct {
	ctx        context.Context
	ApiService *IncidentAPIService
	id         string
}

func (r ApiResolveIncidentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResolveIncidentExecute(r)
}

/*
ResolveIncident Resolve Incident

Resolves an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to be resolved.
	@return ApiResolveIncidentRequest
*/
func (a *IncidentAPIService) ResolveIncident(ctx context.Context, id string) ApiResolveIncidentRequest {
	return ApiResolveIncidentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) ResolveIncidentExecute(r ApiResolveIncidentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.ResolveIncident")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetIncidentAnnotationRequest struct {
	ctx           context.Context
	ApiService    *IncidentAPIService
	id            string
	annotationDto *AnnotationDto
}

func (r ApiSetIncidentAnnotationRequest) AnnotationDto(annotationDto AnnotationDto) ApiSetIncidentAnnotationRequest {
	r.annotationDto = &annotationDto
	return r
}

func (r ApiSetIncidentAnnotationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetIncidentAnnotationExecute(r)
}

/*
SetIncidentAnnotation Set Incident Annotation

Sets the annotation of an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to clear the annotation at.
	@return ApiSetIncidentAnnotationRequest
*/
func (a *IncidentAPIService) SetIncidentAnnotation(ctx context.Context, id string) ApiSetIncidentAnnotationRequest {
	return ApiSetIncidentAnnotationRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) SetIncidentAnnotationExecute(r ApiSetIncidentAnnotationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.SetIncidentAnnotation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.annotationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
