/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// JobAPIService JobAPI service
type JobAPIService service

type ApiDeleteJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
}

func (r ApiDeleteJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJobExecute(r)
}

/*
DeleteJob Delete Job

Deletes a job by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be deleted.
 @return ApiDeleteJobRequest
*/
func (a *JobAPIService) DeleteJob(ctx context.Context, id string) ApiDeleteJobRequest {
	return ApiDeleteJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) DeleteJobExecute(r ApiDeleteJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.DeleteJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExecuteJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
}

func (r ApiExecuteJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExecuteJobExecute(r)
}

/*
ExecuteJob Execute Job

Executes a job by id. **Note:** The execution of the job happens synchronously in
the same thread.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be executed.
 @return ApiExecuteJobRequest
*/
func (a *JobAPIService) ExecuteJob(ctx context.Context, id string) ApiExecuteJobRequest {
	return ApiExecuteJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) ExecuteJobExecute(r ApiExecuteJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.ExecuteJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
}

func (r ApiGetJobRequest) Execute() (*JobDto, *http.Response, error) {
	return r.ApiService.GetJobExecute(r)
}

/*
GetJob Get Job

Retrieves a job by id, according to the `Job` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be retrieved.
 @return ApiGetJobRequest
*/
func (a *JobAPIService) GetJob(ctx context.Context, id string) ApiGetJobRequest {
	return ApiGetJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobDto
func (a *JobAPIService) GetJobExecute(r ApiGetJobRequest) (*JobDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId *string
	jobIds *string
	jobDefinitionId *string
	processInstanceId *string
	processInstanceIds *string
	executionId *string
	processDefinitionId *string
	processDefinitionKey *string
	activityId *string
	withRetriesLeft *bool
	executable *bool
	timers *bool
	messages *bool
	dueDates *string
	createTimes *string
	withException *bool
	exceptionMessage *string
	failedActivityId *string
	noRetriesLeft *bool
	active *bool
	suspended *bool
	priorityLowerThanOrEquals *int64
	priorityHigherThanOrEquals *int64
	tenantIdIn *string
	withoutTenantId *bool
	includeJobsWithoutTenantId *bool
	acquired *bool
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by job id.
func (r ApiGetJobsRequest) JobId(jobId string) ApiGetJobsRequest {
	r.jobId = &jobId
	return r
}

// Filter by a comma-separated list of job ids.
func (r ApiGetJobsRequest) JobIds(jobIds string) ApiGetJobsRequest {
	r.jobIds = &jobIds
	return r
}

// Only select jobs which exist for the given job definition.
func (r ApiGetJobsRequest) JobDefinitionId(jobDefinitionId string) ApiGetJobsRequest {
	r.jobDefinitionId = &jobDefinitionId
	return r
}

// Only select jobs which exist for the given process instance.
func (r ApiGetJobsRequest) ProcessInstanceId(processInstanceId string) ApiGetJobsRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Only select jobs which exist for the given comma-separated list of process instance ids.
func (r ApiGetJobsRequest) ProcessInstanceIds(processInstanceIds string) ApiGetJobsRequest {
	r.processInstanceIds = &processInstanceIds
	return r
}

// Only select jobs which exist for the given execution.
func (r ApiGetJobsRequest) ExecutionId(executionId string) ApiGetJobsRequest {
	r.executionId = &executionId
	return r
}

// Filter by the id of the process definition the jobs run on.
func (r ApiGetJobsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetJobsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the key of the process definition the jobs run on.
func (r ApiGetJobsRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetJobsRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only select jobs which exist for an activity with the given id.
func (r ApiGetJobsRequest) ActivityId(activityId string) ApiGetJobsRequest {
	r.activityId = &activityId
	return r
}

// Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) WithRetriesLeft(withRetriesLeft bool) ApiGetJobsRequest {
	r.withRetriesLeft = &withRetriesLeft
	return r
}

// Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) Executable(executable bool) ApiGetJobsRequest {
	r.executable = &executable
	return r
}

// Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) Timers(timers bool) ApiGetJobsRequest {
	r.timers = &timers
	return r
}

// Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) Messages(messages bool) ApiGetJobsRequest {
	r.messages = &messages
	return r
}

// Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetJobsRequest) DueDates(dueDates string) ApiGetJobsRequest {
	r.dueDates = &dueDates
	return r
}

// Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetJobsRequest) CreateTimes(createTimes string) ApiGetJobsRequest {
	r.createTimes = &createTimes
	return r
}

// Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) WithException(withException bool) ApiGetJobsRequest {
	r.withException = &withException
	return r
}

// Only select jobs that failed due to an exception with the given message.
func (r ApiGetJobsRequest) ExceptionMessage(exceptionMessage string) ApiGetJobsRequest {
	r.exceptionMessage = &exceptionMessage
	return r
}

// Only select jobs that failed due to an exception at an activity with the given id.
func (r ApiGetJobsRequest) FailedActivityId(failedActivityId string) ApiGetJobsRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) NoRetriesLeft(noRetriesLeft bool) ApiGetJobsRequest {
	r.noRetriesLeft = &noRetriesLeft
	return r
}

// Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) Active(active bool) ApiGetJobsRequest {
	r.active = &active
	return r
}

// Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) Suspended(suspended bool) ApiGetJobsRequest {
	r.suspended = &suspended
	return r
}

// Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetJobsRequest) PriorityLowerThanOrEquals(priorityLowerThanOrEquals int64) ApiGetJobsRequest {
	r.priorityLowerThanOrEquals = &priorityLowerThanOrEquals
	return r
}

// Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetJobsRequest) PriorityHigherThanOrEquals(priorityHigherThanOrEquals int64) ApiGetJobsRequest {
	r.priorityHigherThanOrEquals = &priorityHigherThanOrEquals
	return r
}

// Only include jobs which belong to one of the passed comma-separated tenant ids.
func (r ApiGetJobsRequest) TenantIdIn(tenantIdIn string) ApiGetJobsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) WithoutTenantId(withoutTenantId bool) ApiGetJobsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsRequest) IncludeJobsWithoutTenantId(includeJobsWithoutTenantId bool) ApiGetJobsRequest {
	r.includeJobsWithoutTenantId = &includeJobsWithoutTenantId
	return r
}

// Only select jobs which are acquired, i.e.,  lock expiration date is not null, lock expiration date is in future. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. This does not take account if the job is suspended. This filter can be used with the suspension filter.
func (r ApiGetJobsRequest) Acquired(acquired bool) ApiGetJobsRequest {
	r.acquired = &acquired
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetJobsRequest) SortBy(sortBy string) ApiGetJobsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetJobsRequest) SortOrder(sortOrder string) ApiGetJobsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetJobsRequest) FirstResult(firstResult int32) ApiGetJobsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetJobsRequest) MaxResults(maxResults int32) ApiGetJobsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetJobsRequest) Execute() ([]JobDto, *http.Response, error) {
	return r.ApiService.GetJobsExecute(r)
}

/*
GetJobs Get Jobs

Queries for jobs that fulfill given parameters.
The size of the result set can be retrieved by using the [Get Job
Count](https://docs.operaton.org/manual/1.0/reference/rest/job/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJobsRequest
*/
func (a *JobAPIService) GetJobs(ctx context.Context) ApiGetJobsRequest {
	return ApiGetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JobDto
func (a *JobAPIService) GetJobsExecute(r ApiGetJobsRequest) ([]JobDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobId", r.jobId, "")
	}
	if r.jobIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobIds", r.jobIds, "")
	}
	if r.jobDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionId", r.jobDefinitionId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIds", r.processInstanceIds, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.withRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRetriesLeft", r.withRetriesLeft, "")
	}
	if r.executable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executable", r.executable, "")
	}
	if r.timers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timers", r.timers, "")
	}
	if r.messages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messages", r.messages, "")
	}
	if r.dueDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDates", r.dueDates, "")
	}
	if r.createTimes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimes", r.createTimes, "")
	}
	if r.withException != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withException", r.withException, "")
	}
	if r.exceptionMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exceptionMessage", r.exceptionMessage, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.noRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noRetriesLeft", r.noRetriesLeft, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.priorityLowerThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityLowerThanOrEquals", r.priorityLowerThanOrEquals, "")
	}
	if r.priorityHigherThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityHigherThanOrEquals", r.priorityHigherThanOrEquals, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeJobsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeJobsWithoutTenantId", r.includeJobsWithoutTenantId, "")
	}
	if r.acquired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acquired", r.acquired, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobsCountRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId *string
	jobIds *string
	jobDefinitionId *string
	processInstanceId *string
	processInstanceIds *string
	executionId *string
	processDefinitionId *string
	processDefinitionKey *string
	activityId *string
	withRetriesLeft *bool
	executable *bool
	timers *bool
	messages *bool
	dueDates *string
	createTimes *string
	withException *bool
	exceptionMessage *string
	failedActivityId *string
	noRetriesLeft *bool
	active *bool
	suspended *bool
	priorityLowerThanOrEquals *int64
	priorityHigherThanOrEquals *int64
	tenantIdIn *string
	withoutTenantId *bool
	includeJobsWithoutTenantId *bool
	acquired *bool
}

// Filter by job id.
func (r ApiGetJobsCountRequest) JobId(jobId string) ApiGetJobsCountRequest {
	r.jobId = &jobId
	return r
}

// Filter by a comma-separated list of job ids.
func (r ApiGetJobsCountRequest) JobIds(jobIds string) ApiGetJobsCountRequest {
	r.jobIds = &jobIds
	return r
}

// Only select jobs which exist for the given job definition.
func (r ApiGetJobsCountRequest) JobDefinitionId(jobDefinitionId string) ApiGetJobsCountRequest {
	r.jobDefinitionId = &jobDefinitionId
	return r
}

// Only select jobs which exist for the given process instance.
func (r ApiGetJobsCountRequest) ProcessInstanceId(processInstanceId string) ApiGetJobsCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Only select jobs which exist for the given comma-separated list of process instance ids.
func (r ApiGetJobsCountRequest) ProcessInstanceIds(processInstanceIds string) ApiGetJobsCountRequest {
	r.processInstanceIds = &processInstanceIds
	return r
}

// Only select jobs which exist for the given execution.
func (r ApiGetJobsCountRequest) ExecutionId(executionId string) ApiGetJobsCountRequest {
	r.executionId = &executionId
	return r
}

// Filter by the id of the process definition the jobs run on.
func (r ApiGetJobsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetJobsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by the key of the process definition the jobs run on.
func (r ApiGetJobsCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetJobsCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only select jobs which exist for an activity with the given id.
func (r ApiGetJobsCountRequest) ActivityId(activityId string) ApiGetJobsCountRequest {
	r.activityId = &activityId
	return r
}

// Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) WithRetriesLeft(withRetriesLeft bool) ApiGetJobsCountRequest {
	r.withRetriesLeft = &withRetriesLeft
	return r
}

// Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) Executable(executable bool) ApiGetJobsCountRequest {
	r.executable = &executable
	return r
}

// Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) Timers(timers bool) ApiGetJobsCountRequest {
	r.timers = &timers
	return r
}

// Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) Messages(messages bool) ApiGetJobsCountRequest {
	r.messages = &messages
	return r
}

// Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetJobsCountRequest) DueDates(dueDates string) ApiGetJobsCountRequest {
	r.dueDates = &dueDates
	return r
}

// Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetJobsCountRequest) CreateTimes(createTimes string) ApiGetJobsCountRequest {
	r.createTimes = &createTimes
	return r
}

// Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) WithException(withException bool) ApiGetJobsCountRequest {
	r.withException = &withException
	return r
}

// Only select jobs that failed due to an exception with the given message.
func (r ApiGetJobsCountRequest) ExceptionMessage(exceptionMessage string) ApiGetJobsCountRequest {
	r.exceptionMessage = &exceptionMessage
	return r
}

// Only select jobs that failed due to an exception at an activity with the given id.
func (r ApiGetJobsCountRequest) FailedActivityId(failedActivityId string) ApiGetJobsCountRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) NoRetriesLeft(noRetriesLeft bool) ApiGetJobsCountRequest {
	r.noRetriesLeft = &noRetriesLeft
	return r
}

// Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) Active(active bool) ApiGetJobsCountRequest {
	r.active = &active
	return r
}

// Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) Suspended(suspended bool) ApiGetJobsCountRequest {
	r.suspended = &suspended
	return r
}

// Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetJobsCountRequest) PriorityLowerThanOrEquals(priorityLowerThanOrEquals int64) ApiGetJobsCountRequest {
	r.priorityLowerThanOrEquals = &priorityLowerThanOrEquals
	return r
}

// Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
func (r ApiGetJobsCountRequest) PriorityHigherThanOrEquals(priorityHigherThanOrEquals int64) ApiGetJobsCountRequest {
	r.priorityHigherThanOrEquals = &priorityHigherThanOrEquals
	return r
}

// Only include jobs which belong to one of the passed comma-separated tenant ids.
func (r ApiGetJobsCountRequest) TenantIdIn(tenantIdIn string) ApiGetJobsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetJobsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobsCountRequest) IncludeJobsWithoutTenantId(includeJobsWithoutTenantId bool) ApiGetJobsCountRequest {
	r.includeJobsWithoutTenantId = &includeJobsWithoutTenantId
	return r
}

// Only select jobs which are acquired, i.e.,  lock expiration date is not null, lock expiration date is in future. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. This does not take account if the job is suspended. This filter can be used with the suspension filter.
func (r ApiGetJobsCountRequest) Acquired(acquired bool) ApiGetJobsCountRequest {
	r.acquired = &acquired
	return r
}

func (r ApiGetJobsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetJobsCountExecute(r)
}

/*
GetJobsCount Get Job Count

Queries for the number of jobs that fulfill given parameters.
Takes the same parameters as the [Get
Jobs](https://docs.operaton.org/manual/1.0/reference/rest/job/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJobsCountRequest
*/
func (a *JobAPIService) GetJobsCount(ctx context.Context) ApiGetJobsCountRequest {
	return ApiGetJobsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *JobAPIService) GetJobsCountExecute(r ApiGetJobsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobId", r.jobId, "")
	}
	if r.jobIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobIds", r.jobIds, "")
	}
	if r.jobDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionId", r.jobDefinitionId, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIds", r.processInstanceIds, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.withRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRetriesLeft", r.withRetriesLeft, "")
	}
	if r.executable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executable", r.executable, "")
	}
	if r.timers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timers", r.timers, "")
	}
	if r.messages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messages", r.messages, "")
	}
	if r.dueDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDates", r.dueDates, "")
	}
	if r.createTimes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimes", r.createTimes, "")
	}
	if r.withException != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withException", r.withException, "")
	}
	if r.exceptionMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exceptionMessage", r.exceptionMessage, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.noRetriesLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noRetriesLeft", r.noRetriesLeft, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.priorityLowerThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityLowerThanOrEquals", r.priorityLowerThanOrEquals, "")
	}
	if r.priorityHigherThanOrEquals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorityHigherThanOrEquals", r.priorityHigherThanOrEquals, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeJobsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeJobsWithoutTenantId", r.includeJobsWithoutTenantId, "")
	}
	if r.acquired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acquired", r.acquired, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStacktraceRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
}

func (r ApiGetStacktraceRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetStacktraceExecute(r)
}

/*
GetStacktrace Get Exception Stacktrace

Retrieves the exception stacktrace corresponding to the passed job id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to get the exception stacktrace for.
 @return ApiGetStacktraceRequest
*/
func (a *JobAPIService) GetStacktrace(ctx context.Context, id string) ApiGetStacktraceRequest {
	return ApiGetStacktraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return string
func (a *JobAPIService) GetStacktraceExecute(r ApiGetStacktraceRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetStacktrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/stacktrace"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryJobsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	firstResult *int32
	maxResults *int32
	jobQueryDto *JobQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryJobsRequest) FirstResult(firstResult int32) ApiQueryJobsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryJobsRequest) MaxResults(maxResults int32) ApiQueryJobsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryJobsRequest) JobQueryDto(jobQueryDto JobQueryDto) ApiQueryJobsRequest {
	r.jobQueryDto = &jobQueryDto
	return r
}

func (r ApiQueryJobsRequest) Execute() ([]JobDto, *http.Response, error) {
	return r.ApiService.QueryJobsExecute(r)
}

/*
QueryJobs Get Jobs (POST)

Queries for jobs that fulfill given parameters. This method is slightly more
powerful than the [Get Jobs](https://docs.operaton.org/manual/1.0/reference/rest/job/get-query/)
method because it allows filtering by multiple jobs of types `String`,
`Number` or `Boolean`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryJobsRequest
*/
func (a *JobAPIService) QueryJobs(ctx context.Context) ApiQueryJobsRequest {
	return ApiQueryJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JobDto
func (a *JobAPIService) QueryJobsExecute(r ApiQueryJobsRequest) ([]JobDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.QueryJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryJobsCountRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobQueryDto *JobQueryDto
}

func (r ApiQueryJobsCountRequest) JobQueryDto(jobQueryDto JobQueryDto) ApiQueryJobsCountRequest {
	r.jobQueryDto = &jobQueryDto
	return r
}

func (r ApiQueryJobsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryJobsCountExecute(r)
}

/*
QueryJobsCount Get Job Count (POST)

Queries for jobs that fulfill given parameters. This method takes the same message
body as the [Get Jobs POST](https://docs.operaton.org/manual/1.0/reference/rest/job/post-
query/) method and therefore it is slightly more powerful than the
[Get Job Count](https://docs.operaton.org/manual/1.0/reference/rest/job/get-query-count/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryJobsCountRequest
*/
func (a *JobAPIService) QueryJobsCount(ctx context.Context) ApiQueryJobsCountRequest {
	return ApiQueryJobsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *JobAPIService) QueryJobsCountExecute(r ApiQueryJobsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.QueryJobsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecalculateDuedateRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
	creationDateBased *bool
}

// Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
func (r ApiRecalculateDuedateRequest) CreationDateBased(creationDateBased bool) ApiRecalculateDuedateRequest {
	r.creationDateBased = &creationDateBased
	return r
}

func (r ApiRecalculateDuedateRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecalculateDuedateExecute(r)
}

/*
RecalculateDuedate Recalculate Job Due Date

Recalculates the due date of a job by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be updated.
 @return ApiRecalculateDuedateRequest
*/
func (a *JobAPIService) RecalculateDuedate(ctx context.Context, id string) ApiRecalculateDuedateRequest {
	return ApiRecalculateDuedateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) RecalculateDuedateExecute(r ApiRecalculateDuedateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.RecalculateDuedate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/duedate/recalculate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.creationDateBased != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationDateBased", r.creationDateBased, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJobDuedateRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
	jobDuedateDto *JobDuedateDto
}

func (r ApiSetJobDuedateRequest) JobDuedateDto(jobDuedateDto JobDuedateDto) ApiSetJobDuedateRequest {
	r.jobDuedateDto = &jobDuedateDto
	return r
}

func (r ApiSetJobDuedateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJobDuedateExecute(r)
}

/*
SetJobDuedate Set Job Due Date

Updates the due date of a job by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be updated.
 @return ApiSetJobDuedateRequest
*/
func (a *JobAPIService) SetJobDuedate(ctx context.Context, id string) ApiSetJobDuedateRequest {
	return ApiSetJobDuedateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) SetJobDuedateExecute(r ApiSetJobDuedateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.SetJobDuedate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/duedate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDuedateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJobPriorityRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
	priorityDto *PriorityDto
}

func (r ApiSetJobPriorityRequest) PriorityDto(priorityDto PriorityDto) ApiSetJobPriorityRequest {
	r.priorityDto = &priorityDto
	return r
}

func (r ApiSetJobPriorityRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJobPriorityExecute(r)
}

/*
SetJobPriority Set Job Priority

Sets the execution priority of a job by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be updated.
 @return ApiSetJobPriorityRequest
*/
func (a *JobAPIService) SetJobPriority(ctx context.Context, id string) ApiSetJobPriorityRequest {
	return ApiSetJobPriorityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) SetJobPriorityExecute(r ApiSetJobPriorityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.SetJobPriority")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/priority"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.priorityDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJobRetriesRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
	jobRetriesDto *JobRetriesDto
}

func (r ApiSetJobRetriesRequest) JobRetriesDto(jobRetriesDto JobRetriesDto) ApiSetJobRetriesRequest {
	r.jobRetriesDto = &jobRetriesDto
	return r
}

func (r ApiSetJobRetriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJobRetriesExecute(r)
}

/*
SetJobRetries Set Job Retries

Sets the retries of the job to the given number of retries by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to be updated.
 @return ApiSetJobRetriesRequest
*/
func (a *JobAPIService) SetJobRetries(ctx context.Context, id string) ApiSetJobRetriesRequest {
	return ApiSetJobRetriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) SetJobRetriesExecute(r ApiSetJobRetriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.SetJobRetries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/retries"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobRetriesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJobRetriesAsyncOperationRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	setJobRetriesDto *SetJobRetriesDto
}

func (r ApiSetJobRetriesAsyncOperationRequest) SetJobRetriesDto(setJobRetriesDto SetJobRetriesDto) ApiSetJobRetriesAsyncOperationRequest {
	r.setJobRetriesDto = &setJobRetriesDto
	return r
}

func (r ApiSetJobRetriesAsyncOperationRequest) Execute() (*BatchDto, *http.Response, error) {
	return r.ApiService.SetJobRetriesAsyncOperationExecute(r)
}

/*
SetJobRetriesAsyncOperation Set Job Retries Async (POST)

Create a batch to set retries of jobs asynchronously.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetJobRetriesAsyncOperationRequest
*/
func (a *JobAPIService) SetJobRetriesAsyncOperation(ctx context.Context) ApiSetJobRetriesAsyncOperationRequest {
	return ApiSetJobRetriesAsyncOperationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchDto
func (a *JobAPIService) SetJobRetriesAsyncOperationExecute(r ApiSetJobRetriesAsyncOperationRequest) (*BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.SetJobRetriesAsyncOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/retries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setJobRetriesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJobSuspensionStateRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	id string
	suspensionStateDto *SuspensionStateDto
}

func (r ApiUpdateJobSuspensionStateRequest) SuspensionStateDto(suspensionStateDto SuspensionStateDto) ApiUpdateJobSuspensionStateRequest {
	r.suspensionStateDto = &suspensionStateDto
	return r
}

func (r ApiUpdateJobSuspensionStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateJobSuspensionStateExecute(r)
}

/*
UpdateJobSuspensionState Activate/Suspend Job By Id

Activates or suspends a given job by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the job to activate or suspend.
 @return ApiUpdateJobSuspensionStateRequest
*/
func (a *JobAPIService) UpdateJobSuspensionState(ctx context.Context, id string) ApiUpdateJobSuspensionStateRequest {
	return ApiUpdateJobSuspensionStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobAPIService) UpdateJobSuspensionStateExecute(r ApiUpdateJobSuspensionStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.UpdateJobSuspensionState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.suspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSuspensionStateByRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobSuspensionStateDto *JobSuspensionStateDto
}

func (r ApiUpdateSuspensionStateByRequest) JobSuspensionStateDto(jobSuspensionStateDto JobSuspensionStateDto) ApiUpdateSuspensionStateByRequest {
	r.jobSuspensionStateDto = &jobSuspensionStateDto
	return r
}

func (r ApiUpdateSuspensionStateByRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSuspensionStateByExecute(r)
}

/*
UpdateSuspensionStateBy Activate/Suspend Jobs

Activates or suspends jobs matching the given criterion.
This can only be on of:
* `jobDefinitionId`
* `processDefinitionId`
* `processInstanceId`
* `processDefinitionKey`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSuspensionStateByRequest
*/
func (a *JobAPIService) UpdateSuspensionStateBy(ctx context.Context) ApiUpdateSuspensionStateByRequest {
	return ApiUpdateSuspensionStateByRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobAPIService) UpdateSuspensionStateByExecute(r ApiUpdateSuspensionStateByRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.UpdateSuspensionStateBy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/suspended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
