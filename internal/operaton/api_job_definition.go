/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// JobDefinitionAPIService JobDefinitionAPI service
type JobDefinitionAPIService service

type ApiGetJobDefinitionRequest struct {
	ctx        context.Context
	ApiService *JobDefinitionAPIService
	id         string
}

func (r ApiGetJobDefinitionRequest) Execute() (*JobDefinitionDto, *http.Response, error) {
	return r.ApiService.GetJobDefinitionExecute(r)
}

/*
GetJobDefinition Get Job Definition

Retrieves a job definition by id, according to the `JobDefinition` interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the job definition to be retrieved.
	@return ApiGetJobDefinitionRequest
*/
func (a *JobDefinitionAPIService) GetJobDefinition(ctx context.Context, id string) ApiGetJobDefinitionRequest {
	return ApiGetJobDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return JobDefinitionDto
func (a *JobDefinitionAPIService) GetJobDefinitionExecute(r ApiGetJobDefinitionRequest) (*JobDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JobDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.GetJobDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobDefinitionsRequest struct {
	ctx                                  context.Context
	ApiService                           *JobDefinitionAPIService
	jobDefinitionId                      *string
	activityIdIn                         *string
	processDefinitionId                  *string
	processDefinitionKey                 *string
	jobType                              *string
	jobConfiguration                     *string
	active                               *bool
	suspended                            *bool
	withOverridingJobPriority            *bool
	tenantIdIn                           *string
	withoutTenantId                      *bool
	includeJobDefinitionsWithoutTenantId *bool
	sortBy                               *string
	sortOrder                            *string
	firstResult                          *int32
	maxResults                           *int32
}

// Filter by job definition id.
func (r ApiGetJobDefinitionsRequest) JobDefinitionId(jobDefinitionId string) ApiGetJobDefinitionsRequest {
	r.jobDefinitionId = &jobDefinitionId
	return r
}

// Only include job definitions which belong to one of the passed and comma-separated activity ids.
func (r ApiGetJobDefinitionsRequest) ActivityIdIn(activityIdIn string) ApiGetJobDefinitionsRequest {
	r.activityIdIn = &activityIdIn
	return r
}

// Only include job definitions which exist for the given process definition id.
func (r ApiGetJobDefinitionsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetJobDefinitionsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Only include job definitions which exist for the given process definition key.
func (r ApiGetJobDefinitionsRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetJobDefinitionsRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only include job definitions which exist for the given job type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/the-job-executor/#job-creation) for more information about job types.
func (r ApiGetJobDefinitionsRequest) JobType(jobType string) ApiGetJobDefinitionsRequest {
	r.jobType = &jobType
	return r
}

// Only include job definitions which exist for the given job configuration. For example: for timer jobs it is the timer configuration.
func (r ApiGetJobDefinitionsRequest) JobConfiguration(jobConfiguration string) ApiGetJobDefinitionsRequest {
	r.jobConfiguration = &jobConfiguration
	return r
}

// Only include active job definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsRequest) Active(active bool) ApiGetJobDefinitionsRequest {
	r.active = &active
	return r
}

// Only include suspended job definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsRequest) Suspended(suspended bool) ApiGetJobDefinitionsRequest {
	r.suspended = &suspended
	return r
}

// Only include job definitions that have an overriding job priority defined. The only effective value is &#x60;true&#x60;. If set to &#x60;false&#x60;, this filter is not applied.
func (r ApiGetJobDefinitionsRequest) WithOverridingJobPriority(withOverridingJobPriority bool) ApiGetJobDefinitionsRequest {
	r.withOverridingJobPriority = &withOverridingJobPriority
	return r
}

// Only include job definitions which belong to one of the passed and comma-separated tenant ids.
func (r ApiGetJobDefinitionsRequest) TenantIdIn(tenantIdIn string) ApiGetJobDefinitionsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include job definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsRequest) WithoutTenantId(withoutTenantId bool) ApiGetJobDefinitionsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include job definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsRequest) IncludeJobDefinitionsWithoutTenantId(includeJobDefinitionsWithoutTenantId bool) ApiGetJobDefinitionsRequest {
	r.includeJobDefinitionsWithoutTenantId = &includeJobDefinitionsWithoutTenantId
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetJobDefinitionsRequest) SortBy(sortBy string) ApiGetJobDefinitionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetJobDefinitionsRequest) SortOrder(sortOrder string) ApiGetJobDefinitionsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetJobDefinitionsRequest) FirstResult(firstResult int32) ApiGetJobDefinitionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetJobDefinitionsRequest) MaxResults(maxResults int32) ApiGetJobDefinitionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetJobDefinitionsRequest) Execute() ([]JobDefinitionDto, *http.Response, error) {
	return r.ApiService.GetJobDefinitionsExecute(r)
}

/*
GetJobDefinitions Get Job Definitions

Queries for job definitions that fulfill given parameters.
The size of the result set can be retrieved by using the
[Get Job Definition Count](https://docs.operaton.org/manual/1.0/reference/rest/job-definition/get-query-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetJobDefinitionsRequest
*/
func (a *JobDefinitionAPIService) GetJobDefinitions(ctx context.Context) ApiGetJobDefinitionsRequest {
	return ApiGetJobDefinitionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []JobDefinitionDto
func (a *JobDefinitionAPIService) GetJobDefinitionsExecute(r ApiGetJobDefinitionsRequest) ([]JobDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []JobDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.GetJobDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionId", r.jobDefinitionId, "")
	}
	if r.activityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityIdIn", r.activityIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.jobType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobType", r.jobType, "")
	}
	if r.jobConfiguration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobConfiguration", r.jobConfiguration, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.withOverridingJobPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withOverridingJobPriority", r.withOverridingJobPriority, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeJobDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeJobDefinitionsWithoutTenantId", r.includeJobDefinitionsWithoutTenantId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobDefinitionsCountRequest struct {
	ctx                                  context.Context
	ApiService                           *JobDefinitionAPIService
	jobDefinitionId                      *string
	activityIdIn                         *string
	processDefinitionId                  *string
	processDefinitionKey                 *string
	jobType                              *string
	jobConfiguration                     *string
	active                               *bool
	suspended                            *bool
	withOverridingJobPriority            *bool
	tenantIdIn                           *string
	withoutTenantId                      *bool
	includeJobDefinitionsWithoutTenantId *bool
}

// Filter by job definition id.
func (r ApiGetJobDefinitionsCountRequest) JobDefinitionId(jobDefinitionId string) ApiGetJobDefinitionsCountRequest {
	r.jobDefinitionId = &jobDefinitionId
	return r
}

// Only include job definitions which belong to one of the passed and comma-separated activity ids.
func (r ApiGetJobDefinitionsCountRequest) ActivityIdIn(activityIdIn string) ApiGetJobDefinitionsCountRequest {
	r.activityIdIn = &activityIdIn
	return r
}

// Only include job definitions which exist for the given process definition id.
func (r ApiGetJobDefinitionsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetJobDefinitionsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Only include job definitions which exist for the given process definition key.
func (r ApiGetJobDefinitionsCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetJobDefinitionsCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Only include job definitions which exist for the given job type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/the-job-executor/#job-creation) for more information about job types.
func (r ApiGetJobDefinitionsCountRequest) JobType(jobType string) ApiGetJobDefinitionsCountRequest {
	r.jobType = &jobType
	return r
}

// Only include job definitions which exist for the given job configuration. For example: for timer jobs it is the timer configuration.
func (r ApiGetJobDefinitionsCountRequest) JobConfiguration(jobConfiguration string) ApiGetJobDefinitionsCountRequest {
	r.jobConfiguration = &jobConfiguration
	return r
}

// Only include active job definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsCountRequest) Active(active bool) ApiGetJobDefinitionsCountRequest {
	r.active = &active
	return r
}

// Only include suspended job definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsCountRequest) Suspended(suspended bool) ApiGetJobDefinitionsCountRequest {
	r.suspended = &suspended
	return r
}

// Only include job definitions that have an overriding job priority defined. The only effective value is &#x60;true&#x60;. If set to &#x60;false&#x60;, this filter is not applied.
func (r ApiGetJobDefinitionsCountRequest) WithOverridingJobPriority(withOverridingJobPriority bool) ApiGetJobDefinitionsCountRequest {
	r.withOverridingJobPriority = &withOverridingJobPriority
	return r
}

// Only include job definitions which belong to one of the passed and comma-separated tenant ids.
func (r ApiGetJobDefinitionsCountRequest) TenantIdIn(tenantIdIn string) ApiGetJobDefinitionsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include job definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetJobDefinitionsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include job definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetJobDefinitionsCountRequest) IncludeJobDefinitionsWithoutTenantId(includeJobDefinitionsWithoutTenantId bool) ApiGetJobDefinitionsCountRequest {
	r.includeJobDefinitionsWithoutTenantId = &includeJobDefinitionsWithoutTenantId
	return r
}

func (r ApiGetJobDefinitionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetJobDefinitionsCountExecute(r)
}

/*
GetJobDefinitionsCount Get Job Definition Count

Queries for the number of job definitions that fulfill given parameters.
Takes the same parameters as the
[Get Job Definitions](https://docs.operaton.org/manual/1.0/reference/rest/job-definition/get-query/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetJobDefinitionsCountRequest
*/
func (a *JobDefinitionAPIService) GetJobDefinitionsCount(ctx context.Context) ApiGetJobDefinitionsCountRequest {
	return ApiGetJobDefinitionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *JobDefinitionAPIService) GetJobDefinitionsCountExecute(r ApiGetJobDefinitionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.GetJobDefinitionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionId", r.jobDefinitionId, "")
	}
	if r.activityIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityIdIn", r.activityIdIn, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.jobType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobType", r.jobType, "")
	}
	if r.jobConfiguration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobConfiguration", r.jobConfiguration, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.withOverridingJobPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withOverridingJobPriority", r.withOverridingJobPriority, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeJobDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeJobDefinitionsWithoutTenantId", r.includeJobDefinitionsWithoutTenantId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryJobDefinitionsRequest struct {
	ctx                   context.Context
	ApiService            *JobDefinitionAPIService
	firstResult           *int32
	maxResults            *int32
	jobDefinitionQueryDto *JobDefinitionQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryJobDefinitionsRequest) FirstResult(firstResult int32) ApiQueryJobDefinitionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryJobDefinitionsRequest) MaxResults(maxResults int32) ApiQueryJobDefinitionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryJobDefinitionsRequest) JobDefinitionQueryDto(jobDefinitionQueryDto JobDefinitionQueryDto) ApiQueryJobDefinitionsRequest {
	r.jobDefinitionQueryDto = &jobDefinitionQueryDto
	return r
}

func (r ApiQueryJobDefinitionsRequest) Execute() ([]JobDefinitionDto, *http.Response, error) {
	return r.ApiService.QueryJobDefinitionsExecute(r)
}

/*
QueryJobDefinitions Get Job Definitions (POST)

Queries for job definitions that fulfill given parameters. This method is slightly
more powerful than the
[Get Job Definitions](https://docs.operaton.org/manual/1.0/reference/rest/job-definition/get-query/)
method because it allows filtering by multiple job definitions of
types `String`, `Number` or `Boolean`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryJobDefinitionsRequest
*/
func (a *JobDefinitionAPIService) QueryJobDefinitions(ctx context.Context) ApiQueryJobDefinitionsRequest {
	return ApiQueryJobDefinitionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []JobDefinitionDto
func (a *JobDefinitionAPIService) QueryJobDefinitionsExecute(r ApiQueryJobDefinitionsRequest) ([]JobDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []JobDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.QueryJobDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDefinitionQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryJobDefinitionsCountRequest struct {
	ctx                   context.Context
	ApiService            *JobDefinitionAPIService
	jobDefinitionQueryDto *JobDefinitionQueryDto
}

func (r ApiQueryJobDefinitionsCountRequest) JobDefinitionQueryDto(jobDefinitionQueryDto JobDefinitionQueryDto) ApiQueryJobDefinitionsCountRequest {
	r.jobDefinitionQueryDto = &jobDefinitionQueryDto
	return r
}

func (r ApiQueryJobDefinitionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryJobDefinitionsCountExecute(r)
}

/*
QueryJobDefinitionsCount Get Job Definition Count (POST)

Queries for the number of job definitions that fulfill given parameters. This
method takes the same message body as the
[Get Job Definitions (POST)](https://docs.operaton.org/manual/1.0/reference/rest/job-definition/post-query/)
method and therefore it is slightly more powerful than the
[Get Job Definition Count](https://docs.operaton.org/manual/1.0/reference/rest/job-definition/get-query-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryJobDefinitionsCountRequest
*/
func (a *JobDefinitionAPIService) QueryJobDefinitionsCount(ctx context.Context) ApiQueryJobDefinitionsCountRequest {
	return ApiQueryJobDefinitionsCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CountResultDto
func (a *JobDefinitionAPIService) QueryJobDefinitionsCountExecute(r ApiQueryJobDefinitionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.QueryJobDefinitionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDefinitionQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetJobPriorityJobDefinitionRequest struct {
	ctx                      context.Context
	ApiService               *JobDefinitionAPIService
	id                       string
	jobDefinitionPriorityDto *JobDefinitionPriorityDto
}

func (r ApiSetJobPriorityJobDefinitionRequest) JobDefinitionPriorityDto(jobDefinitionPriorityDto JobDefinitionPriorityDto) ApiSetJobPriorityJobDefinitionRequest {
	r.jobDefinitionPriorityDto = &jobDefinitionPriorityDto
	return r
}

func (r ApiSetJobPriorityJobDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJobPriorityJobDefinitionExecute(r)
}

/*
SetJobPriorityJobDefinition Set Job Definition Priority by Id

Sets an overriding execution priority for jobs with the given definition id.
Optionally, the priorities of all the definitions' existing jobs are
updated accordingly. The priority can be reset by setting it to
`null`, meaning that a new job's priority will not be determined based
on its definition's priority any longer. See the
[user guide on job prioritization](https://docs.operaton.org/manual/1.0/user-guide/process-engine/the-job-executor/#set-job-definition-priorities-via-managementservice-api)
for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the job definition to be updated.
	@return ApiSetJobPriorityJobDefinitionRequest
*/
func (a *JobDefinitionAPIService) SetJobPriorityJobDefinition(ctx context.Context, id string) ApiSetJobPriorityJobDefinitionRequest {
	return ApiSetJobPriorityJobDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *JobDefinitionAPIService) SetJobPriorityJobDefinitionExecute(r ApiSetJobPriorityJobDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.SetJobPriorityJobDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/{id}/jobPriority"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDefinitionPriorityDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetJobRetriesJobDefinitionRequest struct {
	ctx        context.Context
	ApiService *JobDefinitionAPIService
	id         string
	retriesDto *RetriesDto
}

func (r ApiSetJobRetriesJobDefinitionRequest) RetriesDto(retriesDto RetriesDto) ApiSetJobRetriesJobDefinitionRequest {
	r.retriesDto = &retriesDto
	return r
}

func (r ApiSetJobRetriesJobDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetJobRetriesJobDefinitionExecute(r)
}

/*
SetJobRetriesJobDefinition Set Job Retries By Job Definition Id

Sets the number of retries of all **failed** jobs associated with the given job
definition id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the job definition to be updated.
	@return ApiSetJobRetriesJobDefinitionRequest
*/
func (a *JobDefinitionAPIService) SetJobRetriesJobDefinition(ctx context.Context, id string) ApiSetJobRetriesJobDefinitionRequest {
	return ApiSetJobRetriesJobDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *JobDefinitionAPIService) SetJobRetriesJobDefinitionExecute(r ApiSetJobRetriesJobDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.SetJobRetriesJobDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/{id}/retries"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.retriesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSuspensionStateJobDefinitionRequest struct {
	ctx                             context.Context
	ApiService                      *JobDefinitionAPIService
	id                              string
	jobDefinitionSuspensionStateDto *JobDefinitionSuspensionStateDto
}

func (r ApiUpdateSuspensionStateJobDefinitionRequest) JobDefinitionSuspensionStateDto(jobDefinitionSuspensionStateDto JobDefinitionSuspensionStateDto) ApiUpdateSuspensionStateJobDefinitionRequest {
	r.jobDefinitionSuspensionStateDto = &jobDefinitionSuspensionStateDto
	return r
}

func (r ApiUpdateSuspensionStateJobDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSuspensionStateJobDefinitionExecute(r)
}

/*
UpdateSuspensionStateJobDefinition Activate/Suspend Job Definition By Id

Activates or suspends a given job definition by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the job definition to activate or suspend.
	@return ApiUpdateSuspensionStateJobDefinitionRequest
*/
func (a *JobDefinitionAPIService) UpdateSuspensionStateJobDefinition(ctx context.Context, id string) ApiUpdateSuspensionStateJobDefinitionRequest {
	return ApiUpdateSuspensionStateJobDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *JobDefinitionAPIService) UpdateSuspensionStateJobDefinitionExecute(r ApiUpdateSuspensionStateJobDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.UpdateSuspensionStateJobDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/{id}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDefinitionSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSuspensionStateJobDefinitionsRequest struct {
	ctx                              context.Context
	ApiService                       *JobDefinitionAPIService
	jobDefinitionsSuspensionStateDto *JobDefinitionsSuspensionStateDto
}

func (r ApiUpdateSuspensionStateJobDefinitionsRequest) JobDefinitionsSuspensionStateDto(jobDefinitionsSuspensionStateDto JobDefinitionsSuspensionStateDto) ApiUpdateSuspensionStateJobDefinitionsRequest {
	r.jobDefinitionsSuspensionStateDto = &jobDefinitionsSuspensionStateDto
	return r
}

func (r ApiUpdateSuspensionStateJobDefinitionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSuspensionStateJobDefinitionsExecute(r)
}

/*
UpdateSuspensionStateJobDefinitions Activate/Suspend Job Definitions

Activates or suspends job definitions with the given process definition id or process definition key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateSuspensionStateJobDefinitionsRequest
*/
func (a *JobDefinitionAPIService) UpdateSuspensionStateJobDefinitions(ctx context.Context) ApiUpdateSuspensionStateJobDefinitionsRequest {
	return ApiUpdateSuspensionStateJobDefinitionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *JobDefinitionAPIService) UpdateSuspensionStateJobDefinitionsExecute(r ApiUpdateSuspensionStateJobDefinitionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobDefinitionAPIService.UpdateSuspensionStateJobDefinitions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job-definition/suspended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobDefinitionsSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
