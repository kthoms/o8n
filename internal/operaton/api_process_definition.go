/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
)


// ProcessDefinitionAPIService ProcessDefinitionAPI service
type ProcessDefinitionAPIService service

type ApiDeleteProcessDefinitionRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	cascade *bool
	skipCustomListeners *bool
	skipIoMappings *bool
}

// &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
func (r ApiDeleteProcessDefinitionRequest) Cascade(cascade bool) ApiDeleteProcessDefinitionRequest {
	r.cascade = &cascade
	return r
}

// &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
func (r ApiDeleteProcessDefinitionRequest) SkipCustomListeners(skipCustomListeners bool) ApiDeleteProcessDefinitionRequest {
	r.skipCustomListeners = &skipCustomListeners
	return r
}

// A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
func (r ApiDeleteProcessDefinitionRequest) SkipIoMappings(skipIoMappings bool) ApiDeleteProcessDefinitionRequest {
	r.skipIoMappings = &skipIoMappings
	return r
}

func (r ApiDeleteProcessDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProcessDefinitionExecute(r)
}

/*
DeleteProcessDefinition Delete

Deletes a process definition by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to be deleted.
 @return ApiDeleteProcessDefinitionRequest
*/
func (a *ProcessDefinitionAPIService) DeleteProcessDefinition(ctx context.Context, id string) ApiDeleteProcessDefinitionRequest {
	return ApiDeleteProcessDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) DeleteProcessDefinitionExecute(r ApiDeleteProcessDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.DeleteProcessDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	if r.skipCustomListeners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCustomListeners", r.skipCustomListeners, "")
	} else {
		var defaultValue bool = false
		r.skipCustomListeners = &defaultValue
	}
	if r.skipIoMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipIoMappings", r.skipIoMappings, "")
	} else {
		var defaultValue bool = false
		r.skipIoMappings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProcessDefinitionsByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	cascade *bool
	skipCustomListeners *bool
	skipIoMappings *bool
}

// &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
func (r ApiDeleteProcessDefinitionsByKeyRequest) Cascade(cascade bool) ApiDeleteProcessDefinitionsByKeyRequest {
	r.cascade = &cascade
	return r
}

// &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
func (r ApiDeleteProcessDefinitionsByKeyRequest) SkipCustomListeners(skipCustomListeners bool) ApiDeleteProcessDefinitionsByKeyRequest {
	r.skipCustomListeners = &skipCustomListeners
	return r
}

// A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
func (r ApiDeleteProcessDefinitionsByKeyRequest) SkipIoMappings(skipIoMappings bool) ApiDeleteProcessDefinitionsByKeyRequest {
	r.skipIoMappings = &skipIoMappings
	return r
}

func (r ApiDeleteProcessDefinitionsByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProcessDefinitionsByKeyExecute(r)
}

/*
DeleteProcessDefinitionsByKey Delete By Key

Deletes process definitions by a given key which belong to no tenant id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definitions to be deleted.
 @return ApiDeleteProcessDefinitionsByKeyRequest
*/
func (a *ProcessDefinitionAPIService) DeleteProcessDefinitionsByKey(ctx context.Context, key string) ApiDeleteProcessDefinitionsByKeyRequest {
	return ApiDeleteProcessDefinitionsByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) DeleteProcessDefinitionsByKeyExecute(r ApiDeleteProcessDefinitionsByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.DeleteProcessDefinitionsByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	if r.skipCustomListeners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCustomListeners", r.skipCustomListeners, "")
	} else {
		var defaultValue bool = false
		r.skipCustomListeners = &defaultValue
	}
	if r.skipIoMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipIoMappings", r.skipIoMappings, "")
	} else {
		var defaultValue bool = false
		r.skipIoMappings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	cascade *bool
	skipCustomListeners *bool
	skipIoMappings *bool
}

// &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
func (r ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest) Cascade(cascade bool) ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest {
	r.cascade = &cascade
	return r
}

// &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
func (r ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest) SkipCustomListeners(skipCustomListeners bool) ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest {
	r.skipCustomListeners = &skipCustomListeners
	return r
}

// A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
func (r ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest) SkipIoMappings(skipIoMappings bool) ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest {
	r.skipIoMappings = &skipIoMappings
	return r
}

func (r ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProcessDefinitionsByKeyAndTenantIdExecute(r)
}

/*
DeleteProcessDefinitionsByKeyAndTenantId Delete By Key

Deletes process definitions by a given key and which belong to a tenant id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definitions to be deleted.
 @param tenantId The id of the tenant the process definitions belong to.
 @return ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) DeleteProcessDefinitionsByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest {
	return ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) DeleteProcessDefinitionsByKeyAndTenantIdExecute(r ApiDeleteProcessDefinitionsByKeyAndTenantIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.DeleteProcessDefinitionsByKeyAndTenantId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	if r.skipCustomListeners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCustomListeners", r.skipCustomListeners, "")
	} else {
		var defaultValue bool = false
		r.skipCustomListeners = &defaultValue
	}
	if r.skipIoMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipIoMappings", r.skipIoMappings, "")
	} else {
		var defaultValue bool = false
		r.skipIoMappings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActivityStatisticsRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	failedJobs *bool
	incidents *bool
	incidentsForType *string
}

// Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiGetActivityStatisticsRequest) FailedJobs(failedJobs bool) ApiGetActivityStatisticsRequest {
	r.failedJobs = &failedJobs
	return r
}

// Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
func (r ApiGetActivityStatisticsRequest) Incidents(incidents bool) ApiGetActivityStatisticsRequest {
	r.incidents = &incidents
	return r
}

// If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetActivityStatisticsRequest) IncidentsForType(incidentsForType string) ApiGetActivityStatisticsRequest {
	r.incidentsForType = &incidentsForType
	return r
}

func (r ApiGetActivityStatisticsRequest) Execute() ([]ActivityStatisticsResultDto, *http.Response, error) {
	return r.ApiService.GetActivityStatisticsExecute(r)
}

/*
GetActivityStatistics Get Activity Instance Statistics

Retrieves runtime statistics of a given process definition, grouped by activities.
These statistics include the number of running activity instances, optionally the number of failed jobs
and also optionally the number of incidents either grouped by incident types or for a specific incident type.
**Note**: This does not include historic data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition.
 @return ApiGetActivityStatisticsRequest
*/
func (a *ProcessDefinitionAPIService) GetActivityStatistics(ctx context.Context, id string) ApiGetActivityStatisticsRequest {
	return ApiGetActivityStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ActivityStatisticsResultDto
func (a *ProcessDefinitionAPIService) GetActivityStatisticsExecute(r ApiGetActivityStatisticsRequest) ([]ActivityStatisticsResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActivityStatisticsResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetActivityStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.failedJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedJobs", r.failedJobs, "")
	}
	if r.incidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidents", r.incidents, "")
	}
	if r.incidentsForType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentsForType", r.incidentsForType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityStatisticsByProcessDefinitionKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	failedJobs *bool
	incidents *bool
	incidentsForType *string
}

// Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyRequest) FailedJobs(failedJobs bool) ApiGetActivityStatisticsByProcessDefinitionKeyRequest {
	r.failedJobs = &failedJobs
	return r
}

// Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyRequest) Incidents(incidents bool) ApiGetActivityStatisticsByProcessDefinitionKeyRequest {
	r.incidents = &incidents
	return r
}

// If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyRequest) IncidentsForType(incidentsForType string) ApiGetActivityStatisticsByProcessDefinitionKeyRequest {
	r.incidentsForType = &incidentsForType
	return r
}

func (r ApiGetActivityStatisticsByProcessDefinitionKeyRequest) Execute() ([]ActivityStatisticsResultDto, *http.Response, error) {
	return r.ApiService.GetActivityStatisticsByProcessDefinitionKeyExecute(r)
}

/*
GetActivityStatisticsByProcessDefinitionKey Get Activity Instance Statistics

Retrieves runtime statistics of the latest version of the given process definition
which belongs to no tenant, grouped by activities.
These statistics include the number of running activity instances, optionally the number of failed jobs
and also optionally the number of incidents either grouped by incident types or
for a specific incident type.
**Note**: This does not include historic data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiGetActivityStatisticsByProcessDefinitionKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetActivityStatisticsByProcessDefinitionKey(ctx context.Context, key string) ApiGetActivityStatisticsByProcessDefinitionKeyRequest {
	return ApiGetActivityStatisticsByProcessDefinitionKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return []ActivityStatisticsResultDto
func (a *ProcessDefinitionAPIService) GetActivityStatisticsByProcessDefinitionKeyExecute(r ApiGetActivityStatisticsByProcessDefinitionKeyRequest) ([]ActivityStatisticsResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActivityStatisticsResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetActivityStatisticsByProcessDefinitionKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.failedJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedJobs", r.failedJobs, "")
	}
	if r.incidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidents", r.incidents, "")
	}
	if r.incidentsForType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentsForType", r.incidentsForType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	failedJobs *bool
	incidents *bool
	incidentsForType *string
}

// Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest) FailedJobs(failedJobs bool) ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest {
	r.failedJobs = &failedJobs
	return r
}

// Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest) Incidents(incidents bool) ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest {
	r.incidents = &incidents
	return r
}

// If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest) IncidentsForType(incidentsForType string) ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest {
	r.incidentsForType = &incidentsForType
	return r
}

func (r ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest) Execute() ([]ActivityStatisticsResultDto, *http.Response, error) {
	return r.ApiService.GetActivityStatisticsByProcessDefinitionKeyAndTenantIdExecute(r)
}

/*
GetActivityStatisticsByProcessDefinitionKeyAndTenantId Get Activity Instance Statistics

Retrieves runtime statistics of the latest version of the given process definition for a tenant,
grouped by activities.
These statistics include the number of running activity instances, optionally the number of failed jobs
and also optionally the number of incidents either grouped by incident types or
for a specific incident type.
**Note**: This does not include historic data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetActivityStatisticsByProcessDefinitionKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest {
	return ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return []ActivityStatisticsResultDto
func (a *ProcessDefinitionAPIService) GetActivityStatisticsByProcessDefinitionKeyAndTenantIdExecute(r ApiGetActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest) ([]ActivityStatisticsResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActivityStatisticsResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetActivityStatisticsByProcessDefinitionKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.failedJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedJobs", r.failedJobs, "")
	}
	if r.incidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidents", r.incidents, "")
	}
	if r.incidentsForType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentsForType", r.incidentsForType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeployedStartFormRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetDeployedStartFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeployedStartFormExecute(r)
}

/*
GetDeployedStartForm Get Deployed Start Form

Retrieves the deployed form that can be referenced from a start event.
For further information please refer to [User Guide](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#embedded-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to get the deployed start form for.
 @return ApiGetDeployedStartFormRequest
*/
func (a *ProcessDefinitionAPIService) GetDeployedStartForm(ctx context.Context, id string) ApiGetDeployedStartFormRequest {
	return ApiGetDeployedStartFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetDeployedStartFormExecute(r ApiGetDeployedStartFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetDeployedStartForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/deployed-start-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeployedStartFormByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetDeployedStartFormByKeyRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeployedStartFormByKeyExecute(r)
}

/*
GetDeployedStartFormByKey Get Deployed Start Form

Retrieves the deployed form that can be referenced from a start event.
For further information please refer to [User Guide](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#embedded-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiGetDeployedStartFormByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetDeployedStartFormByKey(ctx context.Context, key string) ApiGetDeployedStartFormByKeyRequest {
	return ApiGetDeployedStartFormByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetDeployedStartFormByKeyExecute(r ApiGetDeployedStartFormByKeyRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetDeployedStartFormByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/deployed-start-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeployedStartFormByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetDeployedStartFormByKeyAndTenantIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeployedStartFormByKeyAndTenantIdExecute(r)
}

/*
GetDeployedStartFormByKeyAndTenantId Get Deployed Start Form

Retrieves the deployed form that can be referenced from a start event.
For further information please refer to [User Guide](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#embedded-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definitions belong to.
 @return ApiGetDeployedStartFormByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetDeployedStartFormByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetDeployedStartFormByKeyAndTenantIdRequest {
	return ApiGetDeployedStartFormByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetDeployedStartFormByKeyAndTenantIdExecute(r ApiGetDeployedStartFormByKeyAndTenantIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetDeployedStartFormByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/deployed-start-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestProcessDefinitionByTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetLatestProcessDefinitionByTenantIdRequest) Execute() (*ProcessDefinitionDto, *http.Response, error) {
	return r.ApiService.GetLatestProcessDefinitionByTenantIdExecute(r)
}

/*
GetLatestProcessDefinitionByTenantId Get

Retrieves the latest version of the process definition for tenant according to
the `ProcessDefinition` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetLatestProcessDefinitionByTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetLatestProcessDefinitionByTenantId(ctx context.Context, key string, tenantId string) ApiGetLatestProcessDefinitionByTenantIdRequest {
	return ApiGetLatestProcessDefinitionByTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDto
func (a *ProcessDefinitionAPIService) GetLatestProcessDefinitionByTenantIdExecute(r ApiGetLatestProcessDefinitionByTenantIdRequest) (*ProcessDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetLatestProcessDefinitionByTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetProcessDefinitionRequest) Execute() (*ProcessDefinitionDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionExecute(r)
}

/*
GetProcessDefinition Get

Retrieves a process definition according to the `ProcessDefinition` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to be retrieved.
 @return ApiGetProcessDefinitionRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinition(ctx context.Context, id string) ApiGetProcessDefinitionRequest {
	return ApiGetProcessDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionExecute(r ApiGetProcessDefinitionRequest) (*ProcessDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionBpmn20XmlRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetProcessDefinitionBpmn20XmlRequest) Execute() (*ProcessDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionBpmn20XmlExecute(r)
}

/*
GetProcessDefinitionBpmn20Xml Get XML

Retrieves the BPMN 2.0 XML of a process definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition.
 @return ApiGetProcessDefinitionBpmn20XmlRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20Xml(ctx context.Context, id string) ApiGetProcessDefinitionBpmn20XmlRequest {
	return ApiGetProcessDefinitionBpmn20XmlRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDiagramDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20XmlExecute(r ApiGetProcessDefinitionBpmn20XmlRequest) (*ProcessDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionBpmn20Xml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionBpmn20XmlByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetProcessDefinitionBpmn20XmlByKeyRequest) Execute() (*ProcessDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionBpmn20XmlByKeyExecute(r)
}

/*
GetProcessDefinitionBpmn20XmlByKey Get XML

Retrieves latest version the BPMN 2.0 XML of a process definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) whose XML should be retrieved.
 @return ApiGetProcessDefinitionBpmn20XmlByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20XmlByKey(ctx context.Context, key string) ApiGetProcessDefinitionBpmn20XmlByKeyRequest {
	return ApiGetProcessDefinitionBpmn20XmlByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDiagramDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20XmlByKeyExecute(r ApiGetProcessDefinitionBpmn20XmlByKeyRequest) (*ProcessDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionBpmn20XmlByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest) Execute() (*ProcessDefinitionDiagramDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionBpmn20XmlByKeyAndTenantIdExecute(r)
}

/*
GetProcessDefinitionBpmn20XmlByKeyAndTenantId Get XML

Retrieves latest version the BPMN 2.0 XML of a process definition.
Returns the XML for the latest version of the process definition for tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) whose XML should be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20XmlByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest {
	return ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDiagramDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionBpmn20XmlByKeyAndTenantIdExecute(r ApiGetProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest) (*ProcessDefinitionDiagramDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDiagramDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionBpmn20XmlByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetProcessDefinitionByKeyRequest) Execute() (*ProcessDefinitionDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionByKeyExecute(r)
}

/*
GetProcessDefinitionByKey Get

Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiGetProcessDefinitionByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionByKey(ctx context.Context, key string) ApiGetProcessDefinitionByKeyRequest {
	return ApiGetProcessDefinitionByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return ProcessDefinitionDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionByKeyExecute(r ApiGetProcessDefinitionByKeyRequest) (*ProcessDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionDiagramRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetProcessDefinitionDiagramRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionDiagramExecute(r)
}

/*
GetProcessDefinitionDiagram Get Diagram

Retrieves the diagram of a process definition.

If the process definition's deployment contains an image resource with the same file name
as the process definition, the deployed image will be returned by the Get Diagram endpoint.
Example: `someProcess.bpmn` and `someProcess.png`.
Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition.
 @return ApiGetProcessDefinitionDiagramRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagram(ctx context.Context, id string) ApiGetProcessDefinitionDiagramRequest {
	return ApiGetProcessDefinitionDiagramRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagramExecute(r ApiGetProcessDefinitionDiagramRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionDiagram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionDiagramByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetProcessDefinitionDiagramByKeyRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionDiagramByKeyExecute(r)
}

/*
GetProcessDefinitionDiagramByKey Get Diagram

Retrieves the diagram for the latest version of the process definition which belongs to no tenant.

If the process definition's deployment contains an image resource with the same file name
as the process definition, the deployed image will be returned by the Get Diagram endpoint.
Example: `someProcess.bpmn` and `someProcess.png`.
Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition.
 @return ApiGetProcessDefinitionDiagramByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagramByKey(ctx context.Context, key string) ApiGetProcessDefinitionDiagramByKeyRequest {
	return ApiGetProcessDefinitionDiagramByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagramByKeyExecute(r ApiGetProcessDefinitionDiagramByKeyRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionDiagramByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionDiagramByKeyAndTenantIdExecute(r)
}

/*
GetProcessDefinitionDiagramByKeyAndTenantId Get Diagram

Retrieves the diagram for the latest version of the process definition for tenant.

If the process definition's deployment contains an image resource with the same file name
as the process definition, the deployed image will be returned by the Get Diagram endpoint.
Example: `someProcess.bpmn` and `someProcess.png`.
Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagramByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest {
	return ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetProcessDefinitionDiagramByKeyAndTenantIdExecute(r ApiGetProcessDefinitionDiagramByKeyAndTenantIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionDiagramByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionStatisticsRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	failedJobs *bool
	incidents *bool
	incidentsForType *string
	rootIncidents *bool
}

// Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiGetProcessDefinitionStatisticsRequest) FailedJobs(failedJobs bool) ApiGetProcessDefinitionStatisticsRequest {
	r.failedJobs = &failedJobs
	return r
}

// Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
func (r ApiGetProcessDefinitionStatisticsRequest) Incidents(incidents bool) ApiGetProcessDefinitionStatisticsRequest {
	r.incidents = &incidents
	return r
}

// If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetProcessDefinitionStatisticsRequest) IncidentsForType(incidentsForType string) ApiGetProcessDefinitionStatisticsRequest {
	r.incidentsForType = &incidentsForType
	return r
}

// Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
func (r ApiGetProcessDefinitionStatisticsRequest) RootIncidents(rootIncidents bool) ApiGetProcessDefinitionStatisticsRequest {
	r.rootIncidents = &rootIncidents
	return r
}

func (r ApiGetProcessDefinitionStatisticsRequest) Execute() ([]ProcessDefinitionStatisticsResultDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionStatisticsExecute(r)
}

/*
GetProcessDefinitionStatistics Get Process Instance Statistics

Retrieves runtime statistics of the process engine, grouped by process definitions.
These statistics include the number of running process instances, optionally the number of failed jobs
and also optionally the number of incidents either grouped by incident types or
for a specific incident type.
**Note**: This does not include historic data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcessDefinitionStatisticsRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionStatistics(ctx context.Context) ApiGetProcessDefinitionStatisticsRequest {
	return ApiGetProcessDefinitionStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ProcessDefinitionStatisticsResultDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionStatisticsExecute(r ApiGetProcessDefinitionStatisticsRequest) ([]ProcessDefinitionStatisticsResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProcessDefinitionStatisticsResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.failedJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedJobs", r.failedJobs, "")
	}
	if r.incidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidents", r.incidents, "")
	}
	if r.incidentsForType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentsForType", r.incidentsForType, "")
	}
	if r.rootIncidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootIncidents", r.rootIncidents, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionsRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	processDefinitionId *string
	processDefinitionIdIn *string
	name *string
	nameLike *string
	deploymentId *string
	deployedAfter *time.Time
	deployedAt *time.Time
	key *string
	keysIn *string
	keyLike *string
	category *string
	categoryLike *string
	version *int32
	latestVersion *bool
	resourceName *string
	resourceNameLike *string
	startableBy *string
	active *bool
	suspended *bool
	incidentId *string
	incidentType *string
	incidentMessage *string
	incidentMessageLike *string
	tenantIdIn *string
	withoutTenantId *bool
	includeProcessDefinitionsWithoutTenantId *bool
	versionTag *string
	versionTagLike *string
	withoutVersionTag *bool
	startableInTasklist *bool
	notStartableInTasklist *bool
	startablePermissionCheck *bool
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by process definition id.
func (r ApiGetProcessDefinitionsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetProcessDefinitionsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a comma-separated list of process definition ids.
func (r ApiGetProcessDefinitionsRequest) ProcessDefinitionIdIn(processDefinitionIdIn string) ApiGetProcessDefinitionsRequest {
	r.processDefinitionIdIn = &processDefinitionIdIn
	return r
}

// Filter by process definition name.
func (r ApiGetProcessDefinitionsRequest) Name(name string) ApiGetProcessDefinitionsRequest {
	r.name = &name
	return r
}

// Filter by process definition names that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) NameLike(nameLike string) ApiGetProcessDefinitionsRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment the id belongs to.
func (r ApiGetProcessDefinitionsRequest) DeploymentId(deploymentId string) ApiGetProcessDefinitionsRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetProcessDefinitionsRequest) DeployedAfter(deployedAfter time.Time) ApiGetProcessDefinitionsRequest {
	r.deployedAfter = &deployedAfter
	return r
}

// Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetProcessDefinitionsRequest) DeployedAt(deployedAt time.Time) ApiGetProcessDefinitionsRequest {
	r.deployedAt = &deployedAt
	return r
}

// Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
func (r ApiGetProcessDefinitionsRequest) Key(key string) ApiGetProcessDefinitionsRequest {
	r.key = &key
	return r
}

// Filter by a comma-separated list of process definition keys.
func (r ApiGetProcessDefinitionsRequest) KeysIn(keysIn string) ApiGetProcessDefinitionsRequest {
	r.keysIn = &keysIn
	return r
}

// Filter by process definition keys that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) KeyLike(keyLike string) ApiGetProcessDefinitionsRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by process definition category. Exact match.
func (r ApiGetProcessDefinitionsRequest) Category(category string) ApiGetProcessDefinitionsRequest {
	r.category = &category
	return r
}

// Filter by process definition categories that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) CategoryLike(categoryLike string) ApiGetProcessDefinitionsRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by process definition version.
func (r ApiGetProcessDefinitionsRequest) Version(version int32) ApiGetProcessDefinitionsRequest {
	r.version = &version
	return r
}

// Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsRequest) LatestVersion(latestVersion bool) ApiGetProcessDefinitionsRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the process definition resource. Exact match.
func (r ApiGetProcessDefinitionsRequest) ResourceName(resourceName string) ApiGetProcessDefinitionsRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those process definition resources that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) ResourceNameLike(resourceNameLike string) ApiGetProcessDefinitionsRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by a user name who is allowed to start the process.
func (r ApiGetProcessDefinitionsRequest) StartableBy(startableBy string) ApiGetProcessDefinitionsRequest {
	r.startableBy = &startableBy
	return r
}

// Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsRequest) Active(active bool) ApiGetProcessDefinitionsRequest {
	r.active = &active
	return r
}

// Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsRequest) Suspended(suspended bool) ApiGetProcessDefinitionsRequest {
	r.suspended = &suspended
	return r
}

// Filter by the incident id.
func (r ApiGetProcessDefinitionsRequest) IncidentId(incidentId string) ApiGetProcessDefinitionsRequest {
	r.incidentId = &incidentId
	return r
}

// Filter by the incident type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetProcessDefinitionsRequest) IncidentType(incidentType string) ApiGetProcessDefinitionsRequest {
	r.incidentType = &incidentType
	return r
}

// Filter by the incident message. Exact match.
func (r ApiGetProcessDefinitionsRequest) IncidentMessage(incidentMessage string) ApiGetProcessDefinitionsRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Filter by the incident message that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) IncidentMessageLike(incidentMessageLike string) ApiGetProcessDefinitionsRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
func (r ApiGetProcessDefinitionsRequest) TenantIdIn(tenantIdIn string) ApiGetProcessDefinitionsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
func (r ApiGetProcessDefinitionsRequest) WithoutTenantId(withoutTenantId bool) ApiGetProcessDefinitionsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsRequest) IncludeProcessDefinitionsWithoutTenantId(includeProcessDefinitionsWithoutTenantId bool) ApiGetProcessDefinitionsRequest {
	r.includeProcessDefinitionsWithoutTenantId = &includeProcessDefinitionsWithoutTenantId
	return r
}

// Filter by the version tag.
func (r ApiGetProcessDefinitionsRequest) VersionTag(versionTag string) ApiGetProcessDefinitionsRequest {
	r.versionTag = &versionTag
	return r
}

// Filter by the version tag that the parameter is a substring of.
func (r ApiGetProcessDefinitionsRequest) VersionTagLike(versionTagLike string) ApiGetProcessDefinitionsRequest {
	r.versionTagLike = &versionTagLike
	return r
}

// Only include process definitions without a &#x60;versionTag&#x60;.
func (r ApiGetProcessDefinitionsRequest) WithoutVersionTag(withoutVersionTag bool) ApiGetProcessDefinitionsRequest {
	r.withoutVersionTag = &withoutVersionTag
	return r
}

// Filter by process definitions which are startable in Tasklist..
func (r ApiGetProcessDefinitionsRequest) StartableInTasklist(startableInTasklist bool) ApiGetProcessDefinitionsRequest {
	r.startableInTasklist = &startableInTasklist
	return r
}

// Filter by process definitions which are not startable in Tasklist.
func (r ApiGetProcessDefinitionsRequest) NotStartableInTasklist(notStartableInTasklist bool) ApiGetProcessDefinitionsRequest {
	r.notStartableInTasklist = &notStartableInTasklist
	return r
}

// Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
func (r ApiGetProcessDefinitionsRequest) StartablePermissionCheck(startablePermissionCheck bool) ApiGetProcessDefinitionsRequest {
	r.startablePermissionCheck = &startablePermissionCheck
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetProcessDefinitionsRequest) SortBy(sortBy string) ApiGetProcessDefinitionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetProcessDefinitionsRequest) SortOrder(sortOrder string) ApiGetProcessDefinitionsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetProcessDefinitionsRequest) FirstResult(firstResult int32) ApiGetProcessDefinitionsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetProcessDefinitionsRequest) MaxResults(maxResults int32) ApiGetProcessDefinitionsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetProcessDefinitionsRequest) Execute() ([]ProcessDefinitionDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionsExecute(r)
}

/*
GetProcessDefinitions Get List

Queries for process definitions that fulfill given parameters. Parameters may be the properties of 
process definitions, such as the name, key or version. The size of the result set can be retrieved
by using the [Get Definition Count](https://docs.operaton.org/manual/1.0/reference/rest/process-definition/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcessDefinitionsRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitions(ctx context.Context) ApiGetProcessDefinitionsRequest {
	return ApiGetProcessDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ProcessDefinitionDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionsExecute(r ApiGetProcessDefinitionsRequest) ([]ProcessDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProcessDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionIdIn", r.processDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.deployedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAfter", r.deployedAfter, "")
	}
	if r.deployedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAt", r.deployedAt, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keysIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keysIn", r.keysIn, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.startableBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startableBy", r.startableBy, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeProcessDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProcessDefinitionsWithoutTenantId", r.includeProcessDefinitionsWithoutTenantId, "")
	}
	if r.versionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTag", r.versionTag, "")
	}
	if r.versionTagLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTagLike", r.versionTagLike, "")
	}
	if r.withoutVersionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutVersionTag", r.withoutVersionTag, "")
	}
	if r.startableInTasklist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startableInTasklist", r.startableInTasklist, "")
	}
	if r.notStartableInTasklist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notStartableInTasklist", r.notStartableInTasklist, "")
	}
	if r.startablePermissionCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startablePermissionCheck", r.startablePermissionCheck, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcessDefinitionsCountRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	processDefinitionId *string
	processDefinitionIdIn *string
	name *string
	nameLike *string
	deploymentId *string
	deployedAfter *time.Time
	deployedAt *time.Time
	key *string
	keysIn *string
	keyLike *string
	category *string
	categoryLike *string
	version *int32
	latestVersion *bool
	resourceName *string
	resourceNameLike *string
	startableBy *string
	active *bool
	suspended *bool
	incidentId *string
	incidentType *string
	incidentMessage *string
	incidentMessageLike *string
	tenantIdIn *string
	withoutTenantId *bool
	includeProcessDefinitionsWithoutTenantId *bool
	versionTag *string
	versionTagLike *string
	withoutVersionTag *bool
	startableInTasklist *bool
	notStartableInTasklist *bool
	startablePermissionCheck *bool
}

// Filter by process definition id.
func (r ApiGetProcessDefinitionsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetProcessDefinitionsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Filter by a comma-separated list of process definition ids.
func (r ApiGetProcessDefinitionsCountRequest) ProcessDefinitionIdIn(processDefinitionIdIn string) ApiGetProcessDefinitionsCountRequest {
	r.processDefinitionIdIn = &processDefinitionIdIn
	return r
}

// Filter by process definition name.
func (r ApiGetProcessDefinitionsCountRequest) Name(name string) ApiGetProcessDefinitionsCountRequest {
	r.name = &name
	return r
}

// Filter by process definition names that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) NameLike(nameLike string) ApiGetProcessDefinitionsCountRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment the id belongs to.
func (r ApiGetProcessDefinitionsCountRequest) DeploymentId(deploymentId string) ApiGetProcessDefinitionsCountRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetProcessDefinitionsCountRequest) DeployedAfter(deployedAfter time.Time) ApiGetProcessDefinitionsCountRequest {
	r.deployedAfter = &deployedAfter
	return r
}

// Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetProcessDefinitionsCountRequest) DeployedAt(deployedAt time.Time) ApiGetProcessDefinitionsCountRequest {
	r.deployedAt = &deployedAt
	return r
}

// Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
func (r ApiGetProcessDefinitionsCountRequest) Key(key string) ApiGetProcessDefinitionsCountRequest {
	r.key = &key
	return r
}

// Filter by a comma-separated list of process definition keys.
func (r ApiGetProcessDefinitionsCountRequest) KeysIn(keysIn string) ApiGetProcessDefinitionsCountRequest {
	r.keysIn = &keysIn
	return r
}

// Filter by process definition keys that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) KeyLike(keyLike string) ApiGetProcessDefinitionsCountRequest {
	r.keyLike = &keyLike
	return r
}

// Filter by process definition category. Exact match.
func (r ApiGetProcessDefinitionsCountRequest) Category(category string) ApiGetProcessDefinitionsCountRequest {
	r.category = &category
	return r
}

// Filter by process definition categories that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) CategoryLike(categoryLike string) ApiGetProcessDefinitionsCountRequest {
	r.categoryLike = &categoryLike
	return r
}

// Filter by process definition version.
func (r ApiGetProcessDefinitionsCountRequest) Version(version int32) ApiGetProcessDefinitionsCountRequest {
	r.version = &version
	return r
}

// Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsCountRequest) LatestVersion(latestVersion bool) ApiGetProcessDefinitionsCountRequest {
	r.latestVersion = &latestVersion
	return r
}

// Filter by the name of the process definition resource. Exact match.
func (r ApiGetProcessDefinitionsCountRequest) ResourceName(resourceName string) ApiGetProcessDefinitionsCountRequest {
	r.resourceName = &resourceName
	return r
}

// Filter by names of those process definition resources that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) ResourceNameLike(resourceNameLike string) ApiGetProcessDefinitionsCountRequest {
	r.resourceNameLike = &resourceNameLike
	return r
}

// Filter by a user name who is allowed to start the process.
func (r ApiGetProcessDefinitionsCountRequest) StartableBy(startableBy string) ApiGetProcessDefinitionsCountRequest {
	r.startableBy = &startableBy
	return r
}

// Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsCountRequest) Active(active bool) ApiGetProcessDefinitionsCountRequest {
	r.active = &active
	return r
}

// Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsCountRequest) Suspended(suspended bool) ApiGetProcessDefinitionsCountRequest {
	r.suspended = &suspended
	return r
}

// Filter by the incident id.
func (r ApiGetProcessDefinitionsCountRequest) IncidentId(incidentId string) ApiGetProcessDefinitionsCountRequest {
	r.incidentId = &incidentId
	return r
}

// Filter by the incident type. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetProcessDefinitionsCountRequest) IncidentType(incidentType string) ApiGetProcessDefinitionsCountRequest {
	r.incidentType = &incidentType
	return r
}

// Filter by the incident message. Exact match.
func (r ApiGetProcessDefinitionsCountRequest) IncidentMessage(incidentMessage string) ApiGetProcessDefinitionsCountRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Filter by the incident message that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) IncidentMessageLike(incidentMessageLike string) ApiGetProcessDefinitionsCountRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
func (r ApiGetProcessDefinitionsCountRequest) TenantIdIn(tenantIdIn string) ApiGetProcessDefinitionsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
func (r ApiGetProcessDefinitionsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetProcessDefinitionsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetProcessDefinitionsCountRequest) IncludeProcessDefinitionsWithoutTenantId(includeProcessDefinitionsWithoutTenantId bool) ApiGetProcessDefinitionsCountRequest {
	r.includeProcessDefinitionsWithoutTenantId = &includeProcessDefinitionsWithoutTenantId
	return r
}

// Filter by the version tag.
func (r ApiGetProcessDefinitionsCountRequest) VersionTag(versionTag string) ApiGetProcessDefinitionsCountRequest {
	r.versionTag = &versionTag
	return r
}

// Filter by the version tag that the parameter is a substring of.
func (r ApiGetProcessDefinitionsCountRequest) VersionTagLike(versionTagLike string) ApiGetProcessDefinitionsCountRequest {
	r.versionTagLike = &versionTagLike
	return r
}

// Only include process definitions without a &#x60;versionTag&#x60;.
func (r ApiGetProcessDefinitionsCountRequest) WithoutVersionTag(withoutVersionTag bool) ApiGetProcessDefinitionsCountRequest {
	r.withoutVersionTag = &withoutVersionTag
	return r
}

// Filter by process definitions which are startable in Tasklist..
func (r ApiGetProcessDefinitionsCountRequest) StartableInTasklist(startableInTasklist bool) ApiGetProcessDefinitionsCountRequest {
	r.startableInTasklist = &startableInTasklist
	return r
}

// Filter by process definitions which are not startable in Tasklist.
func (r ApiGetProcessDefinitionsCountRequest) NotStartableInTasklist(notStartableInTasklist bool) ApiGetProcessDefinitionsCountRequest {
	r.notStartableInTasklist = &notStartableInTasklist
	return r
}

// Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
func (r ApiGetProcessDefinitionsCountRequest) StartablePermissionCheck(startablePermissionCheck bool) ApiGetProcessDefinitionsCountRequest {
	r.startablePermissionCheck = &startablePermissionCheck
	return r
}

func (r ApiGetProcessDefinitionsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetProcessDefinitionsCountExecute(r)
}

/*
GetProcessDefinitionsCount Get List Count

Requests the number of process definitions that fulfill the query criteria.
Takes the same filtering parameters as the [Get Definitions](https://docs.operaton.org/manual/1.0/reference/rest/process-definition/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcessDefinitionsCountRequest
*/
func (a *ProcessDefinitionAPIService) GetProcessDefinitionsCount(ctx context.Context) ApiGetProcessDefinitionsCountRequest {
	return ApiGetProcessDefinitionsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *ProcessDefinitionAPIService) GetProcessDefinitionsCountExecute(r ApiGetProcessDefinitionsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetProcessDefinitionsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionIdIn", r.processDefinitionIdIn, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "")
	}
	if r.deployedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAfter", r.deployedAfter, "")
	}
	if r.deployedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployedAt", r.deployedAt, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keysIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keysIn", r.keysIn, "")
	}
	if r.keyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyLike", r.keyLike, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.categoryLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryLike", r.categoryLike, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.latestVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestVersion", r.latestVersion, "")
	}
	if r.resourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceNameLike", r.resourceNameLike, "")
	}
	if r.startableBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startableBy", r.startableBy, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.includeProcessDefinitionsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProcessDefinitionsWithoutTenantId", r.includeProcessDefinitionsWithoutTenantId, "")
	}
	if r.versionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTag", r.versionTag, "")
	}
	if r.versionTagLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionTagLike", r.versionTagLike, "")
	}
	if r.withoutVersionTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutVersionTag", r.withoutVersionTag, "")
	}
	if r.startableInTasklist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startableInTasklist", r.startableInTasklist, "")
	}
	if r.notStartableInTasklist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notStartableInTasklist", r.notStartableInTasklist, "")
	}
	if r.startablePermissionCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startablePermissionCheck", r.startablePermissionCheck, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderedStartFormRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetRenderedStartFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRenderedStartFormExecute(r)
}

/*
GetRenderedStartForm Get Rendered Start Form

Retrieves the rendered form for a process definition.
This method can be used to get the HTML rendering of a
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to get the rendered start form for.
 @return ApiGetRenderedStartFormRequest
*/
func (a *ProcessDefinitionAPIService) GetRenderedStartForm(ctx context.Context, id string) ApiGetRenderedStartFormRequest {
	return ApiGetRenderedStartFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetRenderedStartFormExecute(r ApiGetRenderedStartFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetRenderedStartForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/rendered-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderedStartFormByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetRenderedStartFormByKeyRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRenderedStartFormByKeyExecute(r)
}

/*
GetRenderedStartFormByKey Get Rendered Start Form

Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant.
This method can be used to get the HTML rendering of a
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiGetRenderedStartFormByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetRenderedStartFormByKey(ctx context.Context, key string) ApiGetRenderedStartFormByKeyRequest {
	return ApiGetRenderedStartFormByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetRenderedStartFormByKeyExecute(r ApiGetRenderedStartFormByKeyRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetRenderedStartFormByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/rendered-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderedStartFormByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetRenderedStartFormByKeyAndTenantIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRenderedStartFormByKeyAndTenantIdExecute(r)
}

/*
GetRenderedStartFormByKeyAndTenantId Get Rendered Start Form

Retrieves  the rendered form for the latest version of the process definition for a tenant.
This method can be used to get the HTML rendering of a
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetRenderedStartFormByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetRenderedStartFormByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetRenderedStartFormByKeyAndTenantIdRequest {
	return ApiGetRenderedStartFormByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ProcessDefinitionAPIService) GetRenderedStartFormByKeyAndTenantIdExecute(r ApiGetRenderedStartFormByKeyAndTenantIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetRenderedStartFormByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/rendered-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetStartFormRequest) Execute() (*FormDto, *http.Response, error) {
	return r.ApiService.GetStartFormExecute(r)
}

/*
GetStartForm Get Start Form Key

Retrieves the key of the start form for a process definition.
The form key corresponds to the `FormData#formKey` property in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to get the start form key for.
 @return ApiGetStartFormRequest
*/
func (a *ProcessDefinitionAPIService) GetStartForm(ctx context.Context, id string) ApiGetStartFormRequest {
	return ApiGetStartFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FormDto
func (a *ProcessDefinitionAPIService) GetStartFormExecute(r ApiGetStartFormRequest) (*FormDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/startForm"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
}

func (r ApiGetStartFormByKeyRequest) Execute() (*FormDto, *http.Response, error) {
	return r.ApiService.GetStartFormByKeyExecute(r)
}

/*
GetStartFormByKey Get Start Form Key

Retrieves the key of the start form for the latest version of the process definition
which belongs to no tenant.
The form key corresponds to the `FormData#formKey` property in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
 @return ApiGetStartFormByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetStartFormByKey(ctx context.Context, key string) ApiGetStartFormByKeyRequest {
	return ApiGetStartFormByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return FormDto
func (a *ProcessDefinitionAPIService) GetStartFormByKeyExecute(r ApiGetStartFormByKeyRequest) (*FormDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartFormByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/startForm"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
}

func (r ApiGetStartFormByKeyAndTenantIdRequest) Execute() (*FormDto, *http.Response, error) {
	return r.ApiService.GetStartFormByKeyAndTenantIdExecute(r)
}

/*
GetStartFormByKeyAndTenantId Get Start Form Key

Retrieves the key of the start form for the latest version of the process definition for a tenant.
The form key corresponds to the `FormData#formKey` property in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetStartFormByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetStartFormByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetStartFormByKeyAndTenantIdRequest {
	return ApiGetStartFormByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return FormDto
func (a *ProcessDefinitionAPIService) GetStartFormByKeyAndTenantIdExecute(r ApiGetStartFormByKeyAndTenantIdRequest) (*FormDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartFormByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/startForm"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormVariablesRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	variableNames *string
	deserializeValues *bool
}

// A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
func (r ApiGetStartFormVariablesRequest) VariableNames(variableNames string) ApiGetStartFormVariablesRequest {
	r.variableNames = &variableNames
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetStartFormVariablesRequest) DeserializeValues(deserializeValues bool) ApiGetStartFormVariablesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetStartFormVariablesRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetStartFormVariablesExecute(r)
}

/*
GetStartFormVariables Get Start Form Variables

Retrieves the start form variables for a process definition
(only if they are defined via the 
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms) approach).
The start form variables take form data specified on the start event into account.
If form fields are defined, the variable types and default values
of the form fields are taken into account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to retrieve the variables for.
 @return ApiGetStartFormVariablesRequest
*/
func (a *ProcessDefinitionAPIService) GetStartFormVariables(ctx context.Context, id string) ApiGetStartFormVariablesRequest {
	return ApiGetStartFormVariablesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *ProcessDefinitionAPIService) GetStartFormVariablesExecute(r ApiGetStartFormVariablesRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartFormVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/form-variables"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNames", r.variableNames, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	} else {
		var defaultValue bool = true
		r.deserializeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormVariablesByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	variableNames *string
	deserializeValues *bool
}

// A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
func (r ApiGetStartFormVariablesByKeyRequest) VariableNames(variableNames string) ApiGetStartFormVariablesByKeyRequest {
	r.variableNames = &variableNames
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetStartFormVariablesByKeyRequest) DeserializeValues(deserializeValues bool) ApiGetStartFormVariablesByKeyRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetStartFormVariablesByKeyRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetStartFormVariablesByKeyExecute(r)
}

/*
GetStartFormVariablesByKey Get Start Form Variables

Retrieves the start form variables for the latest process definition which belongs to no tenant
(only if they are defined via the 
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms) approach).
The start form variables take form data specified on the start event into account.
If form fields are defined, the variable types and default values
of the form fields are taken into account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiGetStartFormVariablesByKeyRequest
*/
func (a *ProcessDefinitionAPIService) GetStartFormVariablesByKey(ctx context.Context, key string) ApiGetStartFormVariablesByKeyRequest {
	return ApiGetStartFormVariablesByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *ProcessDefinitionAPIService) GetStartFormVariablesByKeyExecute(r ApiGetStartFormVariablesByKeyRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartFormVariablesByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/form-variables"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNames", r.variableNames, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	} else {
		var defaultValue bool = true
		r.deserializeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStartFormVariablesByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	variableNames *string
	deserializeValues *bool
}

// A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
func (r ApiGetStartFormVariablesByKeyAndTenantIdRequest) VariableNames(variableNames string) ApiGetStartFormVariablesByKeyAndTenantIdRequest {
	r.variableNames = &variableNames
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetStartFormVariablesByKeyAndTenantIdRequest) DeserializeValues(deserializeValues bool) ApiGetStartFormVariablesByKeyAndTenantIdRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetStartFormVariablesByKeyAndTenantIdRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetStartFormVariablesByKeyAndTenantIdExecute(r)
}

/*
GetStartFormVariablesByKeyAndTenantId Get Start Form Variables

Retrieves the start form variables for the latest process definition for a tenant
(only if they are defined via the 
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms) approach).
The start form variables take form data specified on the start event into account.
If form fields are defined, the variable types and default values
of the form fields are taken into account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiGetStartFormVariablesByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) GetStartFormVariablesByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiGetStartFormVariablesByKeyAndTenantIdRequest {
	return ApiGetStartFormVariablesByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *ProcessDefinitionAPIService) GetStartFormVariablesByKeyAndTenantIdExecute(r ApiGetStartFormVariablesByKeyAndTenantIdRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStartFormVariablesByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/form-variables"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNames", r.variableNames, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	} else {
		var defaultValue bool = true
		r.deserializeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStaticCalledProcessDefinitionsRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
}

func (r ApiGetStaticCalledProcessDefinitionsRequest) Execute() ([]CalledProcessDefinitionDto, *http.Response, error) {
	return r.ApiService.GetStaticCalledProcessDefinitionsExecute(r)
}

/*
GetStaticCalledProcessDefinitions Get Static Called Process Definitions

For the given process, returns a list of called process definitions corresponding
to
the `CalledProcessDefinition` interface in the engine. The list
contains all process definitions
that are referenced statically by call activities in the given
process. This endpoint does not
resolve process definitions that are referenced with expressions. Each
called process definition
contains a list of call activity ids, which specifies the call
activities that are calling that
process. This endpoint does not resolve references to case
definitions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition.
 @return ApiGetStaticCalledProcessDefinitionsRequest
*/
func (a *ProcessDefinitionAPIService) GetStaticCalledProcessDefinitions(ctx context.Context, id string) ApiGetStaticCalledProcessDefinitionsRequest {
	return ApiGetStaticCalledProcessDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []CalledProcessDefinitionDto
func (a *ProcessDefinitionAPIService) GetStaticCalledProcessDefinitionsExecute(r ApiGetStaticCalledProcessDefinitionsRequest) ([]CalledProcessDefinitionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CalledProcessDefinitionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.GetStaticCalledProcessDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/static-called-process-definitions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartProcessInstanceRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	restartProcessInstanceDto *RestartProcessInstanceDto
}

func (r ApiRestartProcessInstanceRequest) RestartProcessInstanceDto(restartProcessInstanceDto RestartProcessInstanceDto) ApiRestartProcessInstanceRequest {
	r.restartProcessInstanceDto = &restartProcessInstanceDto
	return r
}

func (r ApiRestartProcessInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestartProcessInstanceExecute(r)
}

/*
RestartProcessInstance Restart Process Instance

Restarts process instances that were canceled or terminated synchronously.
Can also restart completed process instances.
It will create a new instance using the original instance information.
To execute the restart asynchronously, use the
[Restart Process Instance Async](https://docs.operaton.org/manual/1.0/reference/rest/process-definition/post-restart-process-instance-async/) method.

For more information about the difference between synchronous and asynchronous execution,
please refer to the related section of the
[User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/process-instance-restart/#execution).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition of the process instances to restart.
 @return ApiRestartProcessInstanceRequest
*/
func (a *ProcessDefinitionAPIService) RestartProcessInstance(ctx context.Context, id string) ApiRestartProcessInstanceRequest {
	return ApiRestartProcessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) RestartProcessInstanceExecute(r ApiRestartProcessInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.RestartProcessInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartProcessInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRestartProcessInstanceAsyncOperationRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	restartProcessInstanceDto *RestartProcessInstanceDto
}

func (r ApiRestartProcessInstanceAsyncOperationRequest) RestartProcessInstanceDto(restartProcessInstanceDto RestartProcessInstanceDto) ApiRestartProcessInstanceAsyncOperationRequest {
	r.restartProcessInstanceDto = &restartProcessInstanceDto
	return r
}

func (r ApiRestartProcessInstanceAsyncOperationRequest) Execute() (*BatchDto, *http.Response, error) {
	return r.ApiService.RestartProcessInstanceAsyncOperationExecute(r)
}

/*
RestartProcessInstanceAsyncOperation Restart Process Instance Async

Restarts process instances that were canceled or terminated asynchronously.
Can also restart completed process instances.
It will create a new instance using the original instance information.
To execute the restart asynchronously, use the
[Restart Process Instance](https://docs.operaton.org/manual/1.0/reference/rest/process-definition/post-restart-process-instance-sync/) method.

For more information about the difference between synchronous and asynchronous execution,
please refer to the related section of the
[User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/process-instance-restart/#execution).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition of the process instances to restart.
 @return ApiRestartProcessInstanceAsyncOperationRequest
*/
func (a *ProcessDefinitionAPIService) RestartProcessInstanceAsyncOperation(ctx context.Context, id string) ApiRestartProcessInstanceAsyncOperationRequest {
	return ApiRestartProcessInstanceAsyncOperationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BatchDto
func (a *ProcessDefinitionAPIService) RestartProcessInstanceAsyncOperationExecute(r ApiRestartProcessInstanceAsyncOperationRequest) (*BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.RestartProcessInstanceAsyncOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/restart-async"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartProcessInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartProcessInstanceRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	startProcessInstanceDto *StartProcessInstanceDto
}

func (r ApiStartProcessInstanceRequest) StartProcessInstanceDto(startProcessInstanceDto StartProcessInstanceDto) ApiStartProcessInstanceRequest {
	r.startProcessInstanceDto = &startProcessInstanceDto
	return r
}

func (r ApiStartProcessInstanceRequest) Execute() (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	return r.ApiService.StartProcessInstanceExecute(r)
}

/*
StartProcessInstance Start Instance

Instantiates a given process definition.
Process variables and business key may be supplied in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to be retrieved.
 @return ApiStartProcessInstanceRequest
*/
func (a *ProcessDefinitionAPIService) StartProcessInstance(ctx context.Context, id string) ApiStartProcessInstanceRequest {
	return ApiStartProcessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessInstanceWithVariablesDto
func (a *ProcessDefinitionAPIService) StartProcessInstanceExecute(r ApiStartProcessInstanceRequest) (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceWithVariablesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.StartProcessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartProcessInstanceByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	startProcessInstanceDto *StartProcessInstanceDto
}

func (r ApiStartProcessInstanceByKeyRequest) StartProcessInstanceDto(startProcessInstanceDto StartProcessInstanceDto) ApiStartProcessInstanceByKeyRequest {
	r.startProcessInstanceDto = &startProcessInstanceDto
	return r
}

func (r ApiStartProcessInstanceByKeyRequest) Execute() (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	return r.ApiService.StartProcessInstanceByKeyExecute(r)
}

/*
StartProcessInstanceByKey Start Instance

Instantiates a given process definition, starts the latest version of the process definition
which belongs to no tenant.
Process variables and business key may be supplied in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @return ApiStartProcessInstanceByKeyRequest
*/
func (a *ProcessDefinitionAPIService) StartProcessInstanceByKey(ctx context.Context, key string) ApiStartProcessInstanceByKeyRequest {
	return ApiStartProcessInstanceByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return ProcessInstanceWithVariablesDto
func (a *ProcessDefinitionAPIService) StartProcessInstanceByKeyExecute(r ApiStartProcessInstanceByKeyRequest) (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceWithVariablesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.StartProcessInstanceByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartProcessInstanceByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	startProcessInstanceDto *StartProcessInstanceDto
}

func (r ApiStartProcessInstanceByKeyAndTenantIdRequest) StartProcessInstanceDto(startProcessInstanceDto StartProcessInstanceDto) ApiStartProcessInstanceByKeyAndTenantIdRequest {
	r.startProcessInstanceDto = &startProcessInstanceDto
	return r
}

func (r ApiStartProcessInstanceByKeyAndTenantIdRequest) Execute() (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	return r.ApiService.StartProcessInstanceByKeyAndTenantIdExecute(r)
}

/*
StartProcessInstanceByKeyAndTenantId Start Instance

Instantiates a given process definition, starts the latest version of the process definition for tenant.
Process variables and business key may be supplied in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be retrieved.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiStartProcessInstanceByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) StartProcessInstanceByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiStartProcessInstanceByKeyAndTenantIdRequest {
	return ApiStartProcessInstanceByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProcessInstanceWithVariablesDto
func (a *ProcessDefinitionAPIService) StartProcessInstanceByKeyAndTenantIdExecute(r ApiStartProcessInstanceByKeyAndTenantIdRequest) (*ProcessInstanceWithVariablesDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceWithVariablesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.StartProcessInstanceByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitFormRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	startProcessInstanceFormDto *StartProcessInstanceFormDto
}

func (r ApiSubmitFormRequest) StartProcessInstanceFormDto(startProcessInstanceFormDto StartProcessInstanceFormDto) ApiSubmitFormRequest {
	r.startProcessInstanceFormDto = &startProcessInstanceFormDto
	return r
}

func (r ApiSubmitFormRequest) Execute() (*ProcessInstanceDto, *http.Response, error) {
	return r.ApiService.SubmitFormExecute(r)
}

/*
SubmitForm Submit Start Form

Starts a process instance using a set of process variables and the business key.
If the start event has Form Field Metadata defined, the process engine will perform backend validation
for any form fields which have validators defined.
See [Documentation on Generated Task Forms](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to submit the form for.
 @return ApiSubmitFormRequest
*/
func (a *ProcessDefinitionAPIService) SubmitForm(ctx context.Context, id string) ApiSubmitFormRequest {
	return ApiSubmitFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessInstanceDto
func (a *ProcessDefinitionAPIService) SubmitFormExecute(r ApiSubmitFormRequest) (*ProcessInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.SubmitForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/submit-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceFormDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitFormByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	startProcessInstanceFormDto *StartProcessInstanceFormDto
}

func (r ApiSubmitFormByKeyRequest) StartProcessInstanceFormDto(startProcessInstanceFormDto StartProcessInstanceFormDto) ApiSubmitFormByKeyRequest {
	r.startProcessInstanceFormDto = &startProcessInstanceFormDto
	return r
}

func (r ApiSubmitFormByKeyRequest) Execute() (*ProcessInstanceDto, *http.Response, error) {
	return r.ApiService.SubmitFormByKeyExecute(r)
}

/*
SubmitFormByKey Submit Start Form

Starts the latest version of the process definition which belongs to no tenant
using a set of process variables and the business key.
If the start event has Form Field Metadata defined, the process engine will perform backend validation
for any form fields which have validators defined.
See [Documentation on Generated Task Forms](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition to submit the form for.
 @return ApiSubmitFormByKeyRequest
*/
func (a *ProcessDefinitionAPIService) SubmitFormByKey(ctx context.Context, key string) ApiSubmitFormByKeyRequest {
	return ApiSubmitFormByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return ProcessInstanceDto
func (a *ProcessDefinitionAPIService) SubmitFormByKeyExecute(r ApiSubmitFormByKeyRequest) (*ProcessInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.SubmitFormByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/submit-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceFormDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitFormByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	startProcessInstanceFormDto *StartProcessInstanceFormDto
}

func (r ApiSubmitFormByKeyAndTenantIdRequest) StartProcessInstanceFormDto(startProcessInstanceFormDto StartProcessInstanceFormDto) ApiSubmitFormByKeyAndTenantIdRequest {
	r.startProcessInstanceFormDto = &startProcessInstanceFormDto
	return r
}

func (r ApiSubmitFormByKeyAndTenantIdRequest) Execute() (*ProcessInstanceDto, *http.Response, error) {
	return r.ApiService.SubmitFormByKeyAndTenantIdExecute(r)
}

/*
SubmitFormByKeyAndTenantId Submit Start Form

Starts the latest version of the process definition for a tenant
using a set of process variables and the business key.
If the start event has Form Field Metadata defined, the process engine will perform backend validation
for any form fields which have validators defined.
See [Documentation on Generated Task Forms](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition to submit the form for.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiSubmitFormByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) SubmitFormByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiSubmitFormByKeyAndTenantIdRequest {
	return ApiSubmitFormByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProcessInstanceDto
func (a *ProcessDefinitionAPIService) SubmitFormByKeyAndTenantIdExecute(r ApiSubmitFormByKeyAndTenantIdRequest) (*ProcessInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.SubmitFormByKeyAndTenantId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/submit-form"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startProcessInstanceFormDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByProcessDefinitionIdExecute(r)
}

/*
UpdateHistoryTimeToLiveByProcessDefinitionId Update History Time to Live

Updates history time to live for process definition.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).
The value of the update is mandatory by default and does not allow `null` values. To enable them, please
set the feature flag `enforceHistoryTimeToLive` to `false`. Read more in [Configuration Properties]
(https://docs.operaton.org/manual/1.0/reference/deployment-descriptors/tags/process-engine#configuration-properties)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to change history time to live.
 @return ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest
*/
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionId(ctx context.Context, id string) ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest {
	return ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionIdExecute(r ApiUpdateHistoryTimeToLiveByProcessDefinitionIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateHistoryTimeToLiveByProcessDefinitionId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByProcessDefinitionKeyExecute(r)
}

/*
UpdateHistoryTimeToLiveByProcessDefinitionKey Update History Time to Live

Updates history time to live for the latest version of the process definition which belongs to no tenant.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).
The value of the update is mandatory by default and does not allow `null` values. To enable them, please
set the feature flag `enforceHistoryTimeToLive` to `false`. Read more in [Configuration Properties]
(https://docs.operaton.org/manual/1.0/reference/deployment-descriptors/tags/process-engine#configuration-properties)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition to change history time to live.
 @return ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest
*/
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionKey(ctx context.Context, key string) ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest {
	return ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionKeyExecute(r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateHistoryTimeToLiveByProcessDefinitionKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	historyTimeToLiveDto *HistoryTimeToLiveDto
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest) HistoryTimeToLiveDto(historyTimeToLiveDto HistoryTimeToLiveDto) ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest {
	r.historyTimeToLiveDto = &historyTimeToLiveDto
	return r
}

func (r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdExecute(r)
}

/*
UpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId Update History Time to Live

Updates history time to live for the latest version of the process definition for a tenant.
The field is used within [History cleanup](https://docs.operaton.org/manual/1.0/user-guide/process-engine/history/#history-cleanup).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition to change history time to live.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest {
	return ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdExecute(r ApiUpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/history-time-to-live"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.historyTimeToLiveDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProcessDefinitionSuspensionStateRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	processDefinitionSuspensionStateDto *ProcessDefinitionSuspensionStateDto
}

// **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
func (r ApiUpdateProcessDefinitionSuspensionStateRequest) ProcessDefinitionSuspensionStateDto(processDefinitionSuspensionStateDto ProcessDefinitionSuspensionStateDto) ApiUpdateProcessDefinitionSuspensionStateRequest {
	r.processDefinitionSuspensionStateDto = &processDefinitionSuspensionStateDto
	return r
}

func (r ApiUpdateProcessDefinitionSuspensionStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateProcessDefinitionSuspensionStateExecute(r)
}

/*
UpdateProcessDefinitionSuspensionState Activate/Suspend By Key

Activates or suspends process definitions with the given process definition key.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateProcessDefinitionSuspensionStateRequest
*/
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionState(ctx context.Context) ApiUpdateProcessDefinitionSuspensionStateRequest {
	return ApiUpdateProcessDefinitionSuspensionStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateExecute(r ApiUpdateProcessDefinitionSuspensionStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateProcessDefinitionSuspensionState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/suspended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processDefinitionSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProcessDefinitionSuspensionStateByIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	id string
	processDefinitionSuspensionStateDto *ProcessDefinitionSuspensionStateDto
}

// **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
func (r ApiUpdateProcessDefinitionSuspensionStateByIdRequest) ProcessDefinitionSuspensionStateDto(processDefinitionSuspensionStateDto ProcessDefinitionSuspensionStateDto) ApiUpdateProcessDefinitionSuspensionStateByIdRequest {
	r.processDefinitionSuspensionStateDto = &processDefinitionSuspensionStateDto
	return r
}

func (r ApiUpdateProcessDefinitionSuspensionStateByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateProcessDefinitionSuspensionStateByIdExecute(r)
}

/*
UpdateProcessDefinitionSuspensionStateById Activate/Suspend By Id

Activates or suspends a given process definition by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition to activate or suspend.
 @return ApiUpdateProcessDefinitionSuspensionStateByIdRequest
*/
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateById(ctx context.Context, id string) ApiUpdateProcessDefinitionSuspensionStateByIdRequest {
	return ApiUpdateProcessDefinitionSuspensionStateByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateByIdExecute(r ApiUpdateProcessDefinitionSuspensionStateByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateProcessDefinitionSuspensionStateById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/{id}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processDefinitionSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProcessDefinitionSuspensionStateByKeyRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	processDefinitionSuspensionStateDto *ProcessDefinitionSuspensionStateDto
}

// **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
func (r ApiUpdateProcessDefinitionSuspensionStateByKeyRequest) ProcessDefinitionSuspensionStateDto(processDefinitionSuspensionStateDto ProcessDefinitionSuspensionStateDto) ApiUpdateProcessDefinitionSuspensionStateByKeyRequest {
	r.processDefinitionSuspensionStateDto = &processDefinitionSuspensionStateDto
	return r
}

func (r ApiUpdateProcessDefinitionSuspensionStateByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateProcessDefinitionSuspensionStateByKeyExecute(r)
}

/*
UpdateProcessDefinitionSuspensionStateByKey Activate/Suspend by Id

Activates or suspends a given process definition by latest version of process definition key
which belongs to no tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be activated/suspended.
 @return ApiUpdateProcessDefinitionSuspensionStateByKeyRequest
*/
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateByKey(ctx context.Context, key string) ApiUpdateProcessDefinitionSuspensionStateByKeyRequest {
	return ApiUpdateProcessDefinitionSuspensionStateByKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateByKeyExecute(r ApiUpdateProcessDefinitionSuspensionStateByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateProcessDefinitionSuspensionStateByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processDefinitionSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest struct {
	ctx context.Context
	ApiService *ProcessDefinitionAPIService
	key string
	tenantId string
	processDefinitionSuspensionStateDto *ProcessDefinitionSuspensionStateDto
}

// **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
func (r ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest) ProcessDefinitionSuspensionStateDto(processDefinitionSuspensionStateDto ProcessDefinitionSuspensionStateDto) ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest {
	r.processDefinitionSuspensionStateDto = &processDefinitionSuspensionStateDto
	return r
}

func (r ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateProcessDefinitionSuspensionStateByKeyAndTenantIdExecute(r)
}

/*
UpdateProcessDefinitionSuspensionStateByKeyAndTenantId Activate/Suspend by Id

Activates or suspends a given process definition by the latest version of
the process definition for tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key The key of the process definition (the latest version thereof) to be activated/suspended.
 @param tenantId The id of the tenant the process definition belongs to.
 @return ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest
*/
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateByKeyAndTenantId(ctx context.Context, key string, tenantId string) ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest {
	return ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
		tenantId: tenantId,
	}
}

// Execute executes the request
func (a *ProcessDefinitionAPIService) UpdateProcessDefinitionSuspensionStateByKeyAndTenantIdExecute(r ApiUpdateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProcessDefinitionAPIService.UpdateProcessDefinitionSuspensionStateByKeyAndTenantId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/process-definition/key/{key}/tenant-id/{tenant-id}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant-id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processDefinitionSuspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
