/*
Operaton REST API

OpenApi Spec for Operaton REST API.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package operaton

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// TaskAPIService TaskAPI service
type TaskAPIService service

type ApiClaimRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that claims the task.
func (r ApiClaimRequest) UserIdDto(userIdDto UserIdDto) ApiClaimRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiClaimRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClaimExecute(r)
}

/*
Claim Claim

Claims a task for a specific user.

**Note:** The difference with the
[Set Assignee](https://docs.operaton.org/manual/1.0/reference/rest/task/post-assignee/)
method is that here a check is performed to see if the task already has a user
assigned to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to claim.
 @return ApiClaimRequest
*/
func (a *TaskAPIService) Claim(ctx context.Context, id string) ApiClaimRequest {
	return ApiClaimRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) ClaimExecute(r ApiClaimRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Claim")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/claim"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompleteRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiCompleteRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiCompleteRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiCompleteRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.CompleteExecute(r)
}

/*
Complete Complete

Completes a task and updates process variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to complete.
 @return ApiCompleteRequest
*/
func (a *TaskAPIService) Complete(ctx context.Context, id string) ApiCompleteRequest {
	return ApiCompleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) CompleteExecute(r ApiCompleteRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Complete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTaskRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	taskDto *TaskDto
}

func (r ApiCreateTaskRequest) TaskDto(taskDto TaskDto) ApiCreateTaskRequest {
	r.taskDto = &taskDto
	return r
}

func (r ApiCreateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTaskExecute(r)
}

/*
CreateTask Create

Creates a new task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTaskRequest
*/
func (a *TaskAPIService) CreateTask(ctx context.Context) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TaskAPIService) CreateTaskExecute(r ApiCreateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.CreateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelegateTaskRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that the task should be delegated to.
func (r ApiDelegateTaskRequest) UserIdDto(userIdDto UserIdDto) ApiDelegateTaskRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiDelegateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.DelegateTaskExecute(r)
}

/*
DelegateTask Delegate

Delegates a task to another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to delegate.
 @return ApiDelegateTaskRequest
*/
func (a *TaskAPIService) DelegateTask(ctx context.Context, id string) ApiDelegateTaskRequest {
	return ApiDelegateTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) DelegateTaskExecute(r ApiDelegateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.DelegateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/delegate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTaskRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiDeleteTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTaskExecute(r)
}

/*
DeleteTask Delete

Removes a task by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be removed.
 @return ApiDeleteTaskRequest
*/
func (a *TaskAPIService) DeleteTask(ctx context.Context, id string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) DeleteTaskExecute(r ApiDeleteTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.DeleteTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeployedFormRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiGetDeployedFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeployedFormExecute(r)
}

/*
GetDeployedForm Get Deployed Form

Retrieves the deployed form that is referenced from a given task. For further
information please refer to the
[User Guide](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#embedded-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to get the deployed form for.
 @return ApiGetDeployedFormRequest
*/
func (a *TaskAPIService) GetDeployedForm(ctx context.Context, id string) ApiGetDeployedFormRequest {
	return ApiGetDeployedFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaskAPIService) GetDeployedFormExecute(r ApiGetDeployedFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetDeployedForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/deployed-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFormRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiGetFormRequest) Execute() (*FormDto, *http.Response, error) {
	return r.ApiService.GetFormExecute(r)
}

/*
GetForm Get Form Key

Retrieves the form key for a task. The form key corresponds to the `FormData#formKey`
property in the engine. This key can be used to do task-specific form rendering in
client applications. Additionally, the context path of the containing process
application is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to retrieve the form for.
 @return ApiGetFormRequest
*/
func (a *TaskAPIService) GetForm(ctx context.Context, id string) ApiGetFormRequest {
	return ApiGetFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FormDto
func (a *TaskAPIService) GetFormExecute(r ApiGetFormRequest) (*FormDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFormVariablesRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	variableNames *string
	deserializeValues *bool
}

// A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
func (r ApiGetFormVariablesRequest) VariableNames(variableNames string) ApiGetFormVariablesRequest {
	r.variableNames = &variableNames
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetFormVariablesRequest) DeserializeValues(deserializeValues bool) ApiGetFormVariablesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetFormVariablesRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetFormVariablesExecute(r)
}

/*
GetFormVariables Get Task Form Variables

Retrieves the form variables for a task. The form variables take form data specified
on the task into account. If form fields are defined, the variable types and default
values of the form fields are taken into account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to retrieve the variables for.
 @return ApiGetFormVariablesRequest
*/
func (a *TaskAPIService) GetFormVariables(ctx context.Context, id string) ApiGetFormVariablesRequest {
	return ApiGetFormVariablesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) GetFormVariablesExecute(r ApiGetFormVariablesRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetFormVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/form-variables"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNames", r.variableNames, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	} else {
		var defaultValue bool = true
		r.deserializeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderedFormRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiGetRenderedFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRenderedFormExecute(r)
}

/*
GetRenderedForm Get Rendered Form

Retrieves the rendered form for a task. This method can be used to get the HTML
rendering of a
[Generated Task Form](https://docs.operaton.org/manual/1.0/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to get the rendered form for.
 @return ApiGetRenderedFormRequest
*/
func (a *TaskAPIService) GetRenderedForm(ctx context.Context, id string) ApiGetRenderedFormRequest {
	return ApiGetRenderedFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaskAPIService) GetRenderedFormExecute(r ApiGetRenderedFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetRenderedForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/rendered-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiGetTaskRequest) Execute() (*TaskWithAttachmentAndCommentDto, *http.Response, error) {
	return r.ApiService.GetTaskExecute(r)
}

/*
GetTask Get

Retrieves a task by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be retrieved.
 @return ApiGetTaskRequest
*/
func (a *TaskAPIService) GetTask(ctx context.Context, id string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TaskWithAttachmentAndCommentDto
func (a *TaskAPIService) GetTaskExecute(r ApiGetTaskRequest) (*TaskWithAttachmentAndCommentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskWithAttachmentAndCommentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskCountByCandidateGroupRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
}

func (r ApiGetTaskCountByCandidateGroupRequest) Execute() ([]TaskCountByCandidateGroupResultDto, *http.Response, error) {
	return r.ApiService.GetTaskCountByCandidateGroupExecute(r)
}

/*
GetTaskCountByCandidateGroup Get Task Count By Candidate Group

Retrieves the number of tasks for each candidate group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTaskCountByCandidateGroupRequest
*/
func (a *TaskAPIService) GetTaskCountByCandidateGroup(ctx context.Context) ApiGetTaskCountByCandidateGroupRequest {
	return ApiGetTaskCountByCandidateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskCountByCandidateGroupResultDto
func (a *TaskAPIService) GetTaskCountByCandidateGroupExecute(r ApiGetTaskCountByCandidateGroupRequest) ([]TaskCountByCandidateGroupResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskCountByCandidateGroupResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTaskCountByCandidateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/report/candidate-group-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/csv", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	taskId *string
	taskIdIn *string
	processInstanceId *string
	processInstanceIdIn *string
	processInstanceBusinessKey *string
	processInstanceBusinessKeyExpression *string
	processInstanceBusinessKeyIn *string
	processInstanceBusinessKeyLike *string
	processInstanceBusinessKeyLikeExpression *string
	processDefinitionId *string
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	executionId *string
	caseInstanceId *string
	caseInstanceBusinessKey *string
	caseInstanceBusinessKeyLike *string
	caseDefinitionId *string
	caseDefinitionKey *string
	caseDefinitionName *string
	caseDefinitionNameLike *string
	caseExecutionId *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	assignee *string
	assigneeExpression *string
	assigneeLike *string
	assigneeLikeExpression *string
	assigneeIn *string
	assigneeNotIn *string
	owner *string
	ownerExpression *string
	candidateGroup *string
	candidateGroupLike *string
	candidateGroupExpression *string
	candidateUser *string
	candidateUserExpression *string
	includeAssignedTasks *bool
	involvedUser *string
	involvedUserExpression *string
	assigned *bool
	unassigned *bool
	taskDefinitionKey *string
	taskDefinitionKeyIn *string
	taskDefinitionKeyNotIn *string
	taskDefinitionKeyLike *string
	name *string
	nameNotEqual *string
	nameLike *string
	nameNotLike *string
	description *string
	descriptionLike *string
	priority *int32
	maxPriority *int32
	minPriority *int32
	dueDate *string
	dueDateExpression *string
	dueAfter *string
	dueAfterExpression *string
	dueBefore *string
	dueBeforeExpression *string
	withoutDueDate *bool
	followUpDate *string
	followUpDateExpression *string
	followUpAfter *string
	followUpAfterExpression *string
	followUpBefore *string
	followUpBeforeExpression *string
	followUpBeforeOrNotExistent *string
	followUpBeforeOrNotExistentExpression *string
	createdOn *string
	createdOnExpression *string
	createdAfter *string
	createdAfterExpression *string
	createdBefore *string
	createdBeforeExpression *string
	updatedAfter *string
	updatedAfterExpression *string
	delegationState *string
	candidateGroups *string
	candidateGroupsExpression *string
	withCandidateGroups *bool
	withoutCandidateGroups *bool
	withCandidateUsers *bool
	withoutCandidateUsers *bool
	active *bool
	suspended *bool
	taskVariables *string
	processVariables *string
	caseInstanceVariables *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	parentTaskId *string
	withCommentAttachmentInfo *bool
	withTaskVariablesInReturn *bool
	withTaskLocalVariablesInReturn *bool
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Restrict to task with the given id.
func (r ApiGetTasksRequest) TaskId(taskId string) ApiGetTasksRequest {
	r.taskId = &taskId
	return r
}

// Restrict to tasks with any of the given ids.
func (r ApiGetTasksRequest) TaskIdIn(taskIdIn string) ApiGetTasksRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given id.
func (r ApiGetTasksRequest) ProcessInstanceId(processInstanceId string) ApiGetTasksRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restrict to tasks that belong to process instances with the given ids.
func (r ApiGetTasksRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetTasksRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given business key.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKey(processInstanceBusinessKey string) ApiGetTasksRequest {
	r.processInstanceBusinessKey = &processInstanceBusinessKey
	return r
}

// Restrict to tasks that belong to process instances with the given business key which is described by an expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyExpression(processInstanceBusinessKeyExpression string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyExpression = &processInstanceBusinessKeyExpression
	return r
}

// Restrict to tasks that belong to process instances with one of the give business keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyIn(processInstanceBusinessKeyIn string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyIn = &processInstanceBusinessKeyIn
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter value as a substring.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyLike(processInstanceBusinessKeyLike string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyLike = &processInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter value as a substring and is described by an expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyLikeExpression(processInstanceBusinessKeyLikeExpression string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyLikeExpression = &processInstanceBusinessKeyLikeExpression
	return r
}

// Restrict to tasks that belong to a process definition with the given id.
func (r ApiGetTasksRequest) ProcessDefinitionId(processDefinitionId string) ApiGetTasksRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetTasksRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetTasksRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetTasksRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetTasksRequest) ProcessDefinitionName(processDefinitionName string) ApiGetTasksRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as a substring.
func (r ApiGetTasksRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetTasksRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Restrict to tasks that belong to an execution with the given id.
func (r ApiGetTasksRequest) ExecutionId(executionId string) ApiGetTasksRequest {
	r.executionId = &executionId
	return r
}

// Restrict to tasks that belong to case instances with the given id.
func (r ApiGetTasksRequest) CaseInstanceId(caseInstanceId string) ApiGetTasksRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Restrict to tasks that belong to case instances with the given business key.
func (r ApiGetTasksRequest) CaseInstanceBusinessKey(caseInstanceBusinessKey string) ApiGetTasksRequest {
	r.caseInstanceBusinessKey = &caseInstanceBusinessKey
	return r
}

// Restrict to tasks that have a case instance business key that has the parameter value as a substring.
func (r ApiGetTasksRequest) CaseInstanceBusinessKeyLike(caseInstanceBusinessKeyLike string) ApiGetTasksRequest {
	r.caseInstanceBusinessKeyLike = &caseInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that belong to a case definition with the given id.
func (r ApiGetTasksRequest) CaseDefinitionId(caseDefinitionId string) ApiGetTasksRequest {
	r.caseDefinitionId = &caseDefinitionId
	return r
}

// Restrict to tasks that belong to a case definition with the given key.
func (r ApiGetTasksRequest) CaseDefinitionKey(caseDefinitionKey string) ApiGetTasksRequest {
	r.caseDefinitionKey = &caseDefinitionKey
	return r
}

// Restrict to tasks that belong to a case definition with the given name.
func (r ApiGetTasksRequest) CaseDefinitionName(caseDefinitionName string) ApiGetTasksRequest {
	r.caseDefinitionName = &caseDefinitionName
	return r
}

// Restrict to tasks that have a case definition name that has the parameter value as a substring.
func (r ApiGetTasksRequest) CaseDefinitionNameLike(caseDefinitionNameLike string) ApiGetTasksRequest {
	r.caseDefinitionNameLike = &caseDefinitionNameLike
	return r
}

// Restrict to tasks that belong to a case execution with the given id.
func (r ApiGetTasksRequest) CaseExecutionId(caseExecutionId string) ApiGetTasksRequest {
	r.caseExecutionId = &caseExecutionId
	return r
}

// Only include tasks which belong to one of the passed and comma-separated activity instance ids.
func (r ApiGetTasksRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetTasksRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include tasks which belong to one of the passed and comma-separated tenant ids.
func (r ApiGetTasksRequest) TenantIdIn(tenantIdIn string) ApiGetTasksRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutTenantId(withoutTenantId bool) ApiGetTasksRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Restrict to tasks that the given user is assigned to.
func (r ApiGetTasksRequest) Assignee(assignee string) ApiGetTasksRequest {
	r.assignee = &assignee
	return r
}

// Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) AssigneeExpression(assigneeExpression string) ApiGetTasksRequest {
	r.assigneeExpression = &assigneeExpression
	return r
}

// Restrict to tasks that have an assignee that has the parameter value as a substring.
func (r ApiGetTasksRequest) AssigneeLike(assigneeLike string) ApiGetTasksRequest {
	r.assigneeLike = &assigneeLike
	return r
}

// Restrict to tasks that have an assignee that has the parameter value described by the given expression as a substring. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) AssigneeLikeExpression(assigneeLikeExpression string) ApiGetTasksRequest {
	r.assigneeLikeExpression = &assigneeLikeExpression
	return r
}

// Only include tasks which are assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksRequest) AssigneeIn(assigneeIn string) ApiGetTasksRequest {
	r.assigneeIn = &assigneeIn
	return r
}

// Only include tasks which are not assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksRequest) AssigneeNotIn(assigneeNotIn string) ApiGetTasksRequest {
	r.assigneeNotIn = &assigneeNotIn
	return r
}

// Restrict to tasks that the given user owns.
func (r ApiGetTasksRequest) Owner(owner string) ApiGetTasksRequest {
	r.owner = &owner
	return r
}

// Restrict to tasks that the user described by the given expression owns. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) OwnerExpression(ownerExpression string) ApiGetTasksRequest {
	r.ownerExpression = &ownerExpression
	return r
}

// Only include tasks that are offered to the given group.
func (r ApiGetTasksRequest) CandidateGroup(candidateGroup string) ApiGetTasksRequest {
	r.candidateGroup = &candidateGroup
	return r
}

// Only include tasks that are offered to groups that have the parameter value as a substring.
func (r ApiGetTasksRequest) CandidateGroupLike(candidateGroupLike string) ApiGetTasksRequest {
	r.candidateGroupLike = &candidateGroupLike
	return r
}

// Only include tasks that are offered to the group described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) CandidateGroupExpression(candidateGroupExpression string) ApiGetTasksRequest {
	r.candidateGroupExpression = &candidateGroupExpression
	return r
}

// Only include tasks that are offered to the given user or to one of his groups.
func (r ApiGetTasksRequest) CandidateUser(candidateUser string) ApiGetTasksRequest {
	r.candidateUser = &candidateUser
	return r
}

// Only include tasks that are offered to the user described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) CandidateUserExpression(candidateUserExpression string) ApiGetTasksRequest {
	r.candidateUserExpression = &candidateUserExpression
	return r
}

// Also include tasks that are assigned to users in candidate queries. Default is to only include tasks that are not assigned to any user if you query by candidate user or group(s).
func (r ApiGetTasksRequest) IncludeAssignedTasks(includeAssignedTasks bool) ApiGetTasksRequest {
	r.includeAssignedTasks = &includeAssignedTasks
	return r
}

// Only include tasks that the given user is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee).
func (r ApiGetTasksRequest) InvolvedUser(involvedUser string) ApiGetTasksRequest {
	r.involvedUser = &involvedUser
	return r
}

// Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) InvolvedUserExpression(involvedUserExpression string) ApiGetTasksRequest {
	r.involvedUserExpression = &involvedUserExpression
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
func (r ApiGetTasksRequest) Assigned(assigned bool) ApiGetTasksRequest {
	r.assigned = &assigned
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
func (r ApiGetTasksRequest) Unassigned(unassigned bool) ApiGetTasksRequest {
	r.unassigned = &unassigned
	return r
}

// Restrict to tasks that have the given key.
func (r ApiGetTasksRequest) TaskDefinitionKey(taskDefinitionKey string) ApiGetTasksRequest {
	r.taskDefinitionKey = &taskDefinitionKey
	return r
}

// Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) TaskDefinitionKeyIn(taskDefinitionKeyIn string) ApiGetTasksRequest {
	r.taskDefinitionKeyIn = &taskDefinitionKeyIn
	return r
}

// Exclude instances by a list of task definition keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) TaskDefinitionKeyNotIn(taskDefinitionKeyNotIn string) ApiGetTasksRequest {
	r.taskDefinitionKeyNotIn = &taskDefinitionKeyNotIn
	return r
}

// Restrict to tasks that have a key that has the parameter value as a substring.
func (r ApiGetTasksRequest) TaskDefinitionKeyLike(taskDefinitionKeyLike string) ApiGetTasksRequest {
	r.taskDefinitionKeyLike = &taskDefinitionKeyLike
	return r
}

// Restrict to tasks that have the given name.
func (r ApiGetTasksRequest) Name(name string) ApiGetTasksRequest {
	r.name = &name
	return r
}

// Restrict to tasks that do not have the given name.
func (r ApiGetTasksRequest) NameNotEqual(nameNotEqual string) ApiGetTasksRequest {
	r.nameNotEqual = &nameNotEqual
	return r
}

// Restrict to tasks that have a name with the given parameter value as substring.
func (r ApiGetTasksRequest) NameLike(nameLike string) ApiGetTasksRequest {
	r.nameLike = &nameLike
	return r
}

// Restrict to tasks that do not have a name with the given parameter value as substring.
func (r ApiGetTasksRequest) NameNotLike(nameNotLike string) ApiGetTasksRequest {
	r.nameNotLike = &nameNotLike
	return r
}

// Restrict to tasks that have the given description.
func (r ApiGetTasksRequest) Description(description string) ApiGetTasksRequest {
	r.description = &description
	return r
}

// Restrict to tasks that have a description that has the parameter value as a substring.
func (r ApiGetTasksRequest) DescriptionLike(descriptionLike string) ApiGetTasksRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// Restrict to tasks that have the given priority.
func (r ApiGetTasksRequest) Priority(priority int32) ApiGetTasksRequest {
	r.priority = &priority
	return r
}

// Restrict to tasks that have a lower or equal priority.
func (r ApiGetTasksRequest) MaxPriority(maxPriority int32) ApiGetTasksRequest {
	r.maxPriority = &maxPriority
	return r
}

// Restrict to tasks that have a higher or equal priority.
func (r ApiGetTasksRequest) MinPriority(minPriority int32) ApiGetTasksRequest {
	r.minPriority = &minPriority
	return r
}

// Restrict to tasks that are due on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetTasksRequest) DueDate(dueDate string) ApiGetTasksRequest {
	r.dueDate = &dueDate
	return r
}

// Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueDateExpression(dueDateExpression string) ApiGetTasksRequest {
	r.dueDateExpression = &dueDateExpression
	return r
}

// Restrict to tasks that are due after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
func (r ApiGetTasksRequest) DueAfter(dueAfter string) ApiGetTasksRequest {
	r.dueAfter = &dueAfter
	return r
}

// Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueAfterExpression(dueAfterExpression string) ApiGetTasksRequest {
	r.dueAfterExpression = &dueAfterExpression
	return r
}

// Restrict to tasks that are due before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
func (r ApiGetTasksRequest) DueBefore(dueBefore string) ApiGetTasksRequest {
	r.dueBefore = &dueBefore
	return r
}

// Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueBeforeExpression(dueBeforeExpression string) ApiGetTasksRequest {
	r.dueBeforeExpression = &dueBeforeExpression
	return r
}

// Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutDueDate(withoutDueDate bool) ApiGetTasksRequest {
	r.withoutDueDate = &withoutDueDate
	return r
}

// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpDate(followUpDate string) ApiGetTasksRequest {
	r.followUpDate = &followUpDate
	return r
}

// Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpDateExpression(followUpDateExpression string) ApiGetTasksRequest {
	r.followUpDateExpression = &followUpDateExpression
	return r
}

// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpAfter(followUpAfter string) ApiGetTasksRequest {
	r.followUpAfter = &followUpAfter
	return r
}

// Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpAfterExpression(followUpAfterExpression string) ApiGetTasksRequest {
	r.followUpAfterExpression = &followUpAfterExpression
	return r
}

// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpBefore(followUpBefore string) ApiGetTasksRequest {
	r.followUpBefore = &followUpBefore
	return r
}

// Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpBeforeExpression(followUpBeforeExpression string) ApiGetTasksRequest {
	r.followUpBeforeExpression = &followUpBeforeExpression
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
func (r ApiGetTasksRequest) FollowUpBeforeOrNotExistent(followUpBeforeOrNotExistent string) ApiGetTasksRequest {
	r.followUpBeforeOrNotExistent = &followUpBeforeOrNotExistent
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpBeforeOrNotExistentExpression(followUpBeforeOrNotExistentExpression string) ApiGetTasksRequest {
	r.followUpBeforeOrNotExistentExpression = &followUpBeforeOrNotExistentExpression
	return r
}

// Restrict to tasks that were created on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
func (r ApiGetTasksRequest) CreatedOn(createdOn string) ApiGetTasksRequest {
	r.createdOn = &createdOn
	return r
}

// Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedOnExpression(createdOnExpression string) ApiGetTasksRequest {
	r.createdOnExpression = &createdOnExpression
	return r
}

// Restrict to tasks that were created after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksRequest) CreatedAfter(createdAfter string) ApiGetTasksRequest {
	r.createdAfter = &createdAfter
	return r
}

// Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedAfterExpression(createdAfterExpression string) ApiGetTasksRequest {
	r.createdAfterExpression = &createdAfterExpression
	return r
}

// Restrict to tasks that were created before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksRequest) CreatedBefore(createdBefore string) ApiGetTasksRequest {
	r.createdBefore = &createdBefore
	return r
}

// Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedBeforeExpression(createdBeforeExpression string) ApiGetTasksRequest {
	r.createdBeforeExpression = &createdBeforeExpression
	return r
}

// Restrict to tasks that were updated after the given date. Every action that fires a [task update event](https://docs.operaton.org/manual/1.0/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksRequest) UpdatedAfter(updatedAfter string) ApiGetTasksRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Restrict to tasks that were updated after the date described by the given expression. Every action that fires a [task update event](https://docs.operaton.org/manual/1.0/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) UpdatedAfterExpression(updatedAfterExpression string) ApiGetTasksRequest {
	r.updatedAfterExpression = &updatedAfterExpression
	return r
}

// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
func (r ApiGetTasksRequest) DelegationState(delegationState string) ApiGetTasksRequest {
	r.delegationState = &delegationState
	return r
}

// Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
func (r ApiGetTasksRequest) CandidateGroups(candidateGroups string) ApiGetTasksRequest {
	r.candidateGroups = &candidateGroups
	return r
}

// Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
func (r ApiGetTasksRequest) CandidateGroupsExpression(candidateGroupsExpression string) ApiGetTasksRequest {
	r.candidateGroupsExpression = &candidateGroupsExpression
	return r
}

// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithCandidateGroups(withCandidateGroups bool) ApiGetTasksRequest {
	r.withCandidateGroups = &withCandidateGroups
	return r
}

// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutCandidateGroups(withoutCandidateGroups bool) ApiGetTasksRequest {
	r.withoutCandidateGroups = &withoutCandidateGroups
	return r
}

// Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithCandidateUsers(withCandidateUsers bool) ApiGetTasksRequest {
	r.withCandidateUsers = &withCandidateUsers
	return r
}

// Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutCandidateUsers(withoutCandidateUsers bool) ApiGetTasksRequest {
	r.withoutCandidateUsers = &withoutCandidateUsers
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) Active(active bool) ApiGetTasksRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) Suspended(suspended bool) ApiGetTasksRequest {
	r.suspended = &suspended
	return r
}

// Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) TaskVariables(taskVariables string) ApiGetTasksRequest {
	r.taskVariables = &taskVariables
	return r
}

// Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) ProcessVariables(processVariables string) ApiGetTasksRequest {
	r.processVariables = &processVariables
	return r
}

// Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) CaseInstanceVariables(caseInstanceVariables string) ApiGetTasksRequest {
	r.caseInstanceVariables = &caseInstanceVariables
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetTasksRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetTasksRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetTasksRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetTasksRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
func (r ApiGetTasksRequest) ParentTaskId(parentTaskId string) ApiGetTasksRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Check if task has attachments and/or comments. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. Adding the filter will do additional attachment and comments queries to the database, it might slow down the query in case of tables having high volume of data. This param is not considered for count queries
func (r ApiGetTasksRequest) WithCommentAttachmentInfo(withCommentAttachmentInfo bool) ApiGetTasksRequest {
	r.withCommentAttachmentInfo = &withCommentAttachmentInfo
	return r
}

// Indicates if all the variables visible from task should be retrieved. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithTaskVariablesInReturn(withTaskVariablesInReturn bool) ApiGetTasksRequest {
	r.withTaskVariablesInReturn = &withTaskVariablesInReturn
	return r
}

// Indicates if all the local variables visible from task should be retrieved. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithTaskLocalVariablesInReturn(withTaskLocalVariablesInReturn bool) ApiGetTasksRequest {
	r.withTaskLocalVariablesInReturn = &withTaskLocalVariablesInReturn
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetTasksRequest) SortBy(sortBy string) ApiGetTasksRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetTasksRequest) SortOrder(sortOrder string) ApiGetTasksRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetTasksRequest) FirstResult(firstResult int32) ApiGetTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetTasksRequest) MaxResults(maxResults int32) ApiGetTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetTasksRequest) Execute() ([]TaskWithAttachmentAndCommentDto, *http.Response, error) {
	return r.ApiService.GetTasksExecute(r)
}

/*
GetTasks Get List

Queries for tasks that fulfill a given filter. The size of the result set can be
retrieved by using the Get Task Count method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.operaton.org/manual/1.0/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTasksRequest
*/
func (a *TaskAPIService) GetTasks(ctx context.Context) ApiGetTasksRequest {
	return ApiGetTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskWithAttachmentAndCommentDto
func (a *TaskAPIService) GetTasksExecute(r ApiGetTasksRequest) ([]TaskWithAttachmentAndCommentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskWithAttachmentAndCommentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKey", r.processInstanceBusinessKey, "")
	}
	if r.processInstanceBusinessKeyExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyExpression", r.processInstanceBusinessKeyExpression, "")
	}
	if r.processInstanceBusinessKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyIn", r.processInstanceBusinessKeyIn, "")
	}
	if r.processInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLike", r.processInstanceBusinessKeyLike, "")
	}
	if r.processInstanceBusinessKeyLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLikeExpression", r.processInstanceBusinessKeyLikeExpression, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKey", r.caseInstanceBusinessKey, "")
	}
	if r.caseInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKeyLike", r.caseInstanceBusinessKeyLike, "")
	}
	if r.caseDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionId", r.caseDefinitionId, "")
	}
	if r.caseDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionKey", r.caseDefinitionKey, "")
	}
	if r.caseDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionName", r.caseDefinitionName, "")
	}
	if r.caseDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionNameLike", r.caseDefinitionNameLike, "")
	}
	if r.caseExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionId", r.caseExecutionId, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "")
	}
	if r.assigneeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeExpression", r.assigneeExpression, "")
	}
	if r.assigneeLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLike", r.assigneeLike, "")
	}
	if r.assigneeLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLikeExpression", r.assigneeLikeExpression, "")
	}
	if r.assigneeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeIn", r.assigneeIn, "")
	}
	if r.assigneeNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeNotIn", r.assigneeNotIn, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.ownerExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExpression", r.ownerExpression, "")
	}
	if r.candidateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroup", r.candidateGroup, "")
	}
	if r.candidateGroupLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupLike", r.candidateGroupLike, "")
	}
	if r.candidateGroupExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupExpression", r.candidateGroupExpression, "")
	}
	if r.candidateUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUser", r.candidateUser, "")
	}
	if r.candidateUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUserExpression", r.candidateUserExpression, "")
	}
	if r.includeAssignedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssignedTasks", r.includeAssignedTasks, "")
	} else {
		var defaultValue bool = false
		r.includeAssignedTasks = &defaultValue
	}
	if r.involvedUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUser", r.involvedUser, "")
	}
	if r.involvedUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUserExpression", r.involvedUserExpression, "")
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	} else {
		var defaultValue bool = false
		r.assigned = &defaultValue
	}
	if r.unassigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassigned", r.unassigned, "")
	} else {
		var defaultValue bool = false
		r.unassigned = &defaultValue
	}
	if r.taskDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKey", r.taskDefinitionKey, "")
	}
	if r.taskDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyIn", r.taskDefinitionKeyIn, "")
	}
	if r.taskDefinitionKeyNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyNotIn", r.taskDefinitionKeyNotIn, "")
	}
	if r.taskDefinitionKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyLike", r.taskDefinitionKeyLike, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameNotEqual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotEqual", r.nameNotEqual, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.nameNotLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotLike", r.nameNotLike, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionLike", r.descriptionLike, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	if r.maxPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPriority", r.maxPriority, "")
	}
	if r.minPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minPriority", r.minPriority, "")
	}
	if r.dueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDate", r.dueDate, "")
	}
	if r.dueDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDateExpression", r.dueDateExpression, "")
	}
	if r.dueAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfter", r.dueAfter, "")
	}
	if r.dueAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfterExpression", r.dueAfterExpression, "")
	}
	if r.dueBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBefore", r.dueBefore, "")
	}
	if r.dueBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBeforeExpression", r.dueBeforeExpression, "")
	}
	if r.withoutDueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDueDate", r.withoutDueDate, "")
	} else {
		var defaultValue bool = false
		r.withoutDueDate = &defaultValue
	}
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
	}
	if r.followUpDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDateExpression", r.followUpDateExpression, "")
	}
	if r.followUpAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfter", r.followUpAfter, "")
	}
	if r.followUpAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfterExpression", r.followUpAfterExpression, "")
	}
	if r.followUpBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBefore", r.followUpBefore, "")
	}
	if r.followUpBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeExpression", r.followUpBeforeExpression, "")
	}
	if r.followUpBeforeOrNotExistent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistent", r.followUpBeforeOrNotExistent, "")
	}
	if r.followUpBeforeOrNotExistentExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistentExpression", r.followUpBeforeOrNotExistentExpression, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.createdOnExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnExpression", r.createdOnExpression, "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "")
	}
	if r.createdAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfterExpression", r.createdAfterExpression, "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "")
	}
	if r.createdBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBeforeExpression", r.createdBeforeExpression, "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "")
	}
	if r.updatedAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfterExpression", r.updatedAfterExpression, "")
	}
	if r.delegationState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delegationState", r.delegationState, "")
	}
	if r.candidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroups", r.candidateGroups, "")
	}
	if r.candidateGroupsExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupsExpression", r.candidateGroupsExpression, "")
	}
	if r.withCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateGroups", r.withCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withCandidateGroups = &defaultValue
	}
	if r.withoutCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateGroups", r.withoutCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateGroups = &defaultValue
	}
	if r.withCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateUsers", r.withCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withCandidateUsers = &defaultValue
	}
	if r.withoutCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateUsers", r.withoutCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateUsers = &defaultValue
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	} else {
		var defaultValue bool = false
		r.active = &defaultValue
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	} else {
		var defaultValue bool = false
		r.suspended = &defaultValue
	}
	if r.taskVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskVariables", r.taskVariables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.caseInstanceVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceVariables", r.caseInstanceVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTaskId", r.parentTaskId, "")
	}
	if r.withCommentAttachmentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCommentAttachmentInfo", r.withCommentAttachmentInfo, "")
	} else {
		var defaultValue bool = false
		r.withCommentAttachmentInfo = &defaultValue
	}
	if r.withTaskVariablesInReturn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withTaskVariablesInReturn", r.withTaskVariablesInReturn, "")
	} else {
		var defaultValue bool = false
		r.withTaskVariablesInReturn = &defaultValue
	}
	if r.withTaskLocalVariablesInReturn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withTaskLocalVariablesInReturn", r.withTaskLocalVariablesInReturn, "")
	} else {
		var defaultValue bool = false
		r.withTaskLocalVariablesInReturn = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksCountRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	taskId *string
	taskIdIn *string
	processInstanceId *string
	processInstanceIdIn *string
	processInstanceBusinessKey *string
	processInstanceBusinessKeyExpression *string
	processInstanceBusinessKeyIn *string
	processInstanceBusinessKeyLike *string
	processInstanceBusinessKeyLikeExpression *string
	processDefinitionId *string
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	executionId *string
	caseInstanceId *string
	caseInstanceBusinessKey *string
	caseInstanceBusinessKeyLike *string
	caseDefinitionId *string
	caseDefinitionKey *string
	caseDefinitionName *string
	caseDefinitionNameLike *string
	caseExecutionId *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	assignee *string
	assigneeExpression *string
	assigneeLike *string
	assigneeLikeExpression *string
	assigneeIn *string
	assigneeNotIn *string
	owner *string
	ownerExpression *string
	candidateGroup *string
	candidateGroupLike *string
	candidateGroupExpression *string
	candidateUser *string
	candidateUserExpression *string
	includeAssignedTasks *bool
	involvedUser *string
	involvedUserExpression *string
	assigned *bool
	unassigned *bool
	taskDefinitionKey *string
	taskDefinitionKeyIn *string
	taskDefinitionKeyNotIn *string
	taskDefinitionKeyLike *string
	name *string
	nameNotEqual *string
	nameLike *string
	nameNotLike *string
	description *string
	descriptionLike *string
	priority *int32
	maxPriority *int32
	minPriority *int32
	dueDate *string
	dueDateExpression *string
	dueAfter *string
	dueAfterExpression *string
	dueBefore *string
	dueBeforeExpression *string
	withoutDueDate *bool
	followUpDate *string
	followUpDateExpression *string
	followUpAfter *string
	followUpAfterExpression *string
	followUpBefore *string
	followUpBeforeExpression *string
	followUpBeforeOrNotExistent *string
	followUpBeforeOrNotExistentExpression *string
	createdOn *string
	createdOnExpression *string
	createdAfter *string
	createdAfterExpression *string
	createdBefore *string
	createdBeforeExpression *string
	updatedAfter *string
	updatedAfterExpression *string
	delegationState *string
	candidateGroups *string
	candidateGroupsExpression *string
	withCandidateGroups *bool
	withoutCandidateGroups *bool
	withCandidateUsers *bool
	withoutCandidateUsers *bool
	active *bool
	suspended *bool
	taskVariables *string
	processVariables *string
	caseInstanceVariables *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	parentTaskId *string
	withCommentAttachmentInfo *bool
	withTaskVariablesInReturn *bool
	withTaskLocalVariablesInReturn *bool
}

// Restrict to task with the given id.
func (r ApiGetTasksCountRequest) TaskId(taskId string) ApiGetTasksCountRequest {
	r.taskId = &taskId
	return r
}

// Restrict to tasks with any of the given ids.
func (r ApiGetTasksCountRequest) TaskIdIn(taskIdIn string) ApiGetTasksCountRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given id.
func (r ApiGetTasksCountRequest) ProcessInstanceId(processInstanceId string) ApiGetTasksCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restrict to tasks that belong to process instances with the given ids.
func (r ApiGetTasksCountRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetTasksCountRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given business key.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKey(processInstanceBusinessKey string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKey = &processInstanceBusinessKey
	return r
}

// Restrict to tasks that belong to process instances with the given business key which is described by an expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyExpression(processInstanceBusinessKeyExpression string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyExpression = &processInstanceBusinessKeyExpression
	return r
}

// Restrict to tasks that belong to process instances with one of the give business keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyIn(processInstanceBusinessKeyIn string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyIn = &processInstanceBusinessKeyIn
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyLike(processInstanceBusinessKeyLike string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyLike = &processInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter value as a substring and is described by an expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyLikeExpression(processInstanceBusinessKeyLikeExpression string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyLikeExpression = &processInstanceBusinessKeyLikeExpression
	return r
}

// Restrict to tasks that belong to a process definition with the given id.
func (r ApiGetTasksCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetTasksCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetTasksCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetTasksCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetTasksCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetTasksCountRequest) ProcessDefinitionName(processDefinitionName string) ApiGetTasksCountRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetTasksCountRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Restrict to tasks that belong to an execution with the given id.
func (r ApiGetTasksCountRequest) ExecutionId(executionId string) ApiGetTasksCountRequest {
	r.executionId = &executionId
	return r
}

// Restrict to tasks that belong to case instances with the given id.
func (r ApiGetTasksCountRequest) CaseInstanceId(caseInstanceId string) ApiGetTasksCountRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Restrict to tasks that belong to case instances with the given business key.
func (r ApiGetTasksCountRequest) CaseInstanceBusinessKey(caseInstanceBusinessKey string) ApiGetTasksCountRequest {
	r.caseInstanceBusinessKey = &caseInstanceBusinessKey
	return r
}

// Restrict to tasks that have a case instance business key that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) CaseInstanceBusinessKeyLike(caseInstanceBusinessKeyLike string) ApiGetTasksCountRequest {
	r.caseInstanceBusinessKeyLike = &caseInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that belong to a case definition with the given id.
func (r ApiGetTasksCountRequest) CaseDefinitionId(caseDefinitionId string) ApiGetTasksCountRequest {
	r.caseDefinitionId = &caseDefinitionId
	return r
}

// Restrict to tasks that belong to a case definition with the given key.
func (r ApiGetTasksCountRequest) CaseDefinitionKey(caseDefinitionKey string) ApiGetTasksCountRequest {
	r.caseDefinitionKey = &caseDefinitionKey
	return r
}

// Restrict to tasks that belong to a case definition with the given name.
func (r ApiGetTasksCountRequest) CaseDefinitionName(caseDefinitionName string) ApiGetTasksCountRequest {
	r.caseDefinitionName = &caseDefinitionName
	return r
}

// Restrict to tasks that have a case definition name that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) CaseDefinitionNameLike(caseDefinitionNameLike string) ApiGetTasksCountRequest {
	r.caseDefinitionNameLike = &caseDefinitionNameLike
	return r
}

// Restrict to tasks that belong to a case execution with the given id.
func (r ApiGetTasksCountRequest) CaseExecutionId(caseExecutionId string) ApiGetTasksCountRequest {
	r.caseExecutionId = &caseExecutionId
	return r
}

// Only include tasks which belong to one of the passed and comma-separated activity instance ids.
func (r ApiGetTasksCountRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetTasksCountRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include tasks which belong to one of the passed and comma-separated tenant ids.
func (r ApiGetTasksCountRequest) TenantIdIn(tenantIdIn string) ApiGetTasksCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetTasksCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Restrict to tasks that the given user is assigned to.
func (r ApiGetTasksCountRequest) Assignee(assignee string) ApiGetTasksCountRequest {
	r.assignee = &assignee
	return r
}

// Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) AssigneeExpression(assigneeExpression string) ApiGetTasksCountRequest {
	r.assigneeExpression = &assigneeExpression
	return r
}

// Restrict to tasks that have an assignee that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) AssigneeLike(assigneeLike string) ApiGetTasksCountRequest {
	r.assigneeLike = &assigneeLike
	return r
}

// Restrict to tasks that have an assignee that has the parameter value described by the given expression as a substring. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) AssigneeLikeExpression(assigneeLikeExpression string) ApiGetTasksCountRequest {
	r.assigneeLikeExpression = &assigneeLikeExpression
	return r
}

// Only include tasks which are assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksCountRequest) AssigneeIn(assigneeIn string) ApiGetTasksCountRequest {
	r.assigneeIn = &assigneeIn
	return r
}

// Only include tasks which are not assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksCountRequest) AssigneeNotIn(assigneeNotIn string) ApiGetTasksCountRequest {
	r.assigneeNotIn = &assigneeNotIn
	return r
}

// Restrict to tasks that the given user owns.
func (r ApiGetTasksCountRequest) Owner(owner string) ApiGetTasksCountRequest {
	r.owner = &owner
	return r
}

// Restrict to tasks that the user described by the given expression owns. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) OwnerExpression(ownerExpression string) ApiGetTasksCountRequest {
	r.ownerExpression = &ownerExpression
	return r
}

// Only include tasks that are offered to the given group.
func (r ApiGetTasksCountRequest) CandidateGroup(candidateGroup string) ApiGetTasksCountRequest {
	r.candidateGroup = &candidateGroup
	return r
}

// Only include tasks that are offered to groups that have the parameter value as a substring.
func (r ApiGetTasksCountRequest) CandidateGroupLike(candidateGroupLike string) ApiGetTasksCountRequest {
	r.candidateGroupLike = &candidateGroupLike
	return r
}

// Only include tasks that are offered to the group described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) CandidateGroupExpression(candidateGroupExpression string) ApiGetTasksCountRequest {
	r.candidateGroupExpression = &candidateGroupExpression
	return r
}

// Only include tasks that are offered to the given user or to one of his groups.
func (r ApiGetTasksCountRequest) CandidateUser(candidateUser string) ApiGetTasksCountRequest {
	r.candidateUser = &candidateUser
	return r
}

// Only include tasks that are offered to the user described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) CandidateUserExpression(candidateUserExpression string) ApiGetTasksCountRequest {
	r.candidateUserExpression = &candidateUserExpression
	return r
}

// Also include tasks that are assigned to users in candidate queries. Default is to only include tasks that are not assigned to any user if you query by candidate user or group(s).
func (r ApiGetTasksCountRequest) IncludeAssignedTasks(includeAssignedTasks bool) ApiGetTasksCountRequest {
	r.includeAssignedTasks = &includeAssignedTasks
	return r
}

// Only include tasks that the given user is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee).
func (r ApiGetTasksCountRequest) InvolvedUser(involvedUser string) ApiGetTasksCountRequest {
	r.involvedUser = &involvedUser
	return r
}

// Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) InvolvedUserExpression(involvedUserExpression string) ApiGetTasksCountRequest {
	r.involvedUserExpression = &involvedUserExpression
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
func (r ApiGetTasksCountRequest) Assigned(assigned bool) ApiGetTasksCountRequest {
	r.assigned = &assigned
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
func (r ApiGetTasksCountRequest) Unassigned(unassigned bool) ApiGetTasksCountRequest {
	r.unassigned = &unassigned
	return r
}

// Restrict to tasks that have the given key.
func (r ApiGetTasksCountRequest) TaskDefinitionKey(taskDefinitionKey string) ApiGetTasksCountRequest {
	r.taskDefinitionKey = &taskDefinitionKey
	return r
}

// Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) TaskDefinitionKeyIn(taskDefinitionKeyIn string) ApiGetTasksCountRequest {
	r.taskDefinitionKeyIn = &taskDefinitionKeyIn
	return r
}

// Exclude instances by a list of task definition keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) TaskDefinitionKeyNotIn(taskDefinitionKeyNotIn string) ApiGetTasksCountRequest {
	r.taskDefinitionKeyNotIn = &taskDefinitionKeyNotIn
	return r
}

// Restrict to tasks that have a key that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) TaskDefinitionKeyLike(taskDefinitionKeyLike string) ApiGetTasksCountRequest {
	r.taskDefinitionKeyLike = &taskDefinitionKeyLike
	return r
}

// Restrict to tasks that have the given name.
func (r ApiGetTasksCountRequest) Name(name string) ApiGetTasksCountRequest {
	r.name = &name
	return r
}

// Restrict to tasks that do not have the given name.
func (r ApiGetTasksCountRequest) NameNotEqual(nameNotEqual string) ApiGetTasksCountRequest {
	r.nameNotEqual = &nameNotEqual
	return r
}

// Restrict to tasks that have a name with the given parameter value as substring.
func (r ApiGetTasksCountRequest) NameLike(nameLike string) ApiGetTasksCountRequest {
	r.nameLike = &nameLike
	return r
}

// Restrict to tasks that do not have a name with the given parameter value as substring.
func (r ApiGetTasksCountRequest) NameNotLike(nameNotLike string) ApiGetTasksCountRequest {
	r.nameNotLike = &nameNotLike
	return r
}

// Restrict to tasks that have the given description.
func (r ApiGetTasksCountRequest) Description(description string) ApiGetTasksCountRequest {
	r.description = &description
	return r
}

// Restrict to tasks that have a description that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) DescriptionLike(descriptionLike string) ApiGetTasksCountRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// Restrict to tasks that have the given priority.
func (r ApiGetTasksCountRequest) Priority(priority int32) ApiGetTasksCountRequest {
	r.priority = &priority
	return r
}

// Restrict to tasks that have a lower or equal priority.
func (r ApiGetTasksCountRequest) MaxPriority(maxPriority int32) ApiGetTasksCountRequest {
	r.maxPriority = &maxPriority
	return r
}

// Restrict to tasks that have a higher or equal priority.
func (r ApiGetTasksCountRequest) MinPriority(minPriority int32) ApiGetTasksCountRequest {
	r.minPriority = &minPriority
	return r
}

// Restrict to tasks that are due on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetTasksCountRequest) DueDate(dueDate string) ApiGetTasksCountRequest {
	r.dueDate = &dueDate
	return r
}

// Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueDateExpression(dueDateExpression string) ApiGetTasksCountRequest {
	r.dueDateExpression = &dueDateExpression
	return r
}

// Restrict to tasks that are due after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
func (r ApiGetTasksCountRequest) DueAfter(dueAfter string) ApiGetTasksCountRequest {
	r.dueAfter = &dueAfter
	return r
}

// Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueAfterExpression(dueAfterExpression string) ApiGetTasksCountRequest {
	r.dueAfterExpression = &dueAfterExpression
	return r
}

// Restrict to tasks that are due before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
func (r ApiGetTasksCountRequest) DueBefore(dueBefore string) ApiGetTasksCountRequest {
	r.dueBefore = &dueBefore
	return r
}

// Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueBeforeExpression(dueBeforeExpression string) ApiGetTasksCountRequest {
	r.dueBeforeExpression = &dueBeforeExpression
	return r
}

// Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutDueDate(withoutDueDate bool) ApiGetTasksCountRequest {
	r.withoutDueDate = &withoutDueDate
	return r
}

// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpDate(followUpDate string) ApiGetTasksCountRequest {
	r.followUpDate = &followUpDate
	return r
}

// Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpDateExpression(followUpDateExpression string) ApiGetTasksCountRequest {
	r.followUpDateExpression = &followUpDateExpression
	return r
}

// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpAfter(followUpAfter string) ApiGetTasksCountRequest {
	r.followUpAfter = &followUpAfter
	return r
}

// Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpAfterExpression(followUpAfterExpression string) ApiGetTasksCountRequest {
	r.followUpAfterExpression = &followUpAfterExpression
	return r
}

// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpBefore(followUpBefore string) ApiGetTasksCountRequest {
	r.followUpBefore = &followUpBefore
	return r
}

// Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpBeforeExpression(followUpBeforeExpression string) ApiGetTasksCountRequest {
	r.followUpBeforeExpression = &followUpBeforeExpression
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
func (r ApiGetTasksCountRequest) FollowUpBeforeOrNotExistent(followUpBeforeOrNotExistent string) ApiGetTasksCountRequest {
	r.followUpBeforeOrNotExistent = &followUpBeforeOrNotExistent
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpBeforeOrNotExistentExpression(followUpBeforeOrNotExistentExpression string) ApiGetTasksCountRequest {
	r.followUpBeforeOrNotExistentExpression = &followUpBeforeOrNotExistentExpression
	return r
}

// Restrict to tasks that were created on the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedOn(createdOn string) ApiGetTasksCountRequest {
	r.createdOn = &createdOn
	return r
}

// Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedOnExpression(createdOnExpression string) ApiGetTasksCountRequest {
	r.createdOnExpression = &createdOnExpression
	return r
}

// Restrict to tasks that were created after the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedAfter(createdAfter string) ApiGetTasksCountRequest {
	r.createdAfter = &createdAfter
	return r
}

// Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedAfterExpression(createdAfterExpression string) ApiGetTasksCountRequest {
	r.createdAfterExpression = &createdAfterExpression
	return r
}

// Restrict to tasks that were created before the given date. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedBefore(createdBefore string) ApiGetTasksCountRequest {
	r.createdBefore = &createdBefore
	return r
}

// Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedBeforeExpression(createdBeforeExpression string) ApiGetTasksCountRequest {
	r.createdBeforeExpression = &createdBeforeExpression
	return r
}

// Restrict to tasks that were updated after the given date. Every action that fires a [task update event](https://docs.operaton.org/manual/1.0/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.operaton.org/manual/1.0/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksCountRequest) UpdatedAfter(updatedAfter string) ApiGetTasksCountRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Restrict to tasks that were updated after the date described by the given expression. Every action that fires a [task update event](https://docs.operaton.org/manual/1.0/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) UpdatedAfterExpression(updatedAfterExpression string) ApiGetTasksCountRequest {
	r.updatedAfterExpression = &updatedAfterExpression
	return r
}

// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
func (r ApiGetTasksCountRequest) DelegationState(delegationState string) ApiGetTasksCountRequest {
	r.delegationState = &delegationState
	return r
}

// Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
func (r ApiGetTasksCountRequest) CandidateGroups(candidateGroups string) ApiGetTasksCountRequest {
	r.candidateGroups = &candidateGroups
	return r
}

// Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.operaton.org/manual/1.0/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
func (r ApiGetTasksCountRequest) CandidateGroupsExpression(candidateGroupsExpression string) ApiGetTasksCountRequest {
	r.candidateGroupsExpression = &candidateGroupsExpression
	return r
}

// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithCandidateGroups(withCandidateGroups bool) ApiGetTasksCountRequest {
	r.withCandidateGroups = &withCandidateGroups
	return r
}

// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutCandidateGroups(withoutCandidateGroups bool) ApiGetTasksCountRequest {
	r.withoutCandidateGroups = &withoutCandidateGroups
	return r
}

// Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithCandidateUsers(withCandidateUsers bool) ApiGetTasksCountRequest {
	r.withCandidateUsers = &withCandidateUsers
	return r
}

// Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutCandidateUsers(withoutCandidateUsers bool) ApiGetTasksCountRequest {
	r.withoutCandidateUsers = &withoutCandidateUsers
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) Active(active bool) ApiGetTasksCountRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) Suspended(suspended bool) ApiGetTasksCountRequest {
	r.suspended = &suspended
	return r
}

// Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) TaskVariables(taskVariables string) ApiGetTasksCountRequest {
	r.taskVariables = &taskVariables
	return r
}

// Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) ProcessVariables(processVariables string) ApiGetTasksCountRequest {
	r.processVariables = &processVariables
	return r
}

// Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) CaseInstanceVariables(caseInstanceVariables string) ApiGetTasksCountRequest {
	r.caseInstanceVariables = &caseInstanceVariables
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetTasksCountRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetTasksCountRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetTasksCountRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetTasksCountRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
func (r ApiGetTasksCountRequest) ParentTaskId(parentTaskId string) ApiGetTasksCountRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Check if task has attachments and/or comments. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. Adding the filter will do additional attachment and comments queries to the database, it might slow down the query in case of tables having high volume of data. This param is not considered for count queries
func (r ApiGetTasksCountRequest) WithCommentAttachmentInfo(withCommentAttachmentInfo bool) ApiGetTasksCountRequest {
	r.withCommentAttachmentInfo = &withCommentAttachmentInfo
	return r
}

// Indicates if all the variables visible from task should be retrieved. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithTaskVariablesInReturn(withTaskVariablesInReturn bool) ApiGetTasksCountRequest {
	r.withTaskVariablesInReturn = &withTaskVariablesInReturn
	return r
}

// Indicates if all the local variables visible from task should be retrieved. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithTaskLocalVariablesInReturn(withTaskLocalVariablesInReturn bool) ApiGetTasksCountRequest {
	r.withTaskLocalVariablesInReturn = &withTaskLocalVariablesInReturn
	return r
}

func (r ApiGetTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetTasksCountExecute(r)
}

/*
GetTasksCount Get List Count

Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size
of the result set when using the [Get Tasks](https://docs.operaton.org/manual/1.0/reference/rest/task/) method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.operaton.org/manual/1.0/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTasksCountRequest
*/
func (a *TaskAPIService) GetTasksCount(ctx context.Context) ApiGetTasksCountRequest {
	return ApiGetTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *TaskAPIService) GetTasksCountExecute(r ApiGetTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKey", r.processInstanceBusinessKey, "")
	}
	if r.processInstanceBusinessKeyExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyExpression", r.processInstanceBusinessKeyExpression, "")
	}
	if r.processInstanceBusinessKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyIn", r.processInstanceBusinessKeyIn, "")
	}
	if r.processInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLike", r.processInstanceBusinessKeyLike, "")
	}
	if r.processInstanceBusinessKeyLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLikeExpression", r.processInstanceBusinessKeyLikeExpression, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKey", r.caseInstanceBusinessKey, "")
	}
	if r.caseInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKeyLike", r.caseInstanceBusinessKeyLike, "")
	}
	if r.caseDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionId", r.caseDefinitionId, "")
	}
	if r.caseDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionKey", r.caseDefinitionKey, "")
	}
	if r.caseDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionName", r.caseDefinitionName, "")
	}
	if r.caseDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionNameLike", r.caseDefinitionNameLike, "")
	}
	if r.caseExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionId", r.caseExecutionId, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "")
	}
	if r.assigneeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeExpression", r.assigneeExpression, "")
	}
	if r.assigneeLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLike", r.assigneeLike, "")
	}
	if r.assigneeLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLikeExpression", r.assigneeLikeExpression, "")
	}
	if r.assigneeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeIn", r.assigneeIn, "")
	}
	if r.assigneeNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeNotIn", r.assigneeNotIn, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.ownerExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExpression", r.ownerExpression, "")
	}
	if r.candidateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroup", r.candidateGroup, "")
	}
	if r.candidateGroupLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupLike", r.candidateGroupLike, "")
	}
	if r.candidateGroupExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupExpression", r.candidateGroupExpression, "")
	}
	if r.candidateUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUser", r.candidateUser, "")
	}
	if r.candidateUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUserExpression", r.candidateUserExpression, "")
	}
	if r.includeAssignedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssignedTasks", r.includeAssignedTasks, "")
	} else {
		var defaultValue bool = false
		r.includeAssignedTasks = &defaultValue
	}
	if r.involvedUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUser", r.involvedUser, "")
	}
	if r.involvedUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUserExpression", r.involvedUserExpression, "")
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	} else {
		var defaultValue bool = false
		r.assigned = &defaultValue
	}
	if r.unassigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassigned", r.unassigned, "")
	} else {
		var defaultValue bool = false
		r.unassigned = &defaultValue
	}
	if r.taskDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKey", r.taskDefinitionKey, "")
	}
	if r.taskDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyIn", r.taskDefinitionKeyIn, "")
	}
	if r.taskDefinitionKeyNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyNotIn", r.taskDefinitionKeyNotIn, "")
	}
	if r.taskDefinitionKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyLike", r.taskDefinitionKeyLike, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameNotEqual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotEqual", r.nameNotEqual, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.nameNotLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotLike", r.nameNotLike, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionLike", r.descriptionLike, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	if r.maxPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPriority", r.maxPriority, "")
	}
	if r.minPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minPriority", r.minPriority, "")
	}
	if r.dueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDate", r.dueDate, "")
	}
	if r.dueDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDateExpression", r.dueDateExpression, "")
	}
	if r.dueAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfter", r.dueAfter, "")
	}
	if r.dueAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfterExpression", r.dueAfterExpression, "")
	}
	if r.dueBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBefore", r.dueBefore, "")
	}
	if r.dueBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBeforeExpression", r.dueBeforeExpression, "")
	}
	if r.withoutDueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDueDate", r.withoutDueDate, "")
	} else {
		var defaultValue bool = false
		r.withoutDueDate = &defaultValue
	}
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
	}
	if r.followUpDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDateExpression", r.followUpDateExpression, "")
	}
	if r.followUpAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfter", r.followUpAfter, "")
	}
	if r.followUpAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfterExpression", r.followUpAfterExpression, "")
	}
	if r.followUpBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBefore", r.followUpBefore, "")
	}
	if r.followUpBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeExpression", r.followUpBeforeExpression, "")
	}
	if r.followUpBeforeOrNotExistent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistent", r.followUpBeforeOrNotExistent, "")
	}
	if r.followUpBeforeOrNotExistentExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistentExpression", r.followUpBeforeOrNotExistentExpression, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.createdOnExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnExpression", r.createdOnExpression, "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "")
	}
	if r.createdAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfterExpression", r.createdAfterExpression, "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "")
	}
	if r.createdBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBeforeExpression", r.createdBeforeExpression, "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "")
	}
	if r.updatedAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfterExpression", r.updatedAfterExpression, "")
	}
	if r.delegationState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delegationState", r.delegationState, "")
	}
	if r.candidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroups", r.candidateGroups, "")
	}
	if r.candidateGroupsExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupsExpression", r.candidateGroupsExpression, "")
	}
	if r.withCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateGroups", r.withCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withCandidateGroups = &defaultValue
	}
	if r.withoutCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateGroups", r.withoutCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateGroups = &defaultValue
	}
	if r.withCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateUsers", r.withCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withCandidateUsers = &defaultValue
	}
	if r.withoutCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateUsers", r.withoutCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateUsers = &defaultValue
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	} else {
		var defaultValue bool = false
		r.active = &defaultValue
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	} else {
		var defaultValue bool = false
		r.suspended = &defaultValue
	}
	if r.taskVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskVariables", r.taskVariables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.caseInstanceVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceVariables", r.caseInstanceVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTaskId", r.parentTaskId, "")
	}
	if r.withCommentAttachmentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCommentAttachmentInfo", r.withCommentAttachmentInfo, "")
	} else {
		var defaultValue bool = false
		r.withCommentAttachmentInfo = &defaultValue
	}
	if r.withTaskVariablesInReturn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withTaskVariablesInReturn", r.withTaskVariablesInReturn, "")
	} else {
		var defaultValue bool = false
		r.withTaskVariablesInReturn = &defaultValue
	}
	if r.withTaskLocalVariablesInReturn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withTaskLocalVariablesInReturn", r.withTaskLocalVariablesInReturn, "")
	} else {
		var defaultValue bool = false
		r.withTaskLocalVariablesInReturn = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHandleBpmnErrorRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	taskBpmnErrorDto *TaskBpmnErrorDto
}

func (r ApiHandleBpmnErrorRequest) TaskBpmnErrorDto(taskBpmnErrorDto TaskBpmnErrorDto) ApiHandleBpmnErrorRequest {
	r.taskBpmnErrorDto = &taskBpmnErrorDto
	return r
}

func (r ApiHandleBpmnErrorRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleBpmnErrorExecute(r)
}

/*
HandleBpmnError Handle BPMN Error

Reports a business error in the context of a running task by id. The error code must
be specified to identify the BPMN error handler. See the documentation for
[Reporting Bpmn Error](https://docs.operaton.org/manual/1.0/reference/bpmn20/tasks/user-task/#reporting-bpmn-error)
in User Tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task a BPMN error is reported for.
 @return ApiHandleBpmnErrorRequest
*/
func (a *TaskAPIService) HandleBpmnError(ctx context.Context, id string) ApiHandleBpmnErrorRequest {
	return ApiHandleBpmnErrorRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) HandleBpmnErrorExecute(r ApiHandleBpmnErrorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.HandleBpmnError")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/bpmnError"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskBpmnErrorDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiHandleEscalationRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	taskEscalationDto *TaskEscalationDto
}

func (r ApiHandleEscalationRequest) TaskEscalationDto(taskEscalationDto TaskEscalationDto) ApiHandleEscalationRequest {
	r.taskEscalationDto = &taskEscalationDto
	return r
}

func (r ApiHandleEscalationRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleEscalationExecute(r)
}

/*
HandleEscalation Handle BPMN Escalation

Reports an escalation in the context of a running task by id. The escalation code must
be specified to identify the escalation handler. See the documentation for
[Reporting Bpmn Escalation](https://docs.operaton.org/manual/1.0/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation)
in User Tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task in which context a BPMN escalation is reported.
 @return ApiHandleEscalationRequest
*/
func (a *TaskAPIService) HandleEscalation(ctx context.Context, id string) ApiHandleEscalationRequest {
	return ApiHandleEscalationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) HandleEscalationExecute(r ApiHandleEscalationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.HandleEscalation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/bpmnEscalation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskEscalationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryTasksRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	firstResult *int32
	maxResults *int32
	taskQueryDto *TaskQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryTasksRequest) FirstResult(firstResult int32) ApiQueryTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryTasksRequest) MaxResults(maxResults int32) ApiQueryTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryTasksRequest) TaskQueryDto(taskQueryDto TaskQueryDto) ApiQueryTasksRequest {
	r.taskQueryDto = &taskQueryDto
	return r
}

func (r ApiQueryTasksRequest) Execute() ([]TaskWithAttachmentAndCommentDto, *http.Response, error) {
	return r.ApiService.QueryTasksExecute(r)
}

/*
QueryTasks Get List (POST)

Queries for tasks that fulfill a given filter. This method is slightly more powerful
than the [Get Tasks](https://docs.operaton.org/manual/1.0/reference/rest/task/get-query/) method because it
allows filtering by multiple process or task variables of types `String`, `Number`
or `Boolean`. The size of the result set can be retrieved by using the
[Get Task Count (POST)](https://docs.operaton.org/manual/1.0/reference/rest/task/post-query-count/) method.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.operaton.org/manual/1.0/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTasksRequest
*/
func (a *TaskAPIService) QueryTasks(ctx context.Context) ApiQueryTasksRequest {
	return ApiQueryTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskWithAttachmentAndCommentDto
func (a *TaskAPIService) QueryTasksExecute(r ApiQueryTasksRequest) ([]TaskWithAttachmentAndCommentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskWithAttachmentAndCommentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.QueryTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryTasksCountRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	taskQueryDto *TaskQueryDto
}

func (r ApiQueryTasksCountRequest) TaskQueryDto(taskQueryDto TaskQueryDto) ApiQueryTasksCountRequest {
	r.taskQueryDto = &taskQueryDto
	return r
}

func (r ApiQueryTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryTasksCountExecute(r)
}

/*
QueryTasksCount Get List Count (POST)

Retrieves the number of tasks that fulfill the given filter. Corresponds to the size
of the result set of the [Get Tasks (POST)](https://docs.operaton.org/manual/1.0/reference/rest/task/post-query/)
method and takes the same parameters.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.operaton.org/manual/1.0/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTasksCountRequest
*/
func (a *TaskAPIService) QueryTasksCount(ctx context.Context) ApiQueryTasksCountRequest {
	return ApiQueryTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *TaskAPIService) QueryTasksCountExecute(r ApiQueryTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.QueryTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiResolveRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiResolveRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiResolveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResolveExecute(r)
}

/*
Resolve Resolve

Resolves a task and updates execution variables.

Resolving a task marks that the assignee is done with the task delegated to them, and
that it can be sent back to the owner. Can only be executed when the task has been
delegated. The assignee will be set to the owner, who performed the delegation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to resolve.
 @return ApiResolveRequest
*/
func (a *TaskAPIService) Resolve(ctx context.Context, id string) ApiResolveRequest {
	return ApiResolveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) ResolveExecute(r ApiResolveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Resolve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetAssigneeRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that will be the assignee of the task.
func (r ApiSetAssigneeRequest) UserIdDto(userIdDto UserIdDto) ApiSetAssigneeRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiSetAssigneeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAssigneeExecute(r)
}

/*
SetAssignee Set Assignee

Changes the assignee of a task to a specific user.

**Note:** The difference with the [Claim Task](https://docs.operaton.org/manual/1.0/reference/rest/task/post-claim/)
method is that this method does not check if the task already has a user
assigned to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to set the assignee for.
 @return ApiSetAssigneeRequest
*/
func (a *TaskAPIService) SetAssignee(ctx context.Context, id string) ApiSetAssigneeRequest {
	return ApiSetAssigneeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) SetAssigneeExecute(r ApiSetAssigneeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.SetAssignee")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/assignee"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiSubmitRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiSubmitRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiSubmitRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.SubmitExecute(r)
}

/*
Submit Submit Form

Completes a task and updates process variables using a form submit. There are two
difference between this method and the `complete` method:

* If the task is in state `PENDING` - i.e., has been delegated before, it is not
completed but resolved. Otherwise it will be completed.
* If the task has Form Field Metadata defined, the process engine will perform backend
validation for any form fields which have validators defined.
See the
[Generated Task Forms](https://docs.operaton.org/manual/1.0/user-guide/task-forms/_index/#generated-task-forms)
section of the [User Guide](https://docs.operaton.org/manual/1.0/user-guide/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to submit the form for.
 @return ApiSubmitRequest
*/
func (a *TaskAPIService) Submit(ctx context.Context, id string) ApiSubmitRequest {
	return ApiSubmitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) SubmitExecute(r ApiSubmitRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Submit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/submit-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnclaimRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
}

func (r ApiUnclaimRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnclaimExecute(r)
}

/*
Unclaim Unclaim

Resets a task's assignee. If successful, the task is not assigned to a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to unclaim.
 @return ApiUnclaimRequest
*/
func (a *TaskAPIService) Unclaim(ctx context.Context, id string) ApiUnclaimRequest {
	return ApiUnclaimRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) UnclaimExecute(r ApiUnclaimRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Unclaim")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/unclaim"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTaskRequest struct {
	ctx context.Context
	ApiService *TaskAPIService
	id string
	taskDto *TaskDto
}

func (r ApiUpdateTaskRequest) TaskDto(taskDto TaskDto) ApiUpdateTaskRequest {
	r.taskDto = &taskDto
	return r
}

func (r ApiUpdateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTaskExecute(r)
}

/*
UpdateTask Update

Updates a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be updated.
 @return ApiUpdateTaskRequest
*/
func (a *TaskAPIService) UpdateTask(ctx context.Context, id string) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) UpdateTaskExecute(r ApiUpdateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.UpdateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
