#o8n — Specification

This document specifies the o8n terminal UI application (written in Go). It fully describes the architecture, data models, UI layout and behavior, configuration files, API interactions, error handling, and tests. The intent is that a developer or an AI coder can reimplement the same structure and behavior from this specification.

## High-level summary

- Language: Go (>= 1.24).
- Primary runtime library: Charmbracelet ecosystem (bubbletea, bubbles, lipgloss).
- Function: Provide a terminal UI to browse and operate on resources exposed by an Operaton/engine-rest API (process definitions, instances, variables, tasks, jobs, etc.).
- The application should have a similar look & feel like k9s (layout, keyboard usage)
- Use the Operaton REST API

## Repository layout (conceptual)

- main.go — main application, model, update/view, UI wiring.
- api.go — HTTP client wrapper code that uses the generated OpenAPI client to interact with Operaton engine-rest endpoints.
- internal/operaton/ — Generated OpenAPI client code from resources/operaton-rest-api.json (generated by .devenv/scripts/generate-api-client.sh).
- config.go — config loading/saving for environment and app config.
- o8n-env.yaml.example — example environment file with ui_color and credentials (sensitive, do not commit real secrets).
- o8n-env.yaml (runtime) — environment configuration (kept out of source control).
- o8n-cfg.yaml — application-level configuration (table definitions, column specs).
- resources/operaton-rest-api.json — OpenAPI / swagger reference used to derive root contexts and generate the Go client.
- .devenv/scripts/generate-api-client.sh — Script to generate the Go client from the OpenAPI specification using OpenAPI Generator.
- tests (go test unit tests) — exercises config load and API client behaviours.

# UX
- Important UX rules:
  - Vertical layout: Header (8 rows) -> Context selection (1 row boxed, dynamic) -> Main content (boxed table filling remaining height minus footer) -> Footer (1 row).
  - Default environment: "local" (if present) or first configured environment.
  - Default root context at start: process-definitions.
  - Context selection opened with `:`; offers inline completion (only after first char); Tab completes; Enter switches only on exact match; Esc cancels.
  - Drill-down interaction: definitions -> instances -> variables (name, value, type). Arrow keys move selection; Enter drills in; Esc goes back.
- Tables:
  - Selected rows are inverted in their colours, i.e. the font color becomes the background color and vice versa
- Context switch
  - By key ':' a context section is opened between Header and Main Content section
  - The section is 1 line boxed, i.e. 3 lines with the border
  - The Main Content section shrinks by 3 lines while the Context switch is open
  - Keyboard focus is on the Context Switch line
  - Content assist:
- Footer
  - Breadbrump
    - At the left a breadcrumb-like context tag is shown, e.g. "<process-definition>" or "<process-instance>" to indicate the current root context.
    - The breadcrump can have at most 3 sections
    - Each section has a different background color
  - Remote access indicator:
    - A flash indicator (⚡) appears on the bottom-right for 0.2s whenever a remote REST call is issued.
- Responsive design:
  - The layout reacts on resizing of terminal
  - Sections
    - All vertical sections have fixed height except for the Main Content
  - Tables:
    - Columns can shrink to the size of their title plus 1 space
    - Column content gets abbreviated by "..." when the content is larger than the available space
    - Columns can be hidden when the remaining width does not allow all columns to be displayed
    - Columns that cannot be hidden are marked their configuration
- Global actions:
  - `:`: Opens the Context Switch dialog
  - `<ctrl>+c`: Exit
  - `?`: Display help
- Styling:
  - Colors:
    - Files in the folder /skins define color schemes for the UI. 
    - The active skin is defined in the environment configuration (o8n-env.yaml) and can be switched at runtime 

- Modal confirmation:
  - Actions that require confirmation are triggering a modal confirmation dialog

# Architecture and major components

## Program model (main.go)
   - Uses the Bubble Tea model pattern with Init, Update, and View.
   - Model fields include:
     - config *Config — compatibility view combining environment and table definitions.
     - envConfig *EnvConfig and appConfig *AppConfig — split configs;
     - UI components: bubbles list.Model (for a list-based view) and bubbles table.Model for the main table.
     - UI state: currentEnv, envNames, currentRoot (root context like `process-definition`), viewMode ("definitions","instances","variables"), selectedInstanceID, autoRefresh, flashActive, footerError, showRootPopup, rootInput.
     - Layout sizing: lastWidth/lastHeight, paneWidth/paneHeight.
   - Main event loop reacts to key presses and window size messages. It orchestrates API fetch commands and updates the table/list state.

## Data model (Go structs used by the API client)
- Environment { URL, Username, Password, UIColor }
- ColumnDef { Name, Visible bool, Width string, Align string }
- TableDef { Name string, DisplayName string, Columns []ColumnDef }
- EnvConfig { Environments map[string]Environment, Active string }
- AppConfig { Tables []TableDef }
- Data models for application elements (e.g. Process Definition, are defined by the REST API specification
- TableDef#DisplayName defaults to TableDef#Name capitalized, `-` replaced by ` ` (e.g. `job` -> `Job`, `process-definition` -> `Process Definition`)

## API client (api.go)
   - Client struct holds the environment info, *http.Client, generated *operaton.APIClient, and authentication context.
   - The generated client is created from resources/operaton-rest-api.json using OpenAPI Generator.
   - Primary methods:
     - FetchProcessDefinitions() -> []ProcessDefinition (uses generated ProcessDefinitionAPI.GetProcessDefinitions)
     - FetchInstances(processDefinitionKey) -> []ProcessInstance (uses generated ProcessInstanceAPI.GetProcessInstances)
     - FetchVariables(instanceId) -> []Variable (uses generated ProcessInstanceAPI.GetProcessInstanceVariables)
     - TerminateInstance(instanceId) -> error (uses generated ProcessInstanceAPI.DeleteProcessInstance)
   - FetchVariables robustly handles the variable map format returned by the REST API: a map keyed by variable name with VariableValueDto containing value/type; returns []Variable with Name, Value (stringified), Type.
   - Errors are returned and propagated back as errMsg messages.
   - The generated client code is located in internal/operaton/ and includes comprehensive API coverage for all Operaton REST endpoints.

## Configuration (config.go + YAML files)

### EnvConfig (o8n-env.yaml)

- environments: map[string]{ url, username, password, ui_color }
- active: string (name of active environment)

### AppConfig (o8n-cfg.yaml)
- tables: array of TableDef (name, columns)
  - Each table definition corresponds to a resource collection endpoint, e.g.
    `process-definition` -> `GET /process-definition`
  - actions: array of ActionDef
    - name: Action name displayed in the Key bindings in the header section
    - command: Key binding to trigger the command
    - confirmation: When true, then execution requires confirmation

- ColumnDef: { name, visible, width (percent string like "25%"), align }
- For compatibility the application exposes LoadConfig(path) to load legacy single-file config.yaml used by tests; also provides LoadEnvConfig and LoadAppConfig and Save helpers. SaveConfig writes back to o8n-env.yaml and o8n-cfg.yaml (best-effort).

## UI Rendering (main.go View)
   - Vertical layout in exact order:
     1. Header (8 rows unboxed area, 3 columns)
        - Column 1 (left, width 25%): Context information lines (Environment, API URL, User). This column must be left-aligned and use the header area height of 8 rows.
        - Column 2 (center): Key bindings/help text (list of keys and short descriptions).
        - Column 3 (right, fixed width 25 characters): ASCII art logo aligned right.
     2. Context selection box (1 row boxed) — visible when `:` is pressed; otherwise an empty boxed placeholder. It contains a single-line text input.
        - Behavior: input is empty initially; no completions shown until first character typed; inline completion (gray color) shows the remaining suffix of the first matching root context; Tab completes; Enter tries to switch context only if exact match; Esc cancels and clears input.
     3. Main content (boxed table) — uses table.Model to render rows and headers. The table consumes the remaining height between header/context selection/footer. Table header text is uppercase and uses a header color (white). Column widths are computed using the configured percent widths from AppConfig when present; otherwise columns get equal widths.
     4. Footer (1 row) — three columns separated by " | ":
        - Column 1: Context tag (e.g. "<process-definition>") — left aligned, largest column (space for long names like historic-external-task-log); uses environment UI color as background and black text.
        - Column 2: Message — used to display errors (footerError) or other status. Truncated as needed.
        - Column 3: Remote access indicator — single character; displays "⚡" for 0.2s after issuing a REST call; otherwise blank.

## UI Styles and Colors
   - Primary border and accent color: environment.UIColor (from env config).
   - Table header foreground color is white.
   - Completion suffix is gray (#666666) by default.
   - Footer error message style: red (#FF0000) and bold.
   - The context selection input uses the environment border color as its font color by default (config allows extension to custom color names).

## Keybindings and behavior
   - <ctrl+c>: quit
   - e: switch environment (cycles through configured envNames). Persists active environment to o8n-env.yaml (best-effort).
   - r: toggle auto-refresh. When enabled, periodically refresh definitions with interval (5s). When disabled, manual selection changes may set a manualRefreshTriggered flag used for UI hints.
   - : (colon): toggle context-selection input box. Focus is inside the input when open.
     - Typing: appends a single rune per key event to rootInput.
     - Completion: only when rootInput length >= 1; inline suffix shown for the first match.
     - Tab: completes rootInput to the first matching root context.
     - Enter: switch context only when rootInput exactly equals a known root context. When switched:
       - close the input box
       - clear footer errors
       - set currentRoot
       - fetch top-level data for the new context (e.g., process-definitions table rows)
       - set focus of table to the first row (implementation note below)
     - Esc: cancel input and close box.
   - Arrow keys: move selection in list/table. Important: in the process-definition view the arrow keys navigate definitions only; Enter is required to drill down into instances.
   - Page up/down: move selection in list table
   - Enter: drills down from definitions -> instances -> variables. In variables view Enter does nothing.
   - x: mark selected instance for kill; y confirms and calls TerminateInstance.

## Fetching & Flow

- On Init: program sends fetchDefinitionsCmd and triggers the flash (flashOnCmd). fetchDefinitionsCmd uses the current environment to call Client.FetchProcessDefinitions.
- When Enter on a definition selected: fetchInstancesCmd(key) is issued which calls Client.FetchInstances(key) and then applyInstances.
- When Enter on an instance: fetchVariablesCmd(id) issued which calls Client.FetchVariables and then applyVariables.

## Error handling
   - All API errors are returned as errMsg messages and the main Update() stores the error text in m.footerError and schedules a clear after 4 seconds (clearErrorMsg).
   - Rendering functions (applyDefinitions, applyInstances, applyVariables) use defer/recover to catch panics and set m.footerError with an explanatory message rather than letting the program crash.
   - The UI will show error messages prominently in the footer message column with the error style.

## Table definition config: o8n-cfg.yaml
- Top-level: tables: array of { name: string, columns: [ { name, visible, width, align } ] }
- Example table def for process-definitions:
  - name: process-definitions
    columns:
      - name: key
        visible: true
        width: 20%
        align: left
      - name: name
        visible: true
        width: 40%
        align: left
      - name: version
        visible: true
        width: 15%
        align: center
      - name: resource
        visible: true
        width: 25%
        align: left
- Column width interpretation: the UI parses the percent string (e.g., "25%") and computes absolute character widths based on available content width; remaining percentage split equally among unspecified columns.
- Column types:
- Built-in types:
  - id:
      type: string
  - date-time
- Implicit types:
  - columns named `id` or ending with `Id` are implicit of type `id`


## Messages and Commands (Bubble Tea)
    - Messages (Go types): refreshMsg, definitionsLoadedMsg, instancesLoadedMsg, variablesLoadedMsg, dataLoadedMsg, errMsg, flashOnMsg, flashOffMsg, clearErrorMsg, terminatedMsg
    - Commands: fetchDefinitionsCmd, fetchInstancesCmd, fetchVariablesCmd, fetchDataCmd, terminateInstanceCmd, flashOnCmd
    - flashOnCmd returns flashOnMsg that Update() uses to set m.flashActive and schedule flashOffMsg after 200ms.

## Tests
    - Unit tests cover: API client behaviors (mock HTTP server), config loading (legacy and split), and model functions (applyData populates table rows, selection change behaviour triggers manualRefresh flag, flash on/off). Tests are run with `go test ./...`.

## Build and run
  - Build:
  ```bash
  go build -o o8n .
  ```

  - Run:
  ```bash
  ./o8n
  ```

  - Tests:
  ```bash
  go test ./... -v
  ```
    - Regenerate API client:
```bash
./.devenv/scripts/generate-api-client.sh
```

## Implementation notes and edge cases
    - The variables endpoint may return different JSON structures; FetchVariables must try decoding to map[string]{value,type} first and fall back to array decoding (re-request or reuse body accordingly).
    - When computing column widths from percentages, normalize percentages if they do not sum to 100. If some columns do not specify a width, distribute remaining percentage evenly.
    - Table rows must be normalized to the configured column count to avoid panics in the table renderer; implement a normalizeRows(rows, colsCount) helper to pad/truncate rows.
    - Always guard UI render code that depends on external data with recover() so the TUI doesn't crash because of a malformed API response.
    - When context selection is invoked, do not present inline completion until the user has typed at least one character. Tab completes to the first match; Enter requires exact match.
    - When switching root contexts programmatically, update the footer context tag and trigger fetch of the root context's primary resource. Also ensure the table selection/focus moves to the first row (implementation detail: use table.SetCursor or equivalent if available; otherwise ensure rows are selected and visible on first render).

## Developer checklist to reimplement
    - Create Go module, add dependencies: bubbletea, bubbles, lipgloss, yaml.
    - Generate OpenAPI client using .devenv/scripts/generate-api-client.sh from resources/operaton-rest-api.json.
    - Define configuration structs and YAML load/save functions.
    - Implement API client wrapper (api.go) that uses the generated OpenAPI client with robust handling of nullable types.
    - Implement Bubble Tea model with the fields and helpers described.
    - Implement Update() key handling and command orchestration.
    - Implement View() rendering the header (8 rows), boxed context selection (1 row), main boxed table (remaining height minus footer), and footer (1 row) with three columns and separators.
    - Add tests for config loading, client behavior, and simple UI logic.

## Example flows
    - Start app -> default env selected -> fetch process definitions -> show table -> user navigates with arrows -> press Enter on definition -> fetch instances -> show instances -> press Enter on instance -> fetch variables -> show variables table (name, value, type)
    - User presses `:` -> types `proc` -> inline completion suggests `ess-definitions` remainder -> Tab completes to `process-definitions` -> Enter switches context (if exact) and reloads table.



Appendix
---------------------------------

## Important API endpoints (Operaton engine-rest example)
- GET /process-definition
- GET /process-instance?processDefinitionKey=<key>
- GET /process-instance/{id}/variables
- DELETE /process-instance/{id}

OpenAPI Client Generation
-------------------------
The application uses a generated Go client from the OpenAPI specification at resources/operaton-rest-api.json.

Generation Process:
- The script .devenv/scripts/generate-api-client.sh uses OpenAPI Generator (via Docker) to generate the client code.
- Generated files are placed in internal/operaton/.
- The generation uses the "go" generator with the following configuration:
  - Package name: operaton
  - isGoSubmodule: true (integrates with the main module)
  - withGoMod: false (uses the main go.mod)
- Generated files include API services for all endpoints, model DTOs, and configuration/authentication helpers.

Using the Generated Client:
- The api.go file wraps the generated client to provide a simpler interface for the application.
- Authentication is configured via context using operaton.ContextBasicAuth with BasicAuth credentials.
- The generated client uses NullableString, NullableInt32, and NullableBool types for optional fields.
- Helper functions (getStringValue, getInt32Value, getBoolValue) safely extract values from nullable types.

Regenerating the Client:
- Run .devenv/scripts/generate-api-client.sh whenever the OpenAPI specification is updated.
- The script requires Docker to be available.
- After generation, run `go mod tidy` to update dependencies (the script does this automatically).

Contact
-------
If details are unclear or you want the spec extended (for example to include exact unit-test cases, more detailed layout mockups, or a list of exact table column mappings for all root contexts), tell me which parts to expand and I will update the specification.md accordingly.
